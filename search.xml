<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[技巧集合]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[linux 小技巧 simple command123456789101112131415uname -a # 查看Linux内核版本信息cat /proc/version # 查看内核版本cat /etc/issue # 查看系统版本lsb_release -a # 查看系统版本 需安装 centos-releaselocale -a # 列出所有语系locale # 当前环境变量中所有编码hwclock # 查看时间who # 当前在线用户w # 当前在线用户whoami # 查看当前用户名logname # 查看初始登陆用户名uptime # 查看服务器启动时间sar -n DEV 1 10 # 查看网卡网速流量dmesg # 显示开机信息lsmod # 查看内核模块 Descriptionsedsed 执行系统命令。查找当前目录以及子目录中以 “.sh”,并改为以”.shell”结尾。find ./a -type f -regex &quot;.*/.sh$&quot; | sed -r -n &#39;s#(.*\.)sh$#mv &amp; \1shell#e&#39; -regex: 使用正则表达式&quot;.*/.sh$&quot; 给出的正则表达式必须要匹配完整的文件路径,比如：find / -regex &quot;find&quot; 这样子是找不到/usr/bin/find的，要像这样find / -regex &quot;.*find&quot;或者更精确一点find / -regex &quot;.*/find&quot; &amp;: 匹配前面找到的内容 e: 末尾的e表示# #这里允许执行命令然后得到结果#,也就是mv 前面匹配到的.sh文件 任意内容.shell]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ghost]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[As long as it starts it will not end！ body{ background-image:url(https://ws1.sinaimg.cn/large/005RRiqRly1fvw1bz9he2j33dc28w4qu.jpg); background-position:center; background-repeat:repeat-y； } 魔术剪辑届 “巫男” 的创意新作《魔术》本文作分享，请勿用于商业用途。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[style]]></title>
    <url>%2F2018%2F08%2F28%2F%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文章写作样式 样式且不问结果如何，尽自己之所能，积极的面对。Content (md partial supported) 站点配置文件 主题配置文件 站点配置文件 主题配置文件 Download Now 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 点击访问博客 居中引用 1.数字块定义 5.命令历史相关环境变量 本文旨在介绍样式的使用规则。 本文旨在介绍样式的使用规则。 本文旨在介绍样式的使用规则。 GA17 YouTube ghost.me I heard the echo, from the valleys and the heartOpen to the lonely soul of sickle harvestingRepeat outrightly, but also repeat the well-being ofEventually swaying in the desert oasisI believe I amBorn as the bright summer flowersDo not withered undefeated fiery demon ruleHeart rate and breathing to bear the load of the cumbersomeBored GA17 1GA17 2GA17 3GA17 4你是谁，你来自哪里我是一个怪物，来自我也不知道的地方f你觉得你死了，还有有人记得你吗]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F28%2F%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目归档 第二周 描述linux目录结构以及目录结构命名规定所有的目录都是按照一定的类别有规律的组织和命名的.FHS（目录层次结构）是Linux的目录规范标准.不要使用特殊字符来命令目录名。和glob字符或许会有冲突FHS（目录层次结构）: http://www.pathname.com/fhs/总结流程图:http://naotu.baidu.com/file/90bbd454b261551260c4e75ca6564f0d 显示/etc目录下，所有以.d结尾的文件或目录ls -d /etc/*.d -d 只显示当前文件夹 显示/etc目录下，所有.conf结尾，且以m,n,r,p开头的文件或目录ls /etc/[mnrp]*.conf 创建/app/rootdir目录，并复制/root下所有文件到该目录内， 要求保留原有权限 12345[root@centos7 /]# mkdir -p /app/rootdir[root@centos7 /]# cp -a /root/ !$cp -a /root/ /app/rootdir[root@centos7 /]# ls /app/rootdir/root 使用命令行展开功能，创建/tmp/a1, /tmp/a2, /tmp/a1/a, /tmp/a1/b，在/tmp目录下创建目录：x_y, x_z, q_y, q_zmkdir {x,q}_{y,z} 总结用户、用户组管理命令并演示命令以及常见用法useradd 创建用户 http://holyghost.me/2018/08/28/linux%20command/-u 指定UID -g 指定所属组或gid -c “文字” 用户的注释信息 -d 指定家目录 -s 指定用户的默认登录的shell,可用列表在/etc/shells文件中 -G 指定用户的附加组，要先创建useradd -u 678 -g pan -c &quot;测试&quot; -d /data -s /bin/sh aaauserdel -r username 删除用户及所属的家目录和邮件groups username 显示linux用户所属的组groupadd groupname 创建组usermod -g root username将用户username的组修改为root组usermod -a -G-a -G 无限增加到附加组，可拥有多个附加组.将a1添加附加组user3 usermod -a -G user3 a1 某一用户拥有多个附加组之后，使用usemod -G会修改附加组，则多个组消失掉变成唯一当前修改的附加组 文件权限，属主属组管理命令有哪些，并演示命令以及用法chmod 更改文件权限：chmod 777 a http://holyghost.me/2018/08/28/linux%20command/chown 更改文件拥有者和所属组：chown USER:GROUP 对象 chown USER 对象 chown :group 对象chgrp 改变文件或目录所属的组: chgrp - R book /opt/local /book 改变/opt/local /book/及其子目录下的所有文件的属组为book 创建用户gentoo，附加组为bin和root，默认shell为/bin/csh，注释信息为 “Gentoo Distribution”useradd -G bin,root -s /bin/sh -c &quot;Gentoo Distribution&quot; gentoo]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mage]]></title>
    <url>%2F2018%2F08%2F28%2F%E9%A9%AC%E5%93%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux 培训的笔记 命令积累lscpu 查看cpu信息 lsblk （列出块设备）命令用于列出所有可用块设备的信息sosreport 收集日志 查看内存：cat /proc/meminfo 进制转换123456789101112130 01 110 2 11 3100 4 101 5 110 6 111 71000 8(2^3)10000 16(2^4)100000 32(2^5)1000000 64(2^6)10000000 128(2^7) 2^0=1 2^1=2 2^2=4 2^3=8 16 32 64 128例：97(十进制)=64+32+1=1000000+100000+1=1100001。例：10101010(二进制)=128+32+8+2=170。1Gbps：每秒传输1g的位。1Gbit/second1Byte=8bit touch建立带-的文件:touch -- -atouch ./-b DAS NAS SAM 存储基础知识—存储网络 DAS NAS SAM 传输类型 SCSI、FC IP IP、FC、SAS 数据类型 数据块 文件 数据块 典型应用 任何 文件服务器 数据库应用 优点 磁盘与服务器分离，便于统一管理 不占用应用服务器资源 高扩展性，高可用性，数据集中，易管理 缺点 连接距离短，数据分散，共享困难，存储空间利用率不高，扩展性有限 不适合存储大量的块级应用，数据备份已恢复占用网络带宽 相比NAS成本较高，安装和升级比NAS复杂 分区分区分配一个目录名mount point,名为挂载分区：MBR,GPT主：一个硬盘最多有四个，只有一个是活动，1-4扩展：最多一个，划分更小的分区，扩展+主分区&lt;=4 1-4逻辑分区：5,6 运行模式：runlevel3 5.3表示前一次的运行级别，5表示现在的运行级别N:表示前一次没有运行级别 。init 3：切换到3级别，init要登录startx:切换到？级别，startx不需要登录5：字符界面 0：关机 6：重启 终端tty显示终端号chvt 2:表示ctrl+Alt+F2切换到的界面 centos7启动网络启动网络：nmcli connection modify ens33 connection.autoconnect yesid -u:当前用户的UID，root为0，非0为普通用户。 查看版本号cat /etc/centos-release lsb_release -a 命令提示符查看：echo $PS1更改：PS1=&quot;\[\e[1;33m\][\u@\h \w \!]\\$\[\e[0m\]&quot;命令提示符:prompt # :管理员 $ :普通用户显示提示符格式：echo $PS1修改提示符格式：PS1=&quot;\e[1;5;41;33m\[\u@h\W]\\$\[\e[0m&quot;\e \033 \u 当前用户 \h 主机名称 \H 主机名 \w 当前工作目录 \W 当前工作目录基名 \t 24小时时间格式 \T 12小时时间格式 \！命令历史数 \# 开机后命令历史数cat ~/.bashrc 命令提示符当前用户修改路径 虚拟机取消密码进入123vim /etc/gdm/custom.conf AutomaticLoginEnable=true AutomaticLogin=root 查看命令类型type pwd:显示命令的类型外部命令或者内部命令 -a :显示所有的内部命令后外部命令的列表 执行命令输入命令后回车:提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来。在shell中可执行的命令有两类1.内部命令：由shell自带的，而且通过某种命令形式提供 help内部命令列表enable cmd 启动内部命令enable -n cmd 禁用内部命令enable -n 查看所有禁用的内部命令2.外部命令：在文件系统路径下有对应的可执行程序文件查看路径：which -a |–skip-alias; whereis3.区别指定的命令是内部或外部命令type COMMANDwhereis:查看外部命令路径和他的配置文件文档路径 命令执行路径alias –内部 –hash表(记录外部命令的路劲) –$PATH –命令找不到 Hash缓存表 系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将这条命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先会查看hash表，存在将执行之，如果不存在，将会去PATH路径下寻找，利用hash缓存表可大大提高命令的调用率。 hash常见用法 hash 显示hash缓存 hash -l 显示hash缓存，可作为输入使用 hash -p path name 将命令全路径path起别名为name hash -t name 打印缓存中name的路径 hash -d name 清除name缓存 hash -r 清除缓存 别名显示当前shell进程所有可用的命令别名alias定义别名NAME，其相当于执行命令VALUEalias NAME=&#39;VALUE&#39;在命令行中定义的别名，仅对当前shell进程有效如果想要永久有效，要定义在配置文件中 仅对当前用户： ~/.bashrc 对所有用户有效： /etc/bashrc 写入文件后，文件存储在磁盘上没有生效，必须让他在内存中才会生效，使用命令source.bashrc删除别名(指在内存中删除)：unalias 别名编辑配置给出的新配置不会立即生效bash进程重新读取配置文件. 12source /path/to/config_file./path/to/config_file 撤销别名: unalias [name] -a取消所有别名如果别名同原命令同名，如果要执行原命令，可使用12345\ALIASNAME&quot;ALIASNAME&quot;&apos;ALIASNAME&apos;command ALIASNAME/path/command 针对外部命令 . 日期和时间linux的两种时钟系统时钟：由Linu内核通过CPU的工作频率进行的硬件时钟：主板相关命令:date 显示和设置系统时间 date +%s date -d @1509536033hwclock,clock:显示硬件时钟-s,–hctosys 以硬件时钟为准，校正系统时钟-w,–systohc 以系统时钟为准，校正硬件时钟时区：/etc/localtime显示日历：cal whoami用户登录信息查看命令:whoami :显示当前登录有效用户who :系统当前所有的登录会话w :系统当前所有的登录会话及所做的操作. 远程协助：screen screen 命令：创建新screen会话 screen -S [SESSION]加入screen会话 screen -x [SESSION]退出并关闭screen会话 exit剥离当前screen会话 Ctrl+a,d显示所有已经打开的screen会话 screen -ls恢复screen会话 screen -r [SESSION]. echolinux中换行表示：移动到下一行回车：光标移动到行首说明：echo会将输入的字符送往输出。输出的字符串间以空白字符隔开，并在最后加上换行号。-E :(默认)不支持\解释功能 -n :不自动换行 -e :启用\字符的解释功能 显示变量：echo &quot;$VAR_NAME&quot; 变量会替换，弱引用 单双引号的区别echo &#39;$VAR_NAME&#39; 变量会替换，强引用反引号里面可执行命令（可用$(命令)代替）`` ls -l `echo $SHELL` 得到的是/bin/bash 文件的详细信息 启用命令选项：-e,若字符串中出现以下字符，则特别加以处理，而不会将他当成一般文字输出\a :发出警告声\b :退格键\c :最后不加上换行符号\n :换行且光标移动至行首\r :回车，即光标移动至行首，但不换行\t :插入Tab字符\ :插入\字符\0nnn :插入nnn(八进制)所代表的ASCII字符 echo -e &#39;\033[43;31;5mmagedu\033[0m&#39;\xHH插入HH(十六进制)所代表的ASCII数字(man 7 ascii) hexdump查看”二进制”文件的十六进制编码123456[root@centos7localdomain ~]# hexdump -C a00000000 31 0a |1. |00000002[root@centos7localdomain ~]# hexdump -C a00000000 31 32 0a 33 0a 61 0a |12.3.a. | 00000007 查看文件a的十六进制和ASCII码。偏移量；十六进制；ASCII码； 原始数据 （最后有空格）文件原始数据每行一个数。 Centos7设置语言localectl list-locales查看语言列表localectl set-locale LANG=en_US.utf8 修改修改后要注销再登录cat /etc/locale.conf 符号命令行扩展，被括起来的集合命令行扩展: $()或``把一个命令的输出打印给另一个命令的参数 1234echo &quot;This system&apos;s name is $(hostname)&quot;This system&apos;s name is server1.example.com echo &quot;i am `whoami`&quot;i am root 括号扩展:{}打印重复字符串的简化形式echo file{1,3,5} 结果为: file1 file3 file5rm -fr file{1,3,5}echo {1..10}echo {a..z}. whatiscentos6生成whatis数据库:makewhatisCentos7: mandbwhatis:显示命令的简短叙述;使用数据库;刚安装后不可立即使用makewhatis | mandb 制作数据库使用示例: whatis cal 或 man -f cal history 重复前一个命令使用上方向键，并且执行 按!!并回车执行 输入!-1执行倒数第一个命令 按Ctrl+p 并回车执行!:0 执行前一条命令(去除参数)Ctrl+n 显示当前历史中的下一条命令，但不执行Ctrl+j 执行当前密令!n 执行history命令输出对应序号n的命令!-n 执行history历史中倒数的第n个命令!string 重复前一个以”string”开头的命令!?string 重复前一个包含string的命令!string:p 仅打印命令历史，而不执行!$:p 打印输出!$(上一条命令的最后一个参数)的内容!*:p 打印输出!*(上一条命令的所有参数)的内容^string 删除上一条命令中的第一个string^string1^string2 将上一条命令中的第一个string1替换为string2!:g/s/string/string2 将上一条命令中所有的string1都替换为string2 3. 使用up(向上)和down(向下)键上下浏览从前输入的命令ctrl+r 在历史命令中搜索ctrl+g 从历史搜索模式中退出要重新调用前一个命令中最后一个参数：!$ESC,.(点击ESC键后松开，然后点击.键)Alt+. (按住Alt键的同时点击.键) 4. command !^ 利用上一个命令的第一个参数做cmd的参数.command !$ 利用上一个命令的最后一个参数做cmd的参数command !* 利用上一个命令的全部参数做cmd的参数command !:n 利用上一个命令的第n个参数做cmd的参数command !n:m 调用第n条命令的第m个参数command !n:* 调用第n条命令的所有参数 -c :清空命令历史 -d offser :删除历史中指定的第offser个命令 n :显示最近的n条历史 -a :追加本次会话新执行的命令历史列表至历史文件 -r :读历史文件附加到历史列表 -w :保存历史列表到指定的历史文件 -n :读取历史文件中未读过的行到历史列表 -p :展开历史参数成多行，但不存在历史列表中 -s :展开参数成一行，附加在历史列表后 -p:可以执行命令但不存在历史记录中。-s:伪造历史，不执行命令。HISTTIMEFORMAT=&quot;%F %T &quot;历史加上时间. 5.命令历史相关环境变量 HISTSIZE :命令历史记录的条数HISTFILE :指定历史文件，默认为~/.bash_history HISTFILESIZE :命令历史文件记录历史的条数 HISTTIMEFORMAT= “%F %T” 显示时间 HISTIGNORE= “str1:str2*……” 忽略str1命令，str2开头的历史 控制命令历史的记录方式： 环境变量：HISTCONTROL ignoredups 默认，忽略重复的命令，连续且相同为”重复” ignorespace 忽略所有已空白开头的命令 ignoreboth 相当于ignoredups,ignorespace的组合 erasedups 删除重复命令export 变量名=”值”存放在 /etc/profile 或 ~/.bash_profile. man查看man手册页 man [章节] keyword列出所有帮助 man -a keyword搜索man手册 man -k keyword 列出所有匹配的页面相当于whatis 数据库 man -f keyword打印man帮助文件的路径 man -w [章节] keyword man 命令的操作方法：使用less 命令实现待续写 man搜索待续写 bash 的快捷键待续写 基名，目录名basename :取文件基名dirname :取文件目录名 centos6自动挂载cd /misc/cd 目录磁盘会自动挂载 通配符* 匹配零个或多个字符? 匹配任何单个字符~ 当前用户家目录 ~mage 用户mage家目录~+ 当前工作目录~- 前一个工作目录[0-9] 匹配数字范围 [a-z]:字母 [A-Z]:字母 [wang]匹配列表中的任何的一个字符[^wang] 匹配列表中的所有字符以外的字符ls 1[a-z].txt:不会显示出小写字母到大写字母的文件，他会以小写大写的顺序排列出来预定义的字符类：man 7 glob [:digit:] :任意数字，相当于0-9[:lower:] :任意小写字母[:upper:] :任意大写字母[:alpha:] :任意大小写字母[:alnum:] :任意数字或字母[:blank:] :水平空白字符[:space:] :水平或垂直空白字符[:punct:] :标点符号[:print:] :可打印字符[:cntrl:] :控制(非打印)字符[:graph:] :图形字符[:xdigit:] :十六进制字符ls .[^.]*显示当前目录下的隐藏目录ls -d .*ls -l &quot;[^.]*&quot; -a 三种显示方式 atime mtime ctime待写 cp待写 mv待写 rename将main1.c重命名为main.c rename main1.c main.c main1.c如果使用rename foo foo0 foo?，会把foo1到foo9的文件重命名为foo01到foo09，重命名的文件只是有4个字符长度名称的文件，文件名中的foo被替换为foo0。 如果使用rename foo foo0 foo??，foo01到foo99的所有文件都被重命名为foo001到foo099，只重命名5个字符长度名称的文件，文件名中的foo被替换为foo0。rename支持正则表达式:rename &quot;s/AA/aa/&quot; //把文件名中的AA替换成aa修改文件的后缀 rename &quot;s//.html//.php/&quot; //把.html 后缀的改成 .php后缀批量添加文件后缀 rename &quot;s/$//.txt/&quot; //把所有的文件名都以txt结尾批量删除文件名 rename &quot;s//.txt//&quot; //把所有以.txt结尾的文件名的.txt删掉如我们想把文件扩展名为.bak 的文件扩展名去掉，可以这样 rename &#39;s/.bak$//&#39; \*.bak*.bak 为通配符(wildcard)，会被shell展开为各个文件名 123去除文件名中的空格 rename &apos;s/ //g&apos;g 是global的意思，替换所有的空格为空字符（也就是删除啦） 文件名转为小写: rename &apos;y/A-Z/a-z/&apos; tree显示目录树 -d :只显示目录 -L level :指定显示的层级数目 -P pattern :只显示由指定pattern匹配到的路径tree -P /etc/rc* mkdir创建目录 -p :存在于不报错，且可自动创建所需的各目录 -v :显示详细信息 -m MODE :创建目录时直接指定权限 rmdir删除空目录 -p :递归删除父目录(rmdir -p:从下往上删除，从深往浅删除) -v :显示详细信息rm -r :递归删除目录树 例：1.创建/testdir/dir1/x,/testdir/dir1/y,/testdir/dir1/x/a,/testdir/dir1/x/b,/testdir/dir1/y/a,/testdir/dir1/y/bmkdir -p ./testdir/dir1/{x,y}/{a,b}2.创建/testdir/dir2/x,/testdir/dir2/y,/testdir/dir2/x/a,testdir/dir2/x/bmkdir -p testdir/dir2{x/{a,b},y}3.创建/testdir/dir3,/testdir/dir4,/testdir/dir5,/testdir/dir5/dir6,testdir/dir5/dir7mkdir -p ./testdir/dir{3,4,5/dir{6,7}} inode索引节点:inode(index node)表中包含文件系统所有文件列表一个节点(索引节点)是在一个表项，包含有关文件的信息(元数据),包括： 文件类型,权限,UID,GID 链接数(指向这个文件名路径名称个数) 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 硬软链接tr用户，组idsupasswdchage修改用户密码状态chagechage [选项] 用户名 -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期(shadow3字段) -m 天数:两次密码修改间隔(4字段) -M 天数:密码有效期(5字段) -W 天数:密码过期前警告天数(7字段) -I 天数:密码过后宽限天数(7字段) -E 日期:账号失效时间(8字段)chage -d 0 username这个命令其实是把密码修改日期归0了(shadow第3字段)，这样用户只要一登录就要修改密码。第三字段是指密码最后一次修改时间的日期。1970年1月1号到现在修改密码的时间戳。如果第3字段改为0，系统会认为用户没有修改过操作密码，那么当此用户一旦登录系统就会提示要修改密码，才可正常使用。. groupmodgroupmemsumaskSUID SGID STICKYchattrACLcat,head,tail,cutpastewcsortuniqpatchgrep–color=auto: 对匹配到的文本着色显示 -v: 显示不被pattern匹配到的行 -i: 忽略字符大小写 -n：显示匹配的行号 -c: 统计匹配的行数 -o: 仅显示匹配到的字符串 -q: 静默模式，不输出任何信息 -A #: after, 后#行 -B #: before, 前#行 -C #：context, 前后各#行 -e：实现多个选项间的逻辑or关系 grep –e &#39;cat&#39; -e dog&#39; file-w：匹配整个单词 -E：使用ERE -F：相当于fgrep，不支持正则表达式 -f file: 根据模式文件处理 正则表达式字符匹配基本正则表达式元字符. 匹配任意单个字符[] 匹配指定范围内的任意单个字符，示例：[wang] [0-9] [a-z] [a-zA-Z][^] 匹配指定范围外的任意单个字符[:alnum:] 字母和数字[:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z[:lower:] 小写字母 [:upper:] 大写字母[:blank:] 空白字符（空格和制表符）[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广） [:cntrl:] 不可打印的控制字符（退格、删除、警铃…）[:digit:] 十进制数字 [:xdigit:]十六进制数字[:graph:] 可打印的非空白字符[:print:] 可打印字符[:punct:] 标点符号 匹配次数用在要指定次数的字符后面，用于指定前面的字符要出现的次数* 匹配前面的字符任意次，包括0次贪婪模式：尽可能长的匹配.* 任意长度的任意字符\? 匹配其前面的字符0或1次\+ 匹配其前面的字符至少1次\{n\} 匹配前面的字符n次\{m,n\} 匹配前面的字符至少m次，至多n次\{,n\} 匹配前面的字符至多n次\{n,\} 匹配前面的字符至少n次 位置锚定定位出现的位置：^ 行首锚定，用于模式的最左侧$行尾锚定，用于模式的最右侧^PATTERN$ 用于模式匹配整行^$ 空行^[[:space:]]*$ 空白行\&lt; 或 \b 词首锚定，用于单词模式的左侧\&gt; 或 \b 词尾锚定，用于单词模式的右侧\&lt;PATTERN\&gt; 匹配整个单词 数字,字母,下划线,不能作为单词的分隔符。. 分组\(\) 将一个或多个字符捆绑在一起，当作一个整体处理，如：\(root\)\+分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \1, \2, \3, …\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符 示例： \(string1\+\(string2\)*\)\1: string1\+\(string2\)*\2: string2后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身或者：|示例：a|b: a或b C|cat: C或cat (C|c)at:Cat或cat ^ 行首$ 行尾 . 任意单一字符 [][]内任意单一字符 [^] 除[]内任意单一字符 * 前面字符重复不确定次数 \+ 前面字符重复一次以上不确定次数 \? 前面字符重复0或1次 \ 转义符.* 任意长度字符 \{n\} 前面字符重复n次 \{n,\} 前面字符重复n次以上\{m,n\} 前面字符重复m次和n次之间 扩展正则egrep = grep -Eegrep [OPTIONS] PATTERN [FILE…]扩展正则表达式的元字符：字符匹配：.任意单个字符 [] 指定范围的字符 [^] 不在指定范围的字符次数匹配：* 匹配前面字符任意次 ? 0或1次 + 1次或多次 {m} 匹配m次 {m,n} 至少m，至多n次位置锚定：^ 行首 $ 行尾 \&lt;, \b 语首 \&gt;, \b 语 尾分组：()后向引用：\1, \2, …或者：a|b a或bC|cat C或cat(C|c)at Cat或cat vim脚本编程环境变量算术运算颜色指定条件测试Bash的文件权限测试Bash的文件属性测试Bash的组合测试条件read编辑配置文件生效Bash 退出任务$-locatefind指搜索层级-maxdepth level 最大搜索目录深度，指定目录为第1级-maindepth level 最小搜索目录深度find /data -maxdepth 2 -mindepth 2 -name &quot;*.sh&quot; 表示只在/data下的二级目录下搜索先处理目录内的文件，再处理目录 -depth根据文件名和inode查找： -name “文件名称”:支持使用glob *,?,[],[^] -iname “文件名称”:不区分字母大小写 -inum n 按inode号查找 -samefile name 相同inode号的文件 -links n 链接数为n的文件 -reges “PATTERN”:以PATTERN匹配整个文件路径，而非文件名称 查找条件根据属主，属组查找：-user USERNAME :查找属主为指定用户(UID)的文件 -group GROUPNAME :查找属组为指定组(GID)的文件 -uid UserID :查找属主为指定的UID号的文件 -gid GroupID :查找属组为指定的GID号的文件 -nouser :查找没有属主的文件 -nogroup :查找没有属组的文件 根据文件类型查找：-type TYPE: f :普通文件 d :目录文件 l :符号链接文件 s :套接字文件 b :块设备文件 c :字符设备文件 p :管道文件空文件或目录： -emptyfind /app -type d -empty 查找条件组合条件： 与：-a 或：-o 非：-not,!德 摩根定律：(非A)或(非B)=非(A或B)(非A)且(非B)=非(A或B)示例： !A -a !B = !(A -o B) !A -o !B = !(A -a B) 根据文件大小来查找 -size[+|-]#UNIT 常用单位:k,M,G,c(byte) #UNIT:(#-1,#] 如: 6k表示(5k,6k] -#UNIT:[0,#-1] 如: +6k表示(0,5k] +#UNIT:(#,∞) 如: +6k表示(6k,∞) 根据时间戳：以”天”为单位-atime [+|-]#, #:[#,#+1) +#:[#+1,∞] -#:[0,#)-mtime-ctiime以”分钟”为单位-amin-mmin-cmin atime、ctime、mtime的区别atime：上一次访问这个文件是什么时候ctime：上一次改变这个文件的属性(元数据)是什么时候mtime：上一次改变这个文件的内容是什么时候 根据权限查找：-perm[/|-]MODE MODE:精确权限匹配 /MODE:任何一类(u,g,o)对象的权限中只要能一位匹配即可，或关系，从centos7开始淘汰 -MODE:每一类对象都必须同时拥有指定权限，与关系 ０:表示不关注find -perm 755会匹配权限模式恰好是755的文件只有当任意人有写权限时，find -perm +222就会匹配只要当每个人都有写权限时，find -perm -222才会匹配只要当其他人(other)有写权限时，find -perm -002 才会匹配 处理动作-exec COMMAND {} \;:对查到的每个文件执行有COMMAND指定的命令{}:用于引用查找到的文件名称自身find传递查找到的文件至后面的命令时，查找到所有符合条件的文件一次性传递给后面的命令 参数替换xargs由于很多命令不支持管道|来传递参数，而日常工作中有这个必要，所以就有了xargs命令xargs用于产生某个命令的参数，xargs可以读入stdin的数据，并且已空格符或回车将stdin的数据分隔为arguments注意:文件名或者是其他意义的名词内含有空格符的情况有些命令不能接受过多参数，命令执行可能会失败，xargs可以解决示例：ls f* | xargs rmfind /sbin -perm +700 | ls -l 这个命令是错误的,ls不支持标准输入find /sbin -perm +7000 | xargs ls -l 查找特殊权限的文件find和xargs格式:find | xargs COMMAND 压缩compress [-dfvcVr]\[-b maxbits]\[file…] -d :解压缩，相当于gunzip -c :结果输出至标准输出，不删除原文件 -v :显示详情 uncompress 解压缩zcat file.Z &gt; file gzip/gunzip-d:解压缩，相当于gunzip-c :结果输出至标准输出，保留源文件不改变 -# :1-9，指定压缩比，值越大压缩比越大 zcat:不解压缩的前提下查看文本文件内容示例： gzip -c messages &gt; messages.gzgzip -c -d message.gz &gt; messageszcat messages.gz &gt; messagescat messages | gzip &gt; m.gz bzip2/bunzip2/bzcatbzip2 [option]…FILE… -k :keep，保留原文件 -d :解压缩 -# :1-9,压缩比，默认为9 bzcat:不显示解压缩的前提下查看文件文件内容 xz/unxz/xzcatxz[OPTION]…FILE… -k :keep，保留原文件 -d :解压缩 -# :1-9，压缩比，默认为6unxz file.xz 解压缩xzcat: 不显示解压缩的前提下查看文本文件内容 zip/unzip 打包压缩zip -r /backup/sysconfig /etc/sysconfig解包解压缩unzip sysconfig.zipcat /var/log/messages | zip messages -unzip -p message &gt; message tar工具-exclude 排除文件 tar zcvf /root/a3.tgz --exclude=/app/host1 --exclude=/app/host2/app-T选项指定输入文件，-X选项指定包含要排除的文件列表 tar zcvf mybackup.tgz -T /root/includefilelist -X /root/excludefilelist splist:: 分割一个文件为多个文件分割大的tar文件为多份小文件split -b Size -d tar-file-name prefix-namesplit -b 1M -d mybackup.tgz mybackup-partssplit -b 1m mybackup.taz mybackup-parts合并：cat mybackup-parts* &gt; mybackup.tar.gz spilt -b 2M -d /root/data.tar.xz databak -d会以数字结尾 cpio功能：cpio用于创建、解压归档文件，也可以对归档文件执行拷入拷出的动作，即向归档文件中追加文件，或从归档文件中提取文件。它也支持tar格式的归档文件，但是对压缩后的tar(如.tar.gz格式)就没法支持了，cpio毕竟不会调用对应的(解)压缩工具。cpio命令是通过重定向的方式将文件进行打包备份，还原恢复的工具，它可以解压以.cpio或者.tar结尾的文件 cpio [选项] &gt; 文件名或者设备名cpio [选项] &lt; 文件名或者设备名 -o 将文件拷贝打包成文件或者将文件输出到设备上 -O filename 输出到指定的归档文件名 -A 向已存在的归档文件中追加文件 -i 解包，将打包文件解压或将设备上的备份还原到系统 -I filename 对指定的归档文件名解压 -t 预览，查看文件内容或者输出到设备上的文件内容 -F filename 使用指定的文件名替代标准输入或输出 -d 解包生成目录，在cpio还原时，自动的建立目录 -v 显示打包过程中的文件名称 将etc目录备份：find ./etc -print |cpio -ov &gt;bak.cpio 将/data内容追加bak.cpio find /data | cpio -oA -F bak.cpio 内容预览cpio –tv &lt; etc.cpio 解包文件 cpio –idv &lt; etc.cpio . sed-n 不输出模式空间内容到屏幕，即不自动打印 -e 多点编辑 -f /PATH/SCRIPT_FILE 从指定文件中读取编辑脚本 -r 支持使用扩展正则表达 -i.bak 备份文件并原处编辑script: &#39;地址命令&#39;地址定界： (1) 不给地址：对全文进行处理(2) 单地址： #: 指定的行，$：最后一行 /pattern/：被此处模式所能够匹配到的每一行(3) 地址范围： #,# #,+# pat1/,/pat2/ #,/pat1/(4) ~：步进 1~2 奇数行, 2~2 偶数行sed -i.back &#39;/^root/aadmin line passwd&#39; 插入并备份原文件. 编辑命令d 删除模式空间匹配的行，并立即启用下一轮循环p 打印当前模式空间内容，追加到默认输出之后a []text在指定行后面追加文本，支持使用\n实现多行追加i []text在行前面插入文本c []text 替换行为单行或多行文本w /path/file 保存模式匹配的行至指定文件r /path/file读取指定文件的文本至模式空间中匹配到的行后= 为模式空间中的行打印行号! 模式空间中匹配行取反处理 sed &#39;/^UUID/r /etc/issue&#39; /etc/fstab 读取/etc/issue中的内容到/etc/fstab UUID开头的行后 123456seq 10 | sed &apos;1~2d&apos; 输出双数的行 seq 10 | sed &apos;axxx\nyyy\nzzz&apos; sed &apos;/^root/i\ admin line&apos; /etc/passwd 加入了空格 sed &apos;/^root/aadmin line&apos; /etc/passwd sed &apos;/^UUID/w f1&apos; /etc/fstab sed &apos;/^UUID/=&apos; /etc/fstab 打印UUID开头的行显示行号 sed替换s/// 查找替换,支持使用其它分隔符，s@@@，s###替换标记：g 行内全局替换p 显示替换成功的行w /PATH/FILE 将替换成功的行保存至文件中例：sed -n &#39;s/UUID/tempfilesystem/gp&#39; /etc/fstabifconfig | sed -n &#39;2p&#39; | sed &#39;s/.*inet //&#39;|sed &#39;s@ netmask.*$@@&#39;ifconfig | sed -nr &#39;2s/.*t (.*) net.*/\1/gp&#39;ifconfig ens33 | sed -r &#39;2!d;s/.*inet (addr:)?//;s/ .*//&#39; sed取IP地址echo /etc/sysconfig/network-scripts/ | sed -nr &#39;s#(^.*/)([^/].*)/?$#\1#p&#39;取基名（不理解）sed大小写转换：sed -r &#39;s/[[:alpha:]]/\u&amp;/g&#39; /etc/fstabsed -r &#39;s/[[:alpha:]]/\l&amp;/g&#39; /etc/fstab sed 示例1234567891011sed ‘2p’ /etc/passwdsed –n ‘2p’ /etc/passwdsed –n ‘1,4p’ /etc/passwdsed –n ‘/root/p’ /etc/passwdsed –n ‘2,/root/p’ /etc/passwd 从2行开始sed -n ‘/^$/=’ file 显示空行行号sed –n –e ‘/^$/p’ –e ‘/^$/=’ filesed ‘/root/a\superman’ /etc/passwd行后sed ‘/root/i\superman’ /etc/passwd 行前sed ‘/root/c\superman’ /etc/passwd 代替行c:是表示将我现在所写的字符与所找到的行全部替换。不是字符替换。 1234567891011sed ‘/^$/d’ filesed ‘1,10d’ filenl /etc/passwd | sed ‘2,5d’nl /etc/passwd | sed ‘2a tea’sed &apos;s/test/mytest/g&apos; examplesed –n ‘s/root/&amp;superman/p’ /etc/passwd 单词后sed –n ‘s/root/superman&amp;/p’ /etc/passwd 单词前sed -e ‘s/dog/cat/’ -e ‘s/hi/lo/’ petssed –i.bak ‘s/dog/cat/g’ petsnl:表示显示行号，空行不显示&amp;：代表前面找到的内容 sed高级P：打印模式空间开端至\n内容，并追加到默认输出之前h: 把模式空间中的内容覆盖至保持空间中H：把模式空间中的内容追加至保持空间中g: 从保持空间取出数据覆盖至模式空间G：从保持空间取出内容追加至模式空间x: 把模式空间中的内容与保持空间中的内容进行互换n: 读取匹配到的行的下一行覆盖至模式空间N：读取匹配到的行的下一行追加至模式空间d: 删除模式空间中的行D：如果模式空间包含换行符，则删除直到第一个换行符的模式空间中的文本，并不会读取新的输入行，而使用合成的模式空间重新启动循环。如果模式空间不包含换行符，则会像发出d命令那样启动正常的新循环12345678910sed -n &apos;n;p&apos; FILEsed &apos;1!G;h;$!d&apos; FILEsed‘N;D’FILEsed &apos;$!N;$!D&apos; FILEsed &apos;$!d&apos; FILEsed ‘G’ FILEsed ‘g’ FILEsed ‘/^$/d;G’ FILEsed &apos;n;d&apos; FILEsed -n &apos;1!G;h;$p&apos; FILE rpm–test: 测试安装，但不真正执行安装，即dry run模式–nodeps：忽略依赖关系–replacepkgs 强制重新安装已经安装的软件包–replacefiles 替换属于其他软件包的文件–nosignature: 不检查来源合法性 –nodigest：不检查包完整性–noscripts：不执行程序包脚本 %pre:安装前脚本 –nopre %post: 安装后脚本 –nopost %preun: 卸载前脚本 –nopreun %postun:卸载后脚本 –nopostun rpm升级upgrade：安装有旧版程序包，则“升级”如果不存在旧版程序包，则“安装” freshen：安装有旧版程序包，则“升级”如果不存在旧版程序包，则不执行升级操作 rpm -Uvh PACKAGE_FILE …rpm -Fvh PACKAGE_FILE …–oldpackage：降级 –force: 强制安装 注意：(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，可以直接安装新版本内核(2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名(FILENAME.rpmnew)后保留. 包查询-a: 所有包 -f: 查看指定的文件由哪个程序包安装生成 -p rpmfile：针对尚未安装的程序包文件做查询操作 –whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供 –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖rpm2cpio 包文件|cpio –itv 预览包内文件rpm2cpio 包文件|cpio –id &quot;\*.conf&quot; 释放包内文件 –changelog：查询rpm包的changelog -c: 查询程序的配置文件 -d: 查询程序的文档 -i: information -l: 查看指定的程序包安装后生成的所有文件 –scripts：程序包自带的脚本 –provides: 列出指定程序包所提供的CAPABILITY -R: 查询指定的程序包所依赖的CAPABILITY 包校验#rpm -V 已安装的包名选项：-V 校验指定RPM包中的文件。(verify) [root@Tiger ~]#rpm -V httpdS.5….T. c /etc/httpd/conf/httpd.conf验证内容中的8个信息的具体内容如下： S：文件大小是否改变； M：文件的类型或文件的权限(r w x)是否被改变； 5：文件MD5校验和是否改变(可以看成文件的内容是否改变)； D：设备的主，从设备号是否改变； L：文件路径是否改变； U：文件的属主(所有者)是否改变； G：文件的属组是否改变； T：文件的修改时间是否改变；文件类型： c :配置文件(config file) d :普通文档(documentation) g :”鬼”文件(ghost file),很少见，就是该文件不应该被这个RPM包包含 l :授权文件(license file) r :描述文件(read me) 秘钥包来源合法性验正及完整性验证完整性验证：SHA256来源合法性验证：RSA公钥加密对称加密：加密、解密使用同一密钥非对称加密：密钥是成对儿的public key: 公钥，公开所有人secret key: 私钥, 不能公开导入所需要公钥rpm -K|checksig rpmfile 检查包的完整性和签名rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 CentOS 7发行版光盘提供：RPM-GPG-KEY-CentOS-7rpm -qa &quot;gpg-pubkey*&quot; 检查系统公钥 rpm -qa &quot;gpg-pubkey*&quot;[root@centos7 Packages]# rpm --import /mnt/RPM-GPG-KEY-CentOS-7[root@centos7 Packages]# rpm -K tree-1.6.0-10.el7.x86_64.rpm 数据库数据库重建：/var/lib/rpmrpm {–initdb|–rebuilddb} initdb: 初始化如果事先不存在数据库，则新建之否则，不执行任何操作rebuilddb：重建已安装的包头的数据库索引目录 centos6 内核救援 yumyum repolist 查看仓库信息仓库的元数据[root@centos7 ~]# cd /var/cache/yum/x86_64/7/yum history 查看yum安装历史yum history info 2 查看历史中的第二项yum客户端配置文件：/etc/yum.conf：为所有仓库提供公共配置/etc/yum.repos.d/*.repo：为仓库的指向提供配置仓库指向的定义：[repositoryID]name=Some name for this repositorybaseurl=url://path/to/repository/enabled={1|0}gpgcheck={1|0}gpgkey=URLenablegroups={1|0}failovermethod={roundrobin|priority}roundrobin：意为随机挑选，默认值priority:按顺序访问cost= 默认为1000 yum的repo配置文件中可用的变量：$releasever: 当前OS的发行版的主版本号$arch: 平台，i386,i486,i586,x86_64等$basearch：基础平台；i386, x86_64$YUM0-$YUM9:自定义变量实例:123http://server/centos/$releasever/$basearch/ http://server/centos/7/x86_64 http://server/centos/6/i384 实验基于httpd搭建的yum服务器：1234567891011121314151617181920212223242526yum install -y httpdmkdir -pv centos/&#123;6,7&#125;/os/x86_64 html/└── centos ├── 6 │ └── os │ └── x86_64 └── 7 └── os └── x86_64 ├── EFI │ └── BOOT │ └── fonts ├── images │ └── pxeboot ├── isolinux ├── LiveOS ├── Packages └── repodatamount /dev/sr0 html/centos/7/os/x86_64/[base]name=Centos\#baseurl=file:///run/media/pan/CentOS\ 7\ x86_64/baseurl=http://192.168.134.138/centos/$releasever/os/$basearchgpgcheck=0 yum 调用文件路径：123456mirrorlist=http://192.168.134.138/list.txt[root@centos7 html]# lscentos list.txt[root@centos7 html]# cat list.txtfile:///var/www/html/centos/7/os/x86_64baseurl=http://192.168.134.138/centos/$releasever/os/$basearch源码编译123456789101112yum groupinstall &quot;development tools&quot;tar xf cmatrix-1.2a.tar.gzcd cmatrix-1.2a./configure --prefix=/app/cmatrixmake &amp;&amp; make installyum install -y ncurses-devel(缺的包)make &amp;&amp; make installcd /app/cmtrix/bin./cmatrix 写入PATHecho &apos;PATH=/app/httpd/bin:$PATH&apos; &gt; /etc/profile.d/httpd.sh. /etc/profile.d/httpd.sh centos7:支持神奇目录：rpm -q autofssystemctl enabled autofssystemctl start autofs 建立仓库元数据：createrepo /data/repodbyum仓库必须要仓库元数据才能使用 centos 防火墙cnetos7:下次开机不启用 systemctl disable firewalld现在马上关掉：systemctl stop firewalld centos6:chkconfig iptables offservice iptables stop]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[command]]></title>
    <url>%2F2018%2F08%2F28%2Flinux%20command%2F</url>
    <content type="text"><![CDATA[linux 常用命令集合: 写在前面[root@pan ~]# root:登录的用户 @分隔符 pan主机名 ~当前路径\:newline echo $PATHctrl+r:在历史命令中搜索。 ctrl+s:暂停屏幕输出。 ctrl+q:恢复屏幕输出。&quot;&amp;&quot; &quot;||&quot; &quot;!&quot;只用普通用户登录Shell是/bin/bash catcat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ -n 显示的时候，顺道输出行号！ -A:查询所有的内容包括隐藏字符 ls-F:在每个输出项后追加文件的类型标识符，具体含义：“*“表示具有可执行权限的普通文件“/“表示目录 “@”表示符号链接“|”表示命令管道FIFO“=”表示sockets套接字当文件为普通文件时，不输出任何标识符 echo#echo [选项][输出内容] echo -e &quot;\e[1;31m abcd \e[0m&quot; 输出颜色=30m 黑色，=31m 红色，=32m 绿色，=33m 黄色，=34m 蓝色，=35m 洋红，=36m 青色，=37m 白色。&quot;echo -e ab\bc&quot; 控制字符在末尾可能不执行。-e:支持反斜线控制的字符转换 控制字符 作用 \ 输出\本身 \a 输出警告音 \b \退格键，也就是向左删除键 \c 取消输出行末的换行符，和“-n”选项一致 \e ESCAPE键 \f 换页符 \n 换行符 \r 回车键 \t 制表符，也就是Tab键 \v 垂直制表符 \0nm 按照八进制ASCII码输出字符，其中0为数字零，nnn是三位八进制数 \xhh 按照十六进制ASCII码表输出字符。其中hh是两位十六进制数。 I/o redirection输出重定向:命令 &gt; 文件 2&gt;&amp;1 :以覆盖的方式，把正确输出和错误输出都保存在一个文件当中。命令 &amp;&gt;文件 :以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。 &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。1&gt;&amp;2 意思是把标准输出重定向到标准错误.2&gt;&amp;1 意思是把标准错误输出重定向到标准输出&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中 输入重定向：命令 &lt;文件wc [选项] [文件名]选项： -c :统计字节数 -w :统计单词数 -l :统计行数wc &lt; filename12345678wc &lt;&lt; filename wc &lt;&lt; a.txt 注意a.txt &gt; dshi &gt; jdiosjfh &gt; diosjfiojd &gt; fdiojsoifj &gt; hello 4 4 36 sortsort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，不加参数时依次按ASCII码值进行比较，最后将他们按升序输出 -n :依照数值的从小到大排序; -f ：忽略大小写 -r :以相反的顺序来排序; -u :忽略相同行使用-u选项或者uniq 文件名 -t &lt;分隔符&gt;：指定排序时所用的栏位分隔字符； -k n[,m]是按照指定的字段范围排序，从第n字段开始，m字段结束(默认到行尾)（字母按ASCII排序，数字按从小到大。先数字后字母） [root@mail text]# sort -nrk 3 -t: sort.txt 将CC列数字从大到小顺序排列：eee:40:5.4eee:60:5.1ddd:20:4.2ccc:50:3.3bbb:10:2.5aaa:30:1.6AAA:BB:CC 列 指定分隔符是:，用第三字段开头，第三字段结尾排序，就是只用第三字段排序1[root@Tiger data]# sort -n -t &quot;:&quot; -k 3,3 /etc/passwd 但是这样排序会以字符串排序需要以数字排序1sort -n -t &quot;:&quot; -k 3,3 /etc/passwd awk awk &#39;{print $1}&#39; 文件名 $1第一列，$2第二列，$NF最后一列.$(NF-1)倒数第二列）。 现在是以文件的空格为分隔符这样打印 awk-F&quot;:&quot;&#39;{print $1}&#39; /etc/passwd -F指定分隔符，并打印文件第一列 多列打印#awk -F &quot;:&quot; &#39;{print $2 $3}&#39; /etc/passwd 这样打印$2 $3之间是没有分隔符 要加分隔符就是 awk -F &quot;:&quot; &#39;{print $2 &quot;\t&quot; $3}&#39; /etc/passwd $0表示整个文件 df文件系统查看命令 -a:显示所有的文件系统信息信息，包括特殊文件系统，如，/proc,/sysfs -h:使用习惯单位显示容量，如KB,MB或GB等。 -T:显示文件系统类型 -m: 以MB为单位显示容量。 -k:以KB为单位显示容量，默认就是以KB为单位显示容量。 du命令和df命令的区别df:命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间(最常见的就是文件已经删除，但是程序并没有释放空间) du: 命令是面向文件的，只会计算计算机文件或目录占用的空间. du是通过搜索文件来计算每个文件的大小然后累加，du能看到的文件只是一些当前存在的，没有被删除的。他计算的大小就是当前他认为存在的所有文件大小的累加和 -h : 以K，M，G为单位，提高信息的可读性。 -s : 统计总占用量，而不列出子目录和子文件的占用量。ls -h是目录下文件名占用大小 du -h 是目录下所有文件的大小 -k : 以KB(1024bytes)为单位输出。 -m : 以MB为单位输出。 -a显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量。 dddd(磁盘对拷命令)命令用于复制文件并对原文件的内容进行转换和格式化处理 [root@localhost]# dd if=输入文件 of=输出文件 bs=字节数 count=个数选项：if=输入文件 指定源文件或源设备of=输出文件 指定目标文件或目标设备bs=字节数 指定一次输入/输出多少字节，即把这些字节看做一个数据块count=个数 指定输入/输出多少个数据块 date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000(100M) ; data。 fsck文件系统修复命令fsck [选项] 分区设备文件名 -a:不显示用户提示，自动修复文件系统 -y:自动修复。和-a作用一致，不过有些文件系统只支持-y dumpe2fs显示磁盘状态命令 #dumpe2fs 分区设备名 rpmrpm是Linux标准基础（LSB）兼容发行版所使用的一种软件包管理器，用来对软件包进行低级处理rpm可以查询、安装、检验、升级和卸载软件包，它多数用于基于Fedora的系统，比如RHEL和CentOS 只有安装和升级要加包全名。 -ivh: -i:安装，-v:显示详细信息，-h:显示进度，–nodeps：不检测依赖性。 -Uvh包全名：RPM包升级. -q :接软件包名字 #查询软件是否已经安装 -q(查询query) -qa :#查询所有已经安装的RPM包。-a(所有all) -qi :包名字#查询软件包详细信息 -i :显示软件包的相关信息 -ql 包名:查询软件包安装位置 -l :显示套件的文件列表。 -qf +系统文件名。查看一个文件是由哪个包安装的 -qip 包全名:查询未安装软件包信息，必须在软件包目录进行查询。 -qR :查询软件包的依赖性。 -qRp :查询未安装软件包的依赖性必须在Packages目录查询。 -e 包名:卸载软件。rpm -qf `which 程序名` #返回软件包的全名 已安装的软件包rpm -qif `which 程序名` #返回软件包的有关信息rpm -qlf `which 程序名` #返回软件包的文件列表 RPM校验#rpm -V 已安装的包名选项：-V 校验指定RPM包中的文件。(verify) [root@Tiger ~]#rpm -V httpdS.5….T. c /etc/httpd/conf/httpd.conf验证内容中的8个信息的具体内容如下： S：文件大小是否改变； M：文件的类型或文件的权限(r w x)是否被改变； 5：文件MD5校验和是否改变(可以看成文件的内容是否改变)； D：设备的主，从设备号是否改变； L：文件路径是否改变； U：文件的属主(所有者)是否改变； G：文件的属组是否改变； T：文件的修改时间是否改变；文件类型： c :配置文件(config file) d :普通文档(documentation) g :”鬼”文件(ghost file),很少见，就是该文件不应该被这个RPM包包含 l :授权文件(license file) r :描述文件(read me) RPM包中文件提取#rpm2cpio 包全名 | \ cpio -idv .文件绝对路径 反斜杠：换行的作用。rpm2cpio:将rpm包转换为cpio格式的命令。cpio:是一个标准工具，他用于创建软件档案文件和从档案文件中提取文件。 #cpio 选项 &lt; [文件|设备]选项： -i:copy-in模式，还原 -d:还原时自动新建目录 -v：显示还原过程 rpm -qf /bin/ls 查询ls命令属于哪个软件包mv /bin/ls /tmp 造成ls命令误删除的假象rpm2cpio /mnt/Packages/coreutils-8.4-37.el6.x86_64.rpm | cpio -idv ./bin/ls提取RPM包中ls命令到当前目录的/bin/ls下 cp /root/bin/ls /bin 把ls命令复制到/bin目录，修复文件丢失。 源码包与RPM包的区别安装在指定位置当中，一般是/usr/local/软件名/。RPM包安装的服务可以使用系统服务管理命令(service)来管理，例如RPM包安装apache的启动方法是:/etc/rc.d/init.d/httpd start: 绝对路径启动服务。service httpd start源代码保存位置：/usr/local/src/软件安装位置：/usr/local/如何确定安装过程报错：安装过程停止；并出现error、warning或no的提示。源码包安装过程：下载源码包；解压缩下载的源码包；进入解压缩目录。 CRT中sftp里面要设置远程的路径和本地的路径:cd 1 进入远程连接到的Linux的1目录lcd \text 本地的c盘text目录get abc.c 从远程目录得到文件abc.c放入本地目录textput a11.txt 从Windows上将文件a11.txt传入linux 源码包配置./configure软件配置与检查 定义需要的功能选择。 检测系统环境是否符合安装需求。 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。./configure –prefix=/usr/local/apache2安装路径详情参考INSTALL 源码包的卸载：不需要卸载命令，直接删除安装目录即可，不会遗留任何垃圾文件。 脚本安装包：脚本安装包并不是独立的软件包类型，常见安装的是源码包。是人们把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。非常类似于Windows下软件的安装方式。 yum能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。remove :删除指定的rpm软件包； yum -y remove 软件包名yum update +包名 :升级。 禁用yum grouplist:列出所有可用的软件组列表；yum groupinstall 软件组名:安装指定的软件组，组名可以由goruplist查询出来；yum groupremove:卸载指定软件组； 配置yum仓库: [base] name=centos baseurl=file:///mnt/ enabled=1 gpgcheck=0 yum clean all 清除缓存，使最新的yum配置生效。yum list 列出所有可安装的软件包列表，包含已安装和未安装的 headhead 用来显示档案的开头至标准输出中,默认head命令打印其相应文件的开头10行 -n:显示文件的前n行 head -n 5 a.txt 显示文件的前5行 -c显示文件前n个字节 &gt;head -c 20 a.txt head -c -32 log2014.log文件的除了最后n个字节以外的内容head -n -6 log2014.log 输出文件除了最后n行的全部内容 . tail主要用来从指定点开始将文件写到标准输出。很多人喜欢使用tail -f 来监控日志文件。 -f该参数用于监视文件的增长 tail -f filename监视filename文件的尾部内容（默认10行，相当于增加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。 -n从指定行位置读取指定文件。 tail -n 20 filename 显示filename最后20行 -c显示文件最后n个字节 tail -c 20 a.txt chmod chmod命令用来变更文件或目录的权限，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件 -f :若该文件权限无法被更改也不要显示错误讯息 -R :对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)r=读取属性 值＝4 w=写入属性 值＝2 x=执行属性 值＝1 chown改变某个文件或目录的所有者和所属的组chown USER:GROUP 对象chown USER 对象 chown :group 对象 systemctlsystemctl命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起 chkconfig1.服务概述:在linux操作系统下，经常需要创建一些服务，这些服务被做成shell脚本，这些服务需要在系统启动的时候自动启动，关闭的时候自动关闭。将需要自动启动的脚本/etc/rc.d/init.d目录下，然后用命令chkconfig –add filename将自动注册开机启动和关机关闭。实质就是在rc0.d-rc6.d目录下生成一些文件连接，这些链接连接到/etc/rc.d /init.d目录下指定文件的shell脚本。 --list :列出所有系统服务 --add httpd:增加httpd服务。 --del httpd:删除httpd服务。 --list mysqld:列出mysqld服务设置情况 --level 35 mysqld on:设定mysqld在等级3和5为开机运行服务，–level 35表示操作只在等级3和5执行，on表示启动，off表示关闭。 chkconfig mysqld on:设定mysqld在各等级为on，“各等级”包括2、3、4、5等级。 chkconfig 设置是当前不生效，linux重启后才生效.service 设置是即时生效，linux关机重启后设置失效. mount查询与自动挂载(Auto Mount) mount [-l] 查询系统中已经挂载的设备，-l会显示卷标名称mount -a 依据配置文件/etc/fstab的内容，自动挂载 挂载命令格式 mount [-t 文件系统] [-L卷标名] [-o特殊选项] 设备文件名 挂载点-t 文件系统:加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统 -L 卷标名:挂载指定卷标的分区，而不是安装设备文件名挂载 -o 特殊选项:可以指定挂载的额外选项。 mount -o remount,noexec /home这里的/home是df可以查看到的分区重新挂载/home分区，并使用noexec权限 #cd /home #vi hello.sh#!/bin/bashecho “i love you”#chmod 755 #./hello.sh 会显示没有权限执行 #mount -o remount,exec /home 记得改回来，要不然会影响系统启动的。 挂载光盘mkdir /mnt/cdrom 建立挂载点mount -t iso9660 /dev/cdrom /mnt/cdrom 挂载光盘mount /dev/sr0 /mnt/cdrom 卸载光盘#umount设备文件名或挂载点umount /mnt/cdrom 挂载U盘fat32格式:fdisk -l 查看U盘设备文件名mount -t vfat /dev/sdb1 /mnt/usb/注意：fat16分区识别为fat,fat32分区识别为vft。linux默认是不支持NTFS文件系统的. NTFS u盘支持下载NTFS-3G插件https://www.tuxera.com/community/open-source-ntfs-3g/ 解压 tar -zxvf filename 安装 ./configure &amp;&amp; make &amp;&amp; make installfdisk -l查看linux的U盘分区：sdc1mount -t ntfs-3g /dev/sdc1 /mnt/usb/mkfs -t ext4 /dev/sdb1/ 格式化分区,扩展分区不可格式mkdir /disk1 建立挂载点mount /dev/sdb1 /disk1 挂载 swap新增swap空间:free查看swap大小新增一个分区，改分区号82，保存退出格式化：mkswap /dev/sdb6 加入swap分区：swapon /dev/sdb6取消swap分区：swapoff /dev/sdb6 但是每次开机都要手动挂载一遍，可以写入fatab开机自动挂载vi /etc/fstab/dev/sdb6 swap swap defaults 0 0 free显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。 -b ：以Byte为单位显示内存使用情况； -k ：以KB为单位显示内存使用情况； -m ：以MB为单位显示内存使用情况； total:去掉为硬件和操作系统保留的内存后剩余的内存总量。许多人奇怪自己的电脑安装了一共8G的内存，但是显示总共只有七点几G的，现在应该没什么疑惑了把，不管Linux还是Windows都会有部分内存是保留给硬件和操作系统的！ userd：当前已使用的内存总量。 free：空闲的或可以使用的内存总量 shared：共享内存大小，主要用于进程间通信 buff(buffers):缓冲，主要用于块设备数据缓冲(磁盘缓存大小)，例如记录文件系统的metadata（目录、权限等等信息）。是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减小了磁盘碎片和硬盘反复寻道，加速了数据的写入过程。 cache:缓存，主要用于文件内容缓冲,是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程。 available:可以使用的内存总量. Compression 压缩 commandgzipgzip filename压缩 *.gz :”后缀名”gzip -d filename.gz gunzip filename.gz 解压缩不解压查看：zcat filename.gz bz2bzip2 filename压缩 *.bzip2:”后缀名”bzip2 -k filename 保存源文件压缩bzip2 -d filename.bz2 bunzip2 filename.bz2解压缩不解压查看：bcat filename.bz2 xzxz filename压缩 .xz:”后缀名”xz -d filename.xz 解压缩unxz -k filename.xz 保存源文件解压 zipzip默认保存源文件，可以压缩目录解压：unzip FileName.zip压缩：zip FileName.zip DirName -r ：递归处理，将指定目录下的所有文件和子目录一并处理； tar-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的 tar cf file.tar files 将一个或多个文件、目录打包到tar包。tar rf file.tar file 将文件file添加到tar包中。tar uf file.tar file 将文件file更新tar包中相应的文件。tar tf file.tar 查看tar内容。tar xf file.tar 解压tar包。 -z:有gzip属性,即需要用 gzip 压缩 -j:有bz2属性,即需要用 bzip2 压缩 -v:显示处理过程 -C:指定解压输出目录 tar zxvf test.tar.gz -C test-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 -Z：有compress属性的 -O：将文件解开到标准输出 格式：tar Zcf file.tar.Z files 将一个或多个文件、目录压缩到file.tar.Z中。需要安装了ncompress软件包才行。解压.tar.Z文件。格式：tar Zxf file.tar.Z 归档并压缩：使用时间格式打包数据：tar zcf etc-$(date +%F).tar.gz /etc tar zcf etc-`date +%F`.tar.gz /etc *.tar.gz归档并调用gzip压缩 tar -zcf 新文件名.tar.gz /etc/passwd /var/log/messagages调用gzip解压缩并展开归档 tar -zxvf filename.tar.gz *.tar.bz2归档并调用bzip2压缩 tar -jcf 新文件名.tar.bz2 /etc/passwd /var/log/messages调用bzip解压缩并展开归档 tar -jxf filename.tar.bz2不解压缩查看：tar -tvf home_2018-10-14.tar.gz locate其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。 所以你要知道： locate的速度比find快，因为它并不是真的查找文件，而是查数据库locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护升级数据库命令：locate -- u CentOS系统找不到locate命令，原因是系统中没有安装 mlocate 这个包，然后更新数据库: updatedb -c :只显示找到条目的号码 -b :匹配唯一的路径名称的基本文件名 -r :基于基本正则表达式进行匹配操作 find实时查找工具，通过遍历指定起始路径下文件系统层级结构完成文件查找： 根据文件名查找： -name “pattern” -iname “pattern” 支持glob风格的通配符: \*,?,[],[^] i忽略大小写 -regex pattern :基于正则表达式查找文件，匹配整个路径而非其名； 根据文件从属关系查找：123456-user USERNAME:查找属主指定用户的所有文件； -goup GROUPNAME:查找属组指定组的所有文件； -uid UID:查找属主指定的UID的所有文件； -gid GID:查找属组指定的GID的所有文件； -nouser :查找没有属主的文件； -nogroup :查找没有属组的文件； 根据文件的类型查找：-type TYPE :按type查找f:普通文件 d:目录 l:符号链接文件 b:块设备文件 c:字符设备文件p:管道文件 s：套接字文件 【 ./可执行文件 】组合测试：12345与：-a,默认组合逻辑而且的意思; -o 是或者的意思； -not,!：非(相反)find ./ -size -1M -a -type f#寻找当前目录下文件大于1M的文件或者是目录。find ./ -size +1M -o -type d#寻找当前目录下文件小于1M并且文件类型是一般文件的文件。 !A -a !B =!(A -o B) !A -o !B =!(A -a B) 查找tmp目录下不包含“fstab”的字符文件 find /tmp -not -iname &quot;*fstab\*&quot; 根据文件的大小查找： -size [+|-]#UNIT 常用单位：K,M,G123size 10K filename,大小表示 (#-1,#] 9K&lt;filename&lt;10K; size -10K filename,大小表示[0-UNIT-1]; size +10K filename,大小表示(#,∞); 根据时间戳查找以“天”为单位： # [#,#-1]距现在为止过去几天前访问过文件。-#:(0,#) 几天内访问过文件。+#(oo, #-1] 几天前至-oo访问过的所有文件 -atime:显示的是文件中的数据最后被访问的时间，比如系统的进程直接使用或通过一些命令和脚本间接使用。 -mtime:显示的是文件内容被修改的最后时间，比如用vi编辑就会发生改变。 -ctime:显示的是文件的权限、拥有者、所属的组、链接数发生改变时的时间。当然当内容改变时也会随之改变。以“分钟”为单位: -amin -mmin -cmin 同上 根据权限来查找 -perm [/|-]mode find ./ -perm 644mode:精确权限匹配； /mode :任何一类用户(u,g,o)的权限中的任何一位(r,w,x)符合条件即满足 9位权限之间存在“或”关系； -mode :每一类用户(u,g,o)的权限中的每一位(r,w,x)同时符合条件即满足 9位权限之间存在”与”关系；440属于/666有读的权限 find./ -perm /666 符合这一查找 处理动作：-print:输出至标准输出:默认的动作;-ls:类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息-delete:删除找到的文件-fls:/PATH/TO/SOMEFILE:把查找到的所有文件的长格式信息保存至指定文件中；-ok COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认；-exec COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令； 查找/var目录下属主为root，且属组为mail的所有文件或目录；find /var -user root -a -group mail -ls 查找/usr目录下不属于root,bin或hadoop的所有文件或目录；用两种方法find /usr -not -user root -a -not -user bin -a -not -user hadoopfind /usr -not \( -user root -o -user bin -o -user hadoop \) -ls 查找/etc目录下最近一周内其内容修改过，且属主不是root也不是hadoop用户的文件或目录；find /etc -mtime -7 -a -not -user root -a -not -user hadoopfind /etc -mtime -7 -a -not \(-user root -o -user hadoop\) -ls 查找当前系统上没有属主或属组，且最近一周内曾今被访问过的文件或目录；find ./ -nouser -o -nogroup -ls 如果有文件属于可查找项，但是加ls选项最后会无法输出显示 加了-o（或条件）和ls后只会对后一半生效。 需要find ./ \( -nouser -o -nogroup\) -atime -7 -ls 查找/etc目录下大于1M且类型为普通文件的所有文件；find /etc -size +1M -lsfind /etc -size +1M -type f -exec ls -lh {} \; 查找/etc目录下所有用户都没有写权限的文件；find /etc -not -perm /222 -type f -ls 至少有一个用户 有 查找/etc目录至少有一类用户没有执行权限的文件；find /etc -not -perm -type f -111 查找/etc/init.d目录下，所有用户都有执行权限，且其他用户有写权限的所有文件；find /etc -perm -111 -a -perm -002 -lsfind /etc -perm -113 -ls -type f historyhistory [选项][历史命令保存文件]-c:清空历史命令 -w:把缓存中的历史命令写入历史命令保存文件 ~/.bash_history 历史命令默认保存1000条，可以在环境变量配置文件/etc/profile中修改历史命令的调用： 使用上、下箭头调用以前的历史命令 使用”!n”重复执行第n条历史命令 使用”!!”重复执行上一条命令 使用”!字符串”重复执行最后一条以该字符串开头的命令。 使用ctrl+r 搜索历史命令 alias命令别名#alias 别名=&#39;原命令&#39; alias:查询命令别名。 命令执行时顺序： 第一顺位执行时用绝对路径或相对路径执行的命令。 第二顺位执行别名。 第三顺位执行Bash的内部命令。 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。让别名永久生效：vim /root/.bashrc删除别名：unalias 别名. vim:.,$y复制当前行到末尾行:! 调用系统命令，可临时执行 使vim设置永久生效:vim /etc/vimrc 把设置写到这个文件的最后，对所有账户生效set nu 显示行号 set nonu 取消行号set ic 不区分大小写 set noic 取消不区分大小写set ts=4 设置tab键长度set sw=4 设置自动缩进的tab键长度 vim /root/.vimrc 也可以把设置写到此文件，只对root生效 vim字符替换:%s/this/that 每一行的第一个this被替换成that:%s/this/that/g 将文本中所有的this替换成that %从每一行的开头到结尾 s表示替换:1,5 s/old/new/g #替换第一行到第5行中所有匹配的内容. 字符操作u撤销上一步i当前插入，I行首插入。a当前字符插入(光标后一位插入)，A行尾插入。o表示：本行回车到下一行插入，O上一行插入。x删除光标所在字符，X向前删除一个字符。dd删除光标所在的行，dG删除光标所在开始行到文件尾的所有字符。J合并两行。行操作：home 键或^键行首，$或end行尾dd删除一行Ndd(删除本行与下一行)。yy复制一行，Nyy复制n行，p将复制行粘贴，p向光标下一行粘。(N表示数字) 词操作:dw删除一个词，y+$复制至行尾。y+^复制至行首。yw复制一个词。:.,$y 复制当前行到末尾 v模式:编程的时候需要进行多行注释： （删除是要将光标移到这个词的行首，如果光标不在行首则删除光标之后的字母。）块操作：D或d+$删除至行尾 d+^删除至行首1、注释：ctrl+v进入列编辑模式2、向下或向上移动光标 （ctrl L 向下全部选中）3、把需要注释的行开头的开头标记起来4、然后按大写的I5、再插入注释符，比如“#”6、再按Esc，就会全部注释了删除多行注释：按ctrl+v进入列编辑模式;向下或向上移动光标；选中注释部 分然后按d,就会删除注释符号。 vim编辑器： :wq 可以保存外 :w +路径+文件名直接保存在某个位置和重命名:w 路径/文件名ZZ 保存退出 :x 保存退出 :!命令:!ifconfigvi的行定位功能:ctrl+f 向前卷动一个屏幕ctrl+b 向后卷动一个屏幕G 到文件最后一行行首:$ 到文件最后一行行尾mG 到指定行，m为目标行数 或者mggset nu 显示行号/内容 查找指定内容n 查找下一个N 回到前一个？ 寻找上一个 /^字符串 查找以字符串开始的行/字符串$ 查找以字符串结尾的行/a.b 查找字符串a任意字符b vim替换r 替换当前光标字符:r 文件名 在光标当前位置载入另一个文件. useradduseradd命令用来建立用户帐号和创建用户的起始目录，使用权限是终极用户. -u :uid指定用户ID -d:指定用户登入时的启始目录。 -g:指定用户所属的群组 -G:指定用户所属的附加群组。tom 用户的登陆 shell 为非交互式 shell useradd –s /sbin/nologin tom -e :指定账号的有效期限，缺省表示永久有效 useradd user1——创建用户user1;useradd –e 12/30/2009 user2——创建user2,指定有效期2009-12-30到期 -c:用户说明，手工指定用户的说明，添加说明有Spacebar时要加“ “。 用户默认值文件：/etc/defalut/useradd1.GROUP=100 :用户默认组ID (公有模式)2.HOME=/home :用户家目录3.INACTIVE=-1 :密码过期宽限天数(shadow文件7字段)4.EXPIRE=no value :密码失效时间(8字段)5.SHELL=/bin/bash :默认的shell6.SKEL=/etc/skel :模板目录7.CREATE_MAIL_SPOOL=yes :是否建立邮箱 /etc/login.defsPASS_MAX_DAYS 999 :密码有效期(5字段)PASS_MIN_DAYS 0 :密码修改间隔(4字段)PASS_MIN_LEN 5 :密码最小5位(PAM)PASS_WARN_AGE 7 :密码到期警告(6)UID_MIN 500 :最小和最大UID范围GID_MIX 60000ENCRYPT_METHOD SHA512 :加密模式. userdel删除用户userdel [-r] 用户名 -r:删除用户的同时删除用户家目录 id查看用户id：#id 用户名查询用户的UID,初始组ID,附加群组ID usermodusermod命令用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user id，必须确认这名user没在电脑上执行任何程序. -g &lt;群组&gt; 修改用户所属的原始群组。usermod -g root username -G &lt;群组&gt; 修改户所属的附加群组 -a -G 无限增加到附加组，可拥有多个附加组.将a1添加附加组user3 usermod -a -G user3 a1-c:修改用户的说明usermod -c &quot;test user&quot; username 当某一用户拥有多个附加组之后，使用usemod -G会修改附加组，则多个组消失掉变成唯一当前修改的附加组1.将 newuser2 添加到附加组 staff usermod -G staff newuser2 -l &lt;帐号名称&gt; 修改用户帐号名称。2.修改 newuser 的用户名为 newuser1 usermod -l newuser1 newuser-L 锁定用户密码，使密码无效。 -U 解除密码锁定。3.锁定账号 newuser1 usermod -L newuser14.解除对 newuser1 的锁定 usermod -U newuser1 -d 改变用户家目录,常与-m结合使用 -m 将主目录的内容移动到新目录usermod -m -d /home/user2 -uid username若使用报错使用以下命令：cat /dev/null &gt; /var/run/utmp 清空此文件。utmp是一个文件，除了utmp程序你不能编辑这个文件，删掉他的话，当前登陆信息都会丢失。它就好比系统开启后它会把系统成员的信息迅速的记录下来，过一段时间它就不再记录，确认系统的用户配置就是这样了，这个文件在每次机器reboot起来后都会重新创建。. groupadd-g GID: 修改组ID -n 新组名: 修改组名 susu: [选项] 用户名 -:选项只使用”-“代表连带用户的环境变量一起切换。可使用env命令查看-c:仅执行一次命令，而不切换用户身份su - root -c &quot;useradd user3&quot;不切换成root,但是执行useradd命令添加user1用户。 chage修改用户密码状态chagechage [选项] 用户名 -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期(shadow3字段) -m 天数:两次密码修改间隔(4字段) -M 天数:密码有效期(5字段) -W 天数:密码过期前警告天数(7字段) -I 天数:密码过后宽限天数(7字段) -E 日期:账号失效时间(8字段)chage -d 0 username这个命令其实是把密码修改日期归0了(shadow第3字段)，这样用户只要一登录就要修改密码。第三字段是指密码最后一次修改时间的日期。1970年1月1号到现在修改密码的时间戳。如果第3字段改为0，系统会认为用户没有修改过操作密码，那么当此用户一旦登录系统就会提示要修改密码，才可正常使用。. passwd-S:查询用户密码的密码状态，仅root用户可用。 -l:暂时锁定用户。仅root用户可用。 -u:解锁用户。仅root用户可用。 –stdin:可以通过管道符输出的数据作为用户的密码。echo &quot;123&quot; | passwd --stdin user gpasswd -d :从组删除用户 gpasswd -d username groupadd -a :添加用户到组(附加组),同时保留以前的组 添加用户到某一个组可以使用 usermod -G groupB userA 这个命令可以添加一个用户到指定的组，但是以前添加的组就会清空掉.所以想要添加一个用户到一个组，同时保留以前添加的组时，请使用gpasswd这个命令来添加操作用户 -A :指定组内管理员 gpasswd -A username groupname groups groups username 显示linux用户所属的组 datedate 根据给定格式显示日期或设置系统日期时间。print or set the system date and time 指令所在路径：/bin/date date &quot;+%Y-%m-%d %H:%M:%S&quot; -d:显示字符串所指的日期与时间。字符串前后必须加上双引号123date -d now date -d &apos;next monday&apos; date -d yesterday +%Y-%m-%d -r:显示文件最后修改时间 -s:设置系统时间 date -s &quot;2018-11-11 00 00 00&quot; 在使用date -s这个命令修改时间后，系统重启后就失效了，因此为了将这个时间永久生效，需要将修改的时间写入CMOS，查看CMOS的时间:clock –r将当前系统时间写入CMOS中去clock –w 在生产环境中常使用时间格式打包数据：tar zcvf etc-$(date +%F).tar.gz /etctar zcvf etc-`date +%F`.tar.gz /etc date:2018/9/23 hwclock查看硬件时间设置硬件时间hwclock --set --date=&quot;07/07/06 10:19&quot; （月/日/年 时:分:秒）硬件时间和系统时间的同步：重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需要用hwclock命令实现同步。硬件时钟与系统时钟同步：hwclock --hctosys（hc代表硬件时间，sys代表系统时间）系统时钟和硬件时钟同步:（让系统的时间同步到硬件时钟)hwclock –-systohc. lnln：链接命令硬链接：复制并同步 ln /etc/passwd /tmp/password 软链接：类似windows下的快捷方式 ln -s /etc/passwd /tmp password软链接和硬链接的区别:1.创建命令不同:ln -s /root/ruan.txt /root/桌面/ ln /root/ying.txt /root/桌面/2.软链接创建时必须使用绝对路径(链接和源文件在同一目录下,可以相对路径)硬链接创建时可以绝对路径也可相对路径3.软链接的源文件不可以剪切,重命名,删除 硬链接的源文件可以剪切,重命名,删除4.软链接的链接文件权限永远是777，即使将链接文件的权限进行了修改，也不会发生变化，变得是源文件的权限 硬链接的链接文件权限永远和源文件相同5.软链接的链接文件的inode号和源文件不同硬链接的链接文件的inode号和源文件相同6.软链接可以对目录操作硬链接不支持对目录操作，是针对于上层来说，底层是可以针对于目录做硬链接的，通过代码就可以实现7.软链接可以跨文件系统硬链接不可以跨文件系统，因为硬链接是存放在源文件的同一个block上面的 SElinux安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则） DAChttp://blog.51cto.com/zhaotianyu/1795178：在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：某个资源是否拥有对应用户的权限（读、写、执行）。只要访问这个资源的进程符合以上的条件就可以被访问。而最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问。这种权限管理机制的主体是用户，也称为自主访问控制（DAC）。 MAChttp://baijiahao.baidu.com/s?id=1590170088632157084&amp;wfr=spider&amp;for=pc：在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限。这样一来，即使进程是以 root 身份运行的，也需要判断这个进程的类型以及允许访问的资源类型才能决定是否允许访问某个资源。进程的活动空间也可以被压缩到最小。即使是以 root 身份运行的服务进程，一般也只能访问到它所需要的资源。即使程序出了漏洞，影响范围也只有在其允许访问的资源范围内。安全性大大增加。这种权限管理机制的主体是进程，也称为强制访问控制（MAC）。getenforce命令是单词get（获取）和enforce(执行)连写，可查看selinux状态setenforce 命令则是单词set（设置）和enforce(执行)连写，用于设置selinux防火墙状态，如： setenforce 0用于关闭selinux防火墙，但重启后失效。 SELinux status：selinux防火墙的状态，enabled表示启用selinux防火墙关闭SElinux:临时关闭 :setenforce 0用于关闭selinux防火墙，但重启后失效永久关闭：修改selinux的配置文件：vim /etc/selinux/config将SELINUX=enforcing改为SELINUX=disabled，保存后退出，此时获取当前selinux防火墙的安全策略仍为Enforcing，配置文件并未生效。重启后验证。SELinux 有三种工作模式，分别是：1.enforcing：强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中。2.permissive：宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用。3.disabled：关闭 SELinux crontab1.Crontab是一个用于设置周期性执行任务的工具；2.周期性执行的任务我们称为Cron Job；3.周期性执行的任务列表我们称为Cron Tablecrontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下: * * * * * command minute hour day month week command 顺序:分 时 日 月 周 minute： 表示分钟，可以是从0到59之间的任何整数。hour：表示小时，可以是从0到23之间的任何整数。day：表示日期，可以是从1到31之间的任何整数。month：表示月份，可以是从1到12之间的任何整数。week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件 -u:编辑某个用户的cron，只用root可以使用此参数为别的用户设置cron服务。也可用于给用户指定crontab文件。 -l: 列出当前用户的crontab。 -r: 删除当前用户的crontab。 -e: 编辑当前用户的crontab，默认使用vi，或者是由 VISUAL或EDITOR环境变量指定的编辑器。 -i与-r 一起使用，用来询问用户是否直接删除crontab安装cronyum install vixie-cronyum install crontabs检查crontab工具是否安装：crontab -l检查crond服务是否启动：service crond status检查crontab服务状态：service crond status 每晚的21:30重启apache30 21 * * * service httpd restart 每月1,10,22日的4:45重启apache45 4 1,10,22 * * service httpd restart 每月1-10日的4:45重启apache45 4 1-10 * * service httpd restart 每天18:00-23:00之间每隔30分钟重启apache0,30 18-23 * * * service httpd restart0-59/30 18-23 * * * service httpd restart 每晚11-早上7点之间，每隔一个小时重启apache* 23-7/1 * * * service httpd restart 每隔两分钟重启apache 123*/2 * * * * service httpd restart 1-59/2 * * * * service httpd restart(奇数分钟重启) 0-58/2 * * * * service httpd restart(偶数分钟重启) 小结：*表示任何时候都匹配；可以用”A,B,C”表示A或者B或者C时执行命令可以用”A-B”表示A到B之间时执行命令可以用”*/A”表示每A分钟(小时等)执行一次命令 */1 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP时间同步: fdiskfdisk命令操作磁盘详解–添加、删除、转换分区等主分区和扩展分区(扩展分区不能直接使用)(1-4),扩展分区下面再分逻辑分区(5开始)。 fdisk /dev/sda 分区保存报错需要重启时，强制读取分区表信息#partprobeyum install -y parted grepgrep [选项] “搜索内容” 文件名 -i 忽略大小写 -n 输出行号 -v 反向查找 --color=auto把搜索出的关键字用颜色显示]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[document]]></title>
    <url>%2F2018%2F08%2F28%2Fdocument%2F</url>
    <content type="text"><![CDATA[Linux 文档 用户和用户组管理/etc/passwd:用户信息文件user1:x:500:500::/home/user1:/bin/bash第一字段:用户名称；第二字段:密码标志；第三字段:UID(用户ID)； 0：超级用户； 1-499：系统用户(伪用户)； 500-65535:普通用户；第4字段：GID(用户初始组ID)第5字段：用户说明第6字段：家目录 普通用户：/home/用户名/ 超级用户：/root/第7字段：登录之后的Shell 影子文件:/etc/shadow第1字段：用户名第2字符：加密密码 加密算法升级为SHA512散列加密算法 如果密码位是“ ！”或“ * ”代表没有密码，不能登录。第3字段：密码最后一次修改日期：使用1970年1月1号作为标准时间，每过一天时间戳加1。第4字段：两次密码的修改间隔时间(和第3字段相比)间隔多少时间后才可以修改密码。第5字段：密码有效期(和第3字段相比)第6字段：密码修改到期前的警告天数(和第5字段相比)第7字段：密码过期后的宽限天数(和第5字段相比) 0：代表密码过期后立即失效。 -1：则代表密码永远不会失效。第8字段：账号失效时间，要用时间戳表示第9字段：保留把时间戳换算为日期：date -d &quot;1970-01-01 17740 days&quot;把日期换算为时间戳：echo $(($(date --date=&quot;2018/07/28&quot; +%s)/86400+1)) 组信息文件/etc/group第一字段：组名第二字段：组密码标志第三字段：GID第四字段：组中附加用户 组密码文件/etc/gshadow第一字段：组名第二字段：组密码第三字段：组管理员用户名第四字段：组中附加用户 用户的家目录 普通用户：/home/用户名/,所有者和所属者都是此用户，权限是700 超级用户：/root/,所有者和所属者都是root用户，权限是550。 用户的邮箱：/var/spool/mail/用户名/ 用户模板目录：/etc/skel:创建用户时，用户的家目录会自动创建一些隐藏文件，这些文件是从/etc/skel/ 过去的。想要每个新添加用户时家目录自动出现共享文件可在此目录添加。 linux的特殊权限特殊权限： SUID,SGID,STICKY 1.进程以某用户的身份运行；进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作；2.权限匹配模型：(1)判断进程的属主，是否为被访问的文件属 主 ；如果是，则应用属主的权限；否则进入第2步；(2)判断进程的属主，是否属于被访问的文件属 组 ；如果是，则应用属组的权限；否则进入第3步;(3)应用other的权限； SUIDSetUID的功能:1、只有可以执行的二进制程序才能设定SUID权限。2、命令执行者要对该程序拥有X(执行)权限3、命令执行者在执行该程序时获得该程序文件属主的身份4、SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效。 SUID :默认情况下:用户发起的进程，进程的属主是其发起者；因此，其以发起者的身份运行； SUID 的功用：用户运行某程序时，如果此程序拥有SUID的权限，那么程序运行为进程时，进程的属主不是发起者，而程序文件自己的属主;管理文件的SUID权限： chmod u+|-s FILe 展示位置：属主的执行权限位。 #chomod 4644 filename取消suid权限：#chmod 644 filename 大写S为报错,检查是否有x权限. SGID用户在执行程序时候，组身份变为该程序文件的属组与SUID类似。 管理文件的 SGID 的权限： chmod g+|-s FILE SGID : 功用：当目录属组有写的权限，且SGID权限时，当你给一个目录添加了sgid之后，后面不管谁来这个目录下创建文件，文件的所属组都会继承目录的所属组展示位置：属组的执行权限位如果属组原本有执行权限，则显示为小写s;否则，显示为大写S; #ll /usr/bin/locate #ll /var/lib/mlocate/mlocate.db STICKY sticky :t权限只能给目录添加，当你给一个目录添加了t权限之后，后面所有人在这个目录下不能删除其他人的文件,只能删除自己的文件； 管理文件的Sticky权限： chmod o+|-t FILE 展示位置：其他用户的执行权限位 如果其他用户原本有执行权限，显示为小写t;否则为大写T。 系统上的/tmp和/var/tmp目录下默认均有Sticky权限 基于八进制方式赋权时，可于默认的三位八进制数字左侧再加一位八进制数字； chmod 1777 中的 1 表示特殊权限 . faclfacl:file access control lists 文件访问控制列表文件的额外赋权机制：在原有的u,g,o之外，另一层让普通用户控制赋权给另外的用户或组的赋权机制；查看分区ACL权限是否开启dumpe2fs -h /dev/sda3dumpe2fs命令是查询指定分区详细文件系统信息的命令.选项： -h 仅显示超级块中的信息，而不显示磁盘块组的详细信息 临时开启分区ACL权限： mount -o remount,acl / 重新挂载根分区，并挂载加入acl权限。 永久开启分区ACL权限#vi /etc/fstab UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 dufaults,acl 1 1 加入ACLmount -o remount /:重新挂载文件系统或重启动系统，使修改生效。getfacl filename:查看文件额外的权限setfacl命令： setfacl -m u:username:rw filename 赋权给用户： setfacl -m u:USERNAME:MODE file 赋权给组： serfacl -m g:GROUPNAME:MODE file 撤销赋权:serfacl -x u:USERNAME file serfacl -x g:USERNAME file 递归ACL权限：#setfacl -m u:用户名:权限 -R 目录名 默认ACL权限:默认acl权限的作用是如果给父目录设定了默认的ACL权限，那么父目录中所有新建的子文件都会继承父目录ACL的权限。#setfacl -m d:u:用户名:权限 文件名 setfacl 选项 文件名选项： -m :设定ACL权限 -x :删除指定的ACL权限 -b :删除文件所有的ACL权限 -d :设定默认ACL权限 -k :删除默认ACL权限 -R :递归设定ACL权限 最大有效权限maskmask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限”相与”才能得到用户的真正权限。 A B and r r r r - - - r - - - - 修改最大有效权限：#setfacl -m m:rx filename 设定mask权限为r-x。使用“m:权限”格式。 mask值只能添加ACL权限之后后期更改，当更改mask值以后再添加ACL权限，mask值就会变为777. 文件系统属性chattr权限#chattr [+-=] [选项] 文件或目录名+：增加权限-：删除权限=：等于权限 选项：-i:如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据还可以cp，但不允许建立和删除文件 -a:如果对文件设置a属性，那么只能在文件中增加数据(只能用echo增加数据，不能用vim)，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。chattr +i a.txtlsattr -a a.txt----i--------e- a.txt e:代表此文件在ext4文件系统下建立的。查看文件系统属性：lsattr 选项 文件名 -a显示所有文件和目录 -d若目标是目录，仅列出目录本身的属性，而不是子文件。 sudo权限root把本来只能超级用户执行的命令赋予普通用户执行。sudo的操作对象是系统命令 whereis 命令 查看命令的绝对路径visudo 实际修改的是/etc/sudoers文件root ALL=(ALL) ALL用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径) 被管理的主机地址可写成主机ip和ALL%wheel ALL=(ALL) ALL组名 被管理的主机地址=(可使用的身份) 授权命令(绝对路径) root ALL=(ALL) ALLst 192.168.81.137=/sbin/shutdown -r now 添加内容 st ALL=/usr/bin/vim 危险操作su - st:切换用户sudo -l:查看可用的sudo命令sudo /sbin/shutdown -r now 普通用户执行sudo赋予的命令 linux下查看帮助命令 whatis :用于查询一个命令执行什么功能，并将查询结果打印到终端上whatis ls man :Linux提供了丰富的帮助手册，当你需要查看某个命令的参数时不必到处上网查找，只要man一下即可 man command linux根目录结构和文件系统进程的类型： 终端:硬件设备，关联一个用户接口。 与终端相关:通过终端启动。 与终端无关:操作引导启动过程中自动启动操作系统的组成: 静态:kernel,application 文件系统:层级结构FHS: Filesystem Hierarchy Standard /bin:所有用户可用的基本命令程序文件； /sbin:供系统管理使用的工具程序； /boot:引导加载器必须用到的各种静态文件：Kernel,initramfs(initrd),grub等； /dev:存储特殊文件或设备文件； 设备有两种类型：字符设备(线性设备)、块设备(随机设备)； /etc:系统程序的配置文件，只能为静态： /home：普通的家目录的集中位置：一般每个普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME； /lib:为系统启动或根文件系统上的应用程序（/bin,/sbin）等提供共享库，以及为内核提供内核模块 libc.so.*:动态链接的C库； ld*:运行时链接器/加载器； modules:用于存储内核模块的目录； /lib64:64位系统特有的存放64位共享的路径； /media:便携式设备挂载点，cdrom,floppy等； /mnt:其他文件系统的临时挂载点； /opt：附加应用程序的安装位置：可选路径； /srv:当前主机为服务提供的数据； /tmp:为那些会产生临时文件的程序提供的用于临时文件的目录：可供所用户执行写入操作：有特殊权限； /usr:usr Hierarchy,全局共享的只读数据路径： bin,lib64 include:C程序头文件； share:命令手册页和自带文档等架构特有的文件的存储位置 local:另一个层级目录； X11R6:X-widow程序的安装位置 src:程序源代码文件的存储位置 多命令顺序执行多命令执行符格式作用&amp;&amp;命令1 &amp;&amp; 命令2逻辑与,当命令1正确执行,则命令2才会执行。当命令1执行不正确,则命令2不会执行||命令1 || 命令2逻辑或,当命令1执行不正确,则命令才会执行。当命令1正确执行,则命令2不会执行 通配符通配符作用?匹配一个任意字符*匹配0个或任意多个字符，也就是可以匹配任何内容[]匹配括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者a,或者b,或者c。[^]逻辑非，表示不匹配中括号内的任意一个字符。例如:[^0-9]代表匹配一个不是数字的字符。 Bash中其他特殊符号 符号作用&#39;&#39;单引号。在单引号中所有的特殊符号，如$,`(反引号)都没有特殊含义。&quot;&quot;双引号。在双引号中特殊符号都没有特殊含义，但是$,和\是例外,拥有&quot;调用变量的值&quot; `反引号引用命令,和&quot;转义符&quot;的特殊含义&quot;``反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。$()和反引号作用一样，用来引用系统命令。#在shell脚本中，#开头的行代表注释。$用于调用变量的值,如需要调用变量name的值时，需要用$name的方式得到变量的值时，需要用$name的方式得到变量的值。\转义符,跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出$符号，而不当做是变量引用。. 12345[root@Tiger ~]# name=test [root@Tiger ~]# echo &apos;$name&apos; $name [root@Tiger ~]# echo &quot;$name&quot; test 12345[root@Tiger ~]# abc=`date` [root@Tiger ~]# echo `date` 2018年 09月 09日 星期日 13:10:57 CST [root@Tiger ~]# echo $abc 2018年 09月 09日 星期日 13:10:49 CST 12345[root@Tiger ~]# abc=$(date) [root@Tiger ~]# echo $abc 2018年 09月 09日 星期日 13:12:44 CST [root@Tiger ~]# echo &quot;abc&quot; abc 1234[root@Tiger ~]# echo &quot;$abc&quot; 2018年 09月 09日 星期日 13:12:44 CST 反引号和$ #echo `ls` #echo $(date) Bash 变量什么是变量：变量是计算机内存单元，其中存放的值可以改变。当Shell脚本需要保存一些信息时，如一个文件名或一个数字,就把它存放在一个变量中，每个变量有一个名字，所以很容易引用它，使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。变量设置规则：explanation 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是”2name”则是错误的。 在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。 变量用等号连接值，等号左右两侧不能有空格。 变量的值如果有空格，需要使用单引号或双引号包括。 在变量的值中，可以使用”\”转义符。 如果需要增加变量的值，那么可以进行变量值的叠加，不过变量需要用双引号包含”$变量名”或用${变量名}包含。 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。 环境变量名建议大写，便于区分。变量的分类 用户自定义变量 环境变量:这种变量中主要保存的是和系统操作环境相关的数据。 位置参数变量:这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。 预定义变量:是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定好的。 本地变量变量定义：#name=&quot;bianliang&quot;变量叠加： #aa=123 #aa=$aa456 #aa=${aa}789变量调用：echo $name变量查看：set变量删除：&gt;unset name 环境变量环境变量是什么:用户自定义变量只在当前的Shell中生效，而环境变量会在当前Shell和这个Shell的所有子Shell当中生效。如果把环境变量写入相应的配置文件,那么这个环境变量就会在所有Shell中生效。 pstree:查看进程数,查看当前shell设置环境变量：export 变量名=变量值申明变量:env :查询变量,专门查看环境变量。set:查看所有变量unset 变量名 #删除变量 name=sc 本地变量export age=18 环境变量sex=man 本地变量。把已经定义好的本地变量变成环境变量，只需要：export sex 系统常见环境变量PATH:系统查找命令的路径 #echo $PATH/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/binPATH变量叠加：PATH=&quot;$PATH&quot;:/root/sh(脚本保存目录) ps1:定义系统提示符的变量：\d:显示日期，格式为”星期 月 日”\h:显示简写主机名。如默认主机名”localhost”\t:显示24小时制时间，格式为”HH:MM:SS”\T:显示12小时制时间，格式为”HH:MM:SS”\A:显示12小时制时间，格式为”HH:MM”\u:显示当前用户名\w:显示当前所在目录的完整名称\W:显示当前所在目录的最后一个目录#:执行的第几个命令\$:提示符。如果为root用户会显示提示符为”#”,如果普通用户会显示提示符为”$”。\@:时间 上下午 echo $PS1 :查看提示符[root@Tiger ~]# PS1=&#39;[\u@\t \w]\$ &#39;这里的空格生成以后,提示符后会有一个SPACE的距离。[root@16:10:52 ~]#cd /usr/local/src/[root@16:11:08 /usr/local/src]# #PS1=&#39;[\u@\@]\$&#39;[root@04:13 下午]#PS1=&#39;[\u@\@ \h]\$&#39;[root@04:17 下午 Tiger]#PS1=&#39;[\u \@@]\$&#39;[root 04:18 下午@]#^ 位置参数变量位置参数变量作用$nn为数字,$0代表命令本身,$1-$9代表第一到第九个参数,十以上的参数需要用大括号包含,如${10}$这个变量代表命令行中所有的参数,$把所有的参数看成一个整体$@这个变量也代表命令行中所有的参数,不过$@把每个参数区别对待$#这个变量代表命令行中所有参数的个数位置参数变量的名称和作用是固定的，他是为了接受用户向程序传入不同的值。 123456789101112131415vim ceshi.sh #!/bin/bash echo $0echo $1echo $2echo $3 :wqchmod 755 ceshi.sh./ceshi.sh./ceshi.sh 输出结果是本身./ceshi.sh 11 22 33./ceshi.sh 输11 出22 接33 果 1234567#!/bin/bashnum1=$1num2=$2sum=$(($num1 + $num2)) //变量sum的和是num1加num2echo $sum //打印sum的值chmod 755 ceshi.sh./ceshi.sh 11 22 123456789#!/bin/bashecho $#echo $*echo $@chmod 755 ceshi.sh./ceshi.sh 11 22 33 44 55 66 6 11 22 33 44 55 6611 22 33 44 55 66 预定义变量预定义变量作用$?最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行;如果这个变量的值非0(具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确了。$$当前进程的进程号(PID)$!后台运行的最后一个进程的进程号(PID)/td&gt;在Linux里面输入一条命令正确执行以后，输入echo $? ，默认输出 0当输出一条错误的命令以后，会系统报错，输入echo $? ，默认输出 127 123456789#!/bin/bashecho &quot;$$&quot;find /root -name hello.sh $ // $符号的作用是把程序放在后台echo &quot;$!&quot;chmod 755 ceshi.sh./ceshi.sh2788827888 接受键盘输入read [选项][变量名] -p&quot;提示信息&quot;:在等待read输入时,输出提示信息 -t 秒数:read命令会一直等待用户输入，使用此选项可以指定等待时间。 -n 字符数:read命令只接受指定的字符数，就会执行 -s:隐藏输入的数据，适用于机密信息输入。 数值运算与运算符declare声明变量类型declare [+/-][选项] 变量名 -:给变量设定类型属性 +取消变量的类型属性 -i:将变量声明为整数型(integer) -x:将变量声明为环境变量 -p:显示指定变量的被声明的类型数值运算方法1: [root@Tiger data]#aa=11 [root@Tiger data]#bb=22给变量aa和bb赋值 [root@Tiger data]#declare -i cc=$aa+$bb方法2:expr或let数值运算工具 [root@Tiger data]#aa=11[root@Tiger data]#bb=22给变量aa和变量bb赋值 [root@Tiger data]#dd=$(expr $aa + $bb)$dd的值是aa和bb的和,注意”+”号左右两侧必须有空格方法3:$((运算式))或$[运算式] aa=11bb=22gg=$(($aa+$bb))ff=$[$aa+$bb] 运算优先级 优先级从上到下优先级运算符说明13-，+单目负,单目正12!，~逻辑非，按位取反或补码11*，/，%乘、除、取余10+，-加、减9&lt;&lt;，&gt;&gt;按位左移、按位右移8&lt;=，&gt;=，&lt;，&gt;小于或等于、大于或等于、小于、大于7==，!==等于、不等于6&amp;按位与5^按位异或4|按位或3&amp;&amp;逻辑与2||逻辑或1=，+=，-=， ，*=，/=，%=，&amp;=，^=，|=，&lt;&lt;=，&gt;&gt;=赋值、运算且赋值. 变量测试与内容替换 123456789101112131415[root@Tiger ~]# unset y[root@Tiger ~]# x=$&#123;y-new&#125;[root@Tiger ~]# echo $y[root@Tiger ~]# echo $xnew[root@Tiger ~]# y=&quot;&quot;[root@Tiger ~]# x=$&#123;y-new&#125;[root@Tiger ~]# echo $x[root@Tiger ~]# y=old[root@Tiger ~]# x=$&#123;y-new&#125;[root@Tiger ~]# echo $xold[root@Tiger ~]# 环境变量配置文件1source 配置文件 或 调用文件的命令1. 配置文件 环境变量配置文件简介：环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如PATH,HISTSIZE,PS1,HOSTNAME等默认环境变量。环境变量配置文件:①/etc/profile②/etc/profile.d/*.sh *是通配符，代表这个目录下所有以.sh结尾的文件。③~/.bash_profile④~/.bashrc⑤/etc/bashrc其中3个在/etc/下面的变量配置文件是对所有登录Linux用户生效。另外两个是用户家目录下的隐藏文件只对当前用户生效。 其他的配置文件和登录信息 注销时生效的环境变量配置文件：~/.bash_logout :这个文件默认是空的，如果想要每次登录比如清空历史命令或者把自己的环境变量清空等，写入后，注销时他会自动执行 ~/bash_history :保存的历史命令，但是有一些他还保存在内存当中，除非是手工写入history -w或者注销登录才会把内存中的命令转移到这个文件中去。 Shell登录信息 本地终端欢迎信息:/etc/issue只对本地登录有显示效果 转义符作用\d显示当前系统日期\s显示操作系统名称\l显示登录的终端号,这个比较常用\m显示硬件体系结构,如i386、i686等\n显示主机名\o显示域名\r显示内核版本\t显示当前系统时间\u显示当前登录用户的序列号 远程终端欢迎信息: /etc/issue.net (上图的转义符本文件不能使用,只能使用纯文本信息)转义符在/etc/issue.net文件中不能使用是否显示此欢迎信息,由ssh的配置文件 /etc/ssh/sshd_config决定，加入&quot;Banner /etc/issue.net&quot;行才能显示(记得重启SSH服务) 登录后显示 欢迎信息: /etc/motd 不管是本地登录,还是远程登录,都可以显示此欢迎信息.直接写入此文件即可 正则表达式与通配符正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配。grep、awk、sed等命令可以支持正则表达式。 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配。 元字符 作用*前一个字符匹配0次或任意多次.匹配除了换行字符外任意一个字符^匹配行首。例如：^hello 会匹配以hello开头的行。$匹配行尾。例如：hello$ 会匹配以hello结尾的行[]匹配中括号中指定的任意一个字符，只匹配一个字符。例如：[aeiou]匹配任意一个元音字母，[0-9]匹配任意一位数字，[a-z][0-9]匹配小写字母和一位数字构成的两位字符[^]匹配除中括号的字符以外的任意一个字符。例如：[^0-9]匹配任意一位非数字字符，[^a-z]表示任意一位非小写字母。\转义符。用于取消将特殊符号的含义取消。\{n\}表示其前面的字符恰好出现n次。例如：[0-9]\{4\}匹配4为数字，[1][3-8][0-9]\{9\}匹配手机号码\{n,\}表示其前面的字符出现不小于n次。例如：[0-9]\{2,\}表示两位及以上的数字\{n,m\}表示其前面的字符至少出现n次，最多出现m次。例如：[a-z]\{6,8\}匹配6到8位的小写字母 *前一个字符匹配0次，或任意多次grep &quot;a*&quot; ceshi.txt 匹配所有内容，包括空白行grep &quot;aa*&quot; ceshi.txt 匹配至少包含有一个a的行grep &quot;aaa*&quot; ceshi.txt 匹配最少包含两个连续a的字符串grep &quot;aaaaa&quot; a.txt 则会匹配最少包含四个连续的a的字符串. 匹配除了换行符外任意一个字符grep &quot;s..d&quot; a.txt s..d会匹配s和d这两个字符之间一定有两个字符的单词grep &quot;s.*d&quot; a.txt 匹配在s和d字母之间有任意字符grep &quot;.*&quot; a.txt 匹配所有内容^ 匹配行首，$匹配行尾grep &quot;^M&quot; a.txt 匹配以大写M开头的行grep &quot;n$&quot; a.txt 匹配以小写n结尾的行grep -n &quot;^$&quot; a.txt 会匹配空白行,-n 显示行号[] 匹配中括号中指定的任意一个字符，只匹配一个字符grep &quot;s[ao]id&quot; a.txt 匹配s和i字母中，要么是a要么是ogep &quot;[0-9]&quot; a.txt 匹配任意一个数字grep &quot;^[a-z] a.txt 匹配用小写字母开头的行grep &quot;^[a-z]&quot; a.txt 匹配用小写字母开头的行 ^ 匹配除中括号的字符以外的任意一个字符grep &quot;^[^a-z]&quot; a.txt 匹配不用小写字母开头的行grep &quot;^[^a-zA-Z]&quot; a.txt 匹配不多字母开头的行\ 转义符grep &quot;\.$&quot; a.txt 匹配使用.结尾的行\{n\} 表示其前面的字符恰好出现n次grep &quot;a\{3\}&quot; a.txt 匹配a字母连续出现三次的字符串grep &quot;[0-9]\{3\}&quot; a.txt 匹配包含连续的三个数字的字符串{n,\} 表示其前面的字符出现不小于n次grep &quot;^[0-9]\{3,\}&quot; a.txt 匹配最少用连续三个数字开头的行\{n,m} 匹配其前面的字符至少出现n次，最多出现m次grep &quot;sa\{1,3\}i&quot; a.txt 匹配在字母s和字母i之前有最少一个a,最多三个a 字符截取命令cut 字段提取命令printf 命令 (严格意义上讲他不属于字符截取命令，因为awk要用到，在这里提出)awk 命令sed 命令cut [选项][文件名] -f 列号: 提取第几列 -d 分隔符: 按照指定分隔符分割列.他的默认分隔符是Tabcut -f &quot;:&quot; -f 1,3 /etc/passwd12345[root@Tiger data]# vim b.txt 这里的空格是Tab键 1 ID NAME gender mark 2 1 liming M 86 3 2 sc M 90 4 3 cao M 83 12345[root@Tiger data]# cut -f 2 b.txtNAMElimingsccao 12345[root@Tiger data]# cut -f 2,4 b.txt NAME markliming 86sc 90cao 83 cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1 常和grep结合使用，查看用户文件，查找普通用户，过滤root，提取用户名称 cut命令的局限df -h | grep /dev/sda3 | cut -d &quot; &quot; -f 5 df命令使用的是空格分隔符，这条命令不能使用，cut对空格使用不友好 printf &#39;输出类型输出格式&#39; 输出内容输出类型:%ns：输出字符串。n是数字指代输出几个字符%ni：输出整数。n是数字指代输出几个数字%m.nf：输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2是小数，6位是整数。 输出格式作用\a输出警告音\b输出退格键，也就是Backspace键\f清除屏幕\n换行\r回车，也就是Enter键\t水平输出退格键，也就是Tab键\v垂直输出退格键，也就是Tab键12345678910[root@Tiger data]# printf %s 1 2 3 4 5 6123456[root@Tiger data]# [root@Tiger data]# printf %s %s %s 1 2 3 4 5 6%s%s123456[root@Tiger data]# [root@Tiger data]# printf &apos;%s %s %s&apos; 1 2 3 4 5 61 2 34 5 6[root@Tiger data]# [root@Tiger data]# printf &apos;%s %s %s\n&apos; 1 2 3 4 5 61 2 34 5 6[root@Tiger data]# printf输出文件内容格式：printf &#39;%s\n&#39; $(cat a.txt)123456[root@Tiger data]# printf &apos;%s\t %s\t %s\t %s\n&apos; $(cat b.txt) 调整格式输出ID NAME gender mark1 liming M 862 sc M 903 cao M 83[root@Tiger data]# 在awk命令的输出中支持print和printf命令print：print会在每个输出之后自动加入一个换行符(linux 默认没有print命令)printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工换行符。 awkawk ‘条件1{动作1} 条件2{动作2}…’ 文件名条件：一般使用关系表达式作为条件x &gt; 10 判断变量x是否大于10x &gt;= 10 大于等于x &lt;= 10 小于等于动作：格式化输出流程控制语句df -h | awk &#39;{print $1 &quot;\t&quot; $5 &quot;\t&quot; $6}&#39; print 自动加入换行符 12[root@Tiger data]# df -h | grep sda3 | awk &apos;&#123;print $5&#125;&apos; | awk -F &apos;%&apos; &apos;&#123;print $1&#125;&apos;62 12[root@Tiger data]# df -h | grep sda3 | awk &apos;&#123;print $5&#125;&apos; | cut -d &quot;%&quot; -f 162 BEGIN END123456awk &apos;BEGIN &#123;printf &quot;打印这里的文字\n&quot;&#125;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&apos; a.txt打印这里的文字NAME genderliming Msc Mcao M awk &#39;{FS=&quot;:&quot;}{print $1 &quot;\t&quot; $3}&#39; /etc/passwd 这样执行的话第一条会无法分割，所以可以在awk &#39;BEGIN{FS=&quot;:&quot;}{print $1 &quot;\t&quot; $3}&#39; /etc/passwd, awk是先读取一行在再执行命令，这样文件的第一行会来不及执行默认空格换行打印出。But但是可以直接用awk -F &quot;:&quot; &#39;{print $2 &quot;\t&quot; $3}&#39; /etc/passwdawk -F &quot;:&quot; &#39;END{print &quot;所有的命令执行完以后再执行&quot;&quot;}{print $2 &quot;\t&quot; $3}&#39; /etc/passwd关系运算符12345678910[root@Tiger data]# cat b.txtID NAME gender mark1 liming M 862 sc M 903 cao M 83[root@Tiger data]# cat b.txt | grep -v NAME | awk &apos;$3 &gt;= 87 &#123;print $2&#125;&apos; limingsccao[root@Tiger data]# sedsed 是一种几乎包括在所有UNIX平台(包括linux)的轻量级流量编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。vi 只能修改文件，但是vi不能修改命令的输出，他只能先把命令的输出保存在文件中，然后修改文件的输出。但是sed可以修改命令的输出结果，结合管道符。sed [选项] &#39;[动作]&#39;文件名-n :一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。 -e :允许对输入数据应用多条sed命令编辑-i :用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出。 动作作用a\追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用\代表数据未完结c\行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用\代表数据未完结i\插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用\代表数据未完结d删除，删除指定的行p打印，输出指定的行s字符替换，用一个字符串替换另外一个字符串。格式为行范围s/旧字符串/新字符串/g(和vim中的替换格式类似). 12345[root@Tiger data]# cat a.txt 例:ID name PHP Linux Mysql Average1 Liming 82 95 86 87.662 Sc 74 96 87 85.663 Gao 99 83 93 91.66 行操作查看文件的第二行12345678[root@Tiger data]# sed &apos;2p&apos; a.txtID name PHP Linux Mysql Average1 Liming 82 95 86 87.661 Liming 82 95 86 87.662 Sc 74 96 87 85.663 Gao 99 83 93 91.66[root@Tiger data]# sed -n &apos;2p&apos; a.txt1 Liming 82 95 86 87.66 删除文件第2行到第4行，可以看到没有对文件本身造成影响1234567[root@Tiger data]# sed &apos;2,4d&apos; a.txtID name PHP Linux Mysql Average[root@Tiger data]# cat a.txtID name PHP Linux Mysql Average1 Liming 82 95 86 87.662 Sc 74 96 87 85.663 Gao 99 83 93 91.66 在第二行后追加hello1sed &apos;2a hello&apos; a.txt 在第二行前插入两行数据12sed &apos;2i hello\world&apos; a.txt 修改第四行文件。将第四行的99替换成5512345678910[root@Tiger data]# sed &apos;4c no file&apos; a.txtID name PHP Linux Mysql Average1 Liming 82 95 86 87.662 Sc 74 96 87 85.66no file[root@Tiger data]# sed &apos;4s/99/55/g&apos; a.txtID name PHP Linux Mysql Average1 Liming 82 95 86 87.662 Sc 74 96 87 85.663 Gao 55 83 93 91.66 字符替换 sed &#39;s/旧字符/新字符/g&#39; 文件名在第3行中，把74换成991sed &apos;3s/74/99/g&apos; a.txt sed操作的数据直接写入文件1sed -i &apos;3s/74/99/g a.txt&apos; 同时把linux和Gao替换为空1sed -e &apos;s/Linux//g;s/Gao//g/a.txt&apos; 前面没有加行号代表整篇文档 字符处理命令统计命令 wc -l :只统计行数 -w :只统计单词数 -m :只统计字符数 sort见command 条件判断按照文件类型判断测试选型作用-b 文件判断该文件是否存在，并且是否为块设备文件(是块设备文件为真)-c 文件判断该文件是否存在，并且是否为字符设备文件(是字符设备文件为真)-d 文件判断该文件是否存在，并且是否为目录文件(是目录为真)-e 文件判断该文件是否存在，(存在为真)-f 文件判断该文件是否存在，并且是否为普通文件(是普通文件为真)-L 文件判断该文件是否存在，并且是否为符号链接文件(是符号链接文件为真)-p 文件判断文件是否存在，并且是否为管道文件(是管道文件为真)-s 文件判断该文件是否存在，并且是否为非空(非空为真)-S 文件判断该文件是否存在，并且是否为套接字文件(是套接字文件为真) 判断文件是否存在(两种格式)test -e /root/install.log-e /root/install.log]第一个判断命令如果正确执行，则打印”yes”，否则打印”no”[ -d /root ] &amp;&amp; echo &quot;yes&quot; || &quot;no&quot;注意空格 按照文件权限进行判断测试选项作用-r 文件判断该文件是否存在，并且是否该文件拥有读权限(有读权限为真)-w 文件判断该文件是否存在，并且是否该文件拥有写权限-x 文件判断该文件是否存在，并且是否该文件拥有执行权限(有执行权限为真)-u 文件判断该文件是否存在，并且是否该文件拥有SUID权限(有SUID权限为真)-g 文件判断该文件是否存在，并且是否该文件拥有SGID权限(有SGID权限为真)-k 文件判断该文件是否存在，并且是否该文件拥有SBit权限(有SBit权限为真). 1test -w /data/a.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 他只要UGO只要有一个有写权限就会执行出来 两个文件之间进行比较测试选项作用文件1 -nt 文件2判断文件1的修改时间是否比文件2的新(如果新则为真)文件1 -ot 文件2判断文件1的修改时间是否比文件2的旧(如果旧则为真)文件1 -ef 文件2判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法比较硬链接的文件Inode号1test a.txt -ef /tmp/a1.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 两个整数之间比较测试选项作用整数1 -eq 整数2判断整数1是否和整数2相等 (相等为真)整数1 -ne 整数2判断整数1是否和整数2不相等 (不相等为真)整数1 -gt 整数2判断整数1 是否大于整数2 (大于为真)整数1 -lt 整数2判断整数1是否小于整数2 (小于为真)整数1 -ge 整数2判断整数1是否大于等于整数2 (大于等于为真)整数1 -le 整数2判断整数1是否小于等于整数2 (小于等于真)1[ 23 -gt 22 ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot; 注意[]左右的空格 字符串的判断测试选项作用-z 字符串判断字符串是否为空(为空返回真)-n 字符串判断字符串是否为非空(非空返回真)子串1 == 子串2判断子串1是否和子串2相等(相等返回真)子串1 ！= 子串2判断字符串1是否和字符串2不相等(不相等为真). 1234[root@Tiger data]# name=scYou have new mail in /var/spool/mail/root[root@Tiger data]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot;N 1234[root@Tiger data]# aa=abc[root@Tiger data]# bb=abc[root@Tiger data]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;y&quot; || echo &quot;N&quot;y 多重条件判断测试选项作用判断1 -a 判断2逻辑与，判断1和判断2都成立，最终的结果才为真判断1 -o 判断2逻辑或，判断1和判断2有一个成立，最终的结果就为真! 判断逻辑非，使原始的判断式取反12345[root@Tiger data]# aa=24[root@Tiger data]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot;yes[root@Tiger data]# [ -z &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot; NO 流程控制语句if123456789单分支if条件语句：if [ 条件判断 ] ;then 程序fi或者if [ 条件判断 ] then 程序fi 单分支条件语句需要注意几个点if语句使用fi结尾,和一般语言使用大括号结尾不同[ 条件判断 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格then后面跟符合条件之后执行的程序，可以放在[]之后，用:分割，也可以换行写入，就不需要；了. 12345678910111213141516171819判断用户输入的是什么文件#!/bin/bashread -p &quot;Please input a filename: &quot; fileif [ -z $file ] then echo &quot;Error please input a filenmae&quot; exit 1 1elif [ ! -e $file ] then echo &quot;Your input is not file!&quot;elif [ -f $file ] then echo &quot;$file is a reguare file&quot;elif [ -d $file ] then echo &quot;$file is a directory file!&quot;else echo &quot;$file is a other file&quot;fi 12345678910111213141516171819备份/etc/目录#!/bin/bashdate=$(date +%F)size=$(du -sh /home)if [ -d /tmp/date ] then echo &quot;date is:$date&quot; &gt; /tmp/date/a.txt echo &quot;size is:$date&quot; &gt;&gt; /tmp/date/a.txt cd /tmp/date tar -zcf home_$date.tar.gz /home a.txt &amp;&gt;/dev/null rm -fr /tmp/date/a.txtelse mkdir /tmp/date echo &quot;date is:$date&quot; &gt; /tmp/date/a.txt echo &quot;size is:$date&quot; &gt;&gt; /tmp/date/a.txt cd /tmp/date tar -zcf home_$date.tar.gz /home a.txt &amp;&gt;/dev/null rm -fr /tmp/date/a.txtfi nmap -sT ip地址：-sT作用扫描指定服务器查找的开放端口12345678910判断sshd服务是否开启#!/bin/bashport=$(nmap -sT 192.168.100.136 | grep ssh | awk &apos;&#123;print $2&#125;&apos;)if [ $port == &quot;open&quot; ] then echo &quot;$(date) sshd is ok!!&quot; &gt;&gt; /tmp/sshd_acc.log else /etc/rc.d/init.d/sshd restart &amp; &gt;/dev/null echo &quot;$(date) sshd reboot!!&quot; &gt;&gt; /tmp/sshd_err.logfi case语句多分支case条件语句 case语句和if…elif…else语句一样，都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。123456789101112131415161718 1 #!/bin/bash 2 echo &apos;shanghai please input &quot;dddd&quot;&apos; 3 echo &apos;guangzhou please input &quot;2&quot;&apos; 4 echo &apos;chengdu please input &quot;3&quot;&apos; 5 read -t 30 -p &quot;Please input your weizhi: &quot; u 6 case $u in 7 &quot;dddd&quot;) 8 echo &quot;shanghai de &quot; 9 ;;10 &quot;2&quot;)11 echo &quot;guangzhou&quot;12 ;;13 &quot;3&quot;)14 echo &quot;chengdu&quot;15 ;;16 *)17 echo &quot;error 1/2/3&quot;18 esac for循环语法一：for 变量 in 值1 值2 值3 do 程序 done12345678910查看当前目录有多少.sh结尾的文件。 #!/bin/bash 2 cd /home/ceshi.sh 3 ls *.sh &gt; ls.log 4 y=1 5 for i in $(cat ls.log) 6 do 7 echo $y 8 y=$(( $y + 1)) 9 done 语法二：for((初始值；循环控制条件；变量变化)) do 程序 done12345678从1加到100 #!/bin/bash 2 s=0 3 for (( i=1;i&lt;=100;i=i+1 )) 4 do 5 s=$(( $s+$i )) 6 done 7 echo $s while循环while循环是不定循环，也称作条件循环。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和for的固定循环不太一样了。1234while [ 条件判断式 ] do 程序 done 1234567891 #!/bin/bash 2 i=1 3 s=0 4 while [ $i -le 100 ] 5 do 6 s=$(( $s+$i )) 7 i=$(( $i+1 )) 8 done 9 echo $s until循环until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。123456789#!/bin/bashi=1s=0until [ $i -gt 100 ] do s=$(( $s+$i )) i=$(( $i+1 )) doneecho $s 服务的简介与分类启动与自启动 服务器启动: 就是在当前系统中让服务运行，并提供功能。 服务自启动: 自启动是指让服务在系统开机重启动之后，随着系统的启动而自动启动服务。rpm包安装的服务：chkconfig --list :查看服务自启动状态，可以看到所有RPM包安装的服务源码包安装的服务：查看服务安装位置，一般是/usr/local下RPM安装服务和源码包安装服务的区别： 就是安装位置的不同 源码包安装包安装在指定位置，一般是/usr/local/RPM包安装在默认位置中service 不能用于源码包，因为service默认搜索的是/etc/rc.d/init.d/这个路径，也就是RPM包安装的路径RPM包的一般存放的默认位置：/etc/init.d/ :启动脚本位置/etc/sysconfig/ :初始化环境配置文件位置/etc/ :配置文件位置/etc/xinted.conf ：xinetd配置文件/etc/xinetd.d/ :基于xinetd服务的启动脚本/var/lib/ :服务产生的数据放在这里/var/Log/ :日志 独立服务的启动：/etc/init.d/独立服务名 start|stop|status|restartservice 独立服务名 start|stop|status|restart status 查询服务的状态 service 红帽专有命令 service –status-all 列出系统所有已经安装的RPM包服务的状态 独立服务的自启动chkconfig命令 （详见command）修改/etc/rc.d/rc.local文件使用ntsysv命令管理自启动(红帽专有命令) 基于xinetd服务 yum -y install xinetd这是可以用chkconfig –list 查看服务可以看到基于xinetd的服务 yum -y install telnet-server 安装telnet服务端chkconfig –list 查看安装的服务Telnet的默认端口是23，netstat -tlun telnet服务还没有开启xinetd服务的启动：vim /etc/xinetd.d/telnet 修改文件service xinetd restart 重启xinetd服务 基于xinetd服务的自启动chkconfig telnet onntsysv 基于xinetd 服务的启动与自启动区别不明显，若关闭telnet(chkconfig telnet off)的自启动会将运行的telnet一并关闭，配置文件也会显示关闭状态。 . 源码包安装服务的启动使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。源码包服务的自启动：vi /etc/rc.d/rc.local 开机自启文件，加入下面的标准启动命令/usr/local/apache2/bin/apachectl start 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动vi /etc/init.d/apache# chkconfig: 35 86 76指定httpd脚本可以被chkconfig命令管理。格式是:chkconfig: 运行级别 启动顺序 关闭顺序#descriptaion:source package apache 说明，内容随意 启动顺序和关闭顺序不能和系统中现有服务的启动关闭顺序一样在/etc/rc.d/可以看到各个启动级别的服务启动关闭文件。例/etc/rc.d/rc3.d里面的文件S01表示依次启动，K01表示依次关闭。不能存在一样的启动关闭级别。 服务的总结： 进程管理进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源. body{ background-image:url(https://ws1.sinaimg.cn/large/005RRiqRly1fvyygdfzt6j31hc0u0138.jpg); background-position:center; background-repeat:repeat-y； }]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
