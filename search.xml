<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[unique]]></title>
    <url>%2F2019%2F09%2F25%2Fsed%2F</url>
    <content type="text"><![CDATA[sed sed源文件 northwest NW Charles Main 3.0 .98 3 34 western WE Sharon Gray 5.3 .97 5 23 southwest SW Lewis Dalsass 2.7 .8 2 18 southern SO Suan Chin 5.1 .95 4 15 southeast SE Patricia Hemenway 4.0 .7 4 17 eastern EA TB Savage 4.4 .84 5 20 northeast NE AM Main Jr. 5.1 .94 3 13 north NO Mar00000 Weber 4.5 .89 5 9 north NO Mar00000 Weber 4.5 .89 5 9 central CT Ann Stephens 5.7 .94 5 13 范围说明：修改从模式 wast 和 east 之间的所有行，将各行的行尾($)替换为字符串**VACA**。换行符被移到新的字符串后面。 [root@Gin scripts]# sed &#39;/west/,/east/s/$/**VACA**/&#39; ceshi.txt northwest NW Charles Main 3.0 .98 3 34**VACA** western WE Sharon Gray 5.3 .97 5 23**VACA** southwest SW Lewis Dalsass 2.7 .8 2 18**VACA** southern SO Suan Chin 5.1 .95 4 15**VACA** southeast SE Patricia Hemenway 4.0 .7 4 17**VACA** eastern EA TB Savage 4.4 .84 5 20 northeast NE AM Main Jr. 5.1 .94 3 13 north NO Margot Weber 4.5 .89 5 9 central CT Ann Stephens 5.7 .94 5 13 说明：默认情况下， sed 打印当前缓存区中的输入行。命令 p 指示 sed 将再次打印该行。选项-n 取消 sed 取消默认打印操作。选线-n 和命令配合使用，模式缓冲区内的输入行，只被打印一次。如果不指定-n 选项， sed 就会像上例中那样，打印出重复的行。如果指定了-n，则sed 只打印包含模式 north 的行。 [root@Gin scripts]# sed -n &#39;/north/p&#39; ceshi.txt northwest NW Charles Main 3.0 .98 3 34 northeast NE AM Main Jr. 5.1 .94 3 13 north NO Margot Weber 4.5 .89 5 9 说明：打印从第 5 行开始第一个以 northeast 开头的行之间的所有行 [root@Gin scripts]# sed -n &#39;5,/northeast/p&#39; ceshi.txt southeast SE Patricia Hemenway 4.0 .7 4 17 eastern EA TB Savage 4.4 .84 5 20 northeast NE AM Main Jr. 5.1 .94 3 13 原文链接:https://www.cnblogs.com/ginvip/p/6376049.html hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eight]]></title>
    <url>%2F2019%2F09%2F25%2FHttp%2F</url>
    <content type="text"><![CDATA[Http HTTP1.0协议介绍http/1.1：1997年1月引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。对于同一个域名，大多数浏览器允许同时建立6个持久连接引入了管道机制（pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率新增方法：PUT、PATCH、OPTIONS、DELETE同一个TCP连接里，所有的数据通信是按次序进行的。服务器只能顺序处理回应，前面的回应慢，会有许多请求排队，造成”队头堵塞”（Head-of-line blocking）为避免上述问题，两种方法：一是减少请求数，二是同时多开持久连接。网页优化技巧，如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等HTTP 协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度 HTTP2.0协议介绍Spdy：2009年,谷歌研发,解决 HTTP/1.1 效率不高问题http/2.0：2015年头信息和数据体都是二进制，称为头信息帧和数据帧复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“队头堵塞“,此双向的实时通信称为多工（Multiplexing）引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push） URIURI: Uniform Resource Identifier统一资源标识，分为URL和URNURN: Uniform Resource Naming，统一资源命名示例： P2P下载使用的磁力链接是URN的一种实现magnet:?xt=urn:btih:660557A6890EF888666URL: Uniform Resorce Locator，统一资源定位符，用于描述某服务器某特定资源位置两者区别：URN如同一个人的名称，而URL代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。URN仅用于命名，而不指定地址 URL组成&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;scheme:方案，访问服务器以获取资源时要使用哪种协议user:用户，某些方案访问资源时需要的用户名password:密码，用户对应的密码，中间用：分隔Host:主机，资源宿主服务器的主机名或IP地址port:端口,资源宿主服务器正在监听的端口号，很多方案有默认端口号path:路径,服务器资源的本地名，由一个/将其与前面的URL组件分隔params:参数，指定输入的参数，参数为名/值对，多个参数，用;分隔query:查询，传递参数给程序，如数据库，用？分隔,多个查询用&amp;分隔frag:片段,一小片或一部分资源的名字，此组件在客户端使用，用#分隔 URL示例http://www.magedu.com:8080/images/logo.jpgftp://mage:password@172.16.0.1/pub/linux.pptrtsp://videoserver/video_demo/ Real Time Streaming Protocolhttp://www.magedu.com/bbs/hello;gender=f/send;type=titlehttps://list.jd.com/list.html?cat=670,671,672&amp;ev=149_2992&amp;sort=sort_t otalsales15_desc&amp;trans=1http://apache.org/index.html#projects-list 网站访问量IP(独立IP)：即Internet Protocol,指独立IP数。一天内来自相同客户机IP地址只计算一次，记录远程客户机IP地址的计算机访问网站的次数，是衡量网站流量的重要指标PV(访问量)： 即Page View, 页面浏览量或点击量，用户每次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV与来访者的数量成正比，PV并不是页面的来访者数量，而是网站被访问的页面数量UV(独立访客)：即Unique Visitor,访问网站的一台电脑为一个访客。一天内相同的客户端只被计算一次。可以理解成访问某网站的电脑的数量。网站判断来访电脑的身份是通过来访电脑的cookies实现的。如果更换了IP后但不清除cookies，再访问相同网站，该网站的统计中UV数是不变的网站统计：http://www.alexa.cn/rank/ 网站访问统计示例示例：甲乙丙三人在同一台通过ADSL上网的电脑上（中间没有断网），分别访问www.magedu.com 网站，并且每人各浏览了2个页面，那么网站的流量统计是：IP: 1 PV:6 UV：1若三人都是ADSL重新拨号后,各浏览了2个页面，则IP: 3 PV:6 UV：1 httpd 版本消失过滤掉注释行和空行，查看httpd的配置文件 [root@tiger html]# grep -Ev &#39;^ *#|^$&#39; /etc/httpd/conf/httpd.conf httpd有一个目录，我们的配置文件可以建立在哪里面，不用修改主配置文件。目录位置配置文件最后一行有提及。位置在/etc/httpd/conf.d目录中，可以建立一个以.conf结尾的文件。依然可以配置httpd.在配置文件中写入可以隐藏apache的版本:ServerTokens Prod，这样就浏览器看不到Apache的版本了。也可以用curl -I ip地址来进行查看 httpd多端口和ip绑定可以多端口访问，就是在配置文件中添加listen 8080重新启动服务以后80和8080都可以访问也可ip和端口进行绑定，那么此端口就只能用绑定的ip来进行通讯listen 192.168.122.1:8080 持久连接持久连接默认是开启的KeepAliveTimeout 20 这个表示持久连接的时间是20秒，在这个阶段不会断开 MPM工作模式prefork：多进程I/O模型，每个进程响应一个请求，默认模型一个主进程：生成和回收n个子进程，创建套接字，不响应请求多个子进程：工作work进程，每个子进程处理一个请求；系统初始时，预先生成多个空闲进程，等待请求，最大不超过1024个worker：复用的多进程I/O模型,多进程多线程，IIS使用此模型一个主进程：生成m个子进程，每个子进程负责生个n个线程，每个线程响应一个请求，并发响应请求：m*nevent：事件驱动模型（worker模型的变种）一个主进程：生成m个子进程，每个进程直接响应n个请求，并发响应请求：m*n，有专门的线程来管理这些keep-alive类型的线程，当有真实请求时，将请求传递给服务线程，执行完毕后，又允许释放。这样增强了高并发场景下的请求处理能力httpd-2.2：event 测试版，centos6默认httpd-2.4：event 稳定版，centos7默认 MPM（ Multi-Processing Module）多路处理模块 prefork, worker, event切换使用的MPM/etc/httpd/conf.modules.d/00-mpm.conf启用要启用的MPM相关的LoadModule指令即可查看静态编译的模块 httpd -l查看静态编译及动态装载的模块 httpd –M动态模块加载：不需重启即生效动态模块路径/usr/lib64/httpd/modules/ prefork的配置：StartServers 8MinSpareServers 5MaxSpareServers 20ServerLimit 256 最多进程数,最大20000MaxRequestsPerChild 4000 子进程最多能处理的请求数量。在处理MaxRequestsPerChild 个请求之后,子进程将会被父进程终止，这时候子进程占用的内存就会释放(为0时永远不释放） http文档根目录定义’Main’ server的文档页面路径 DocumentRoot “/path”在配置文件中修改路径以后，还需要添加 DocumentRoot &quot;/data/www&quot; 只写这一行是没有权限访问的 &lt;Directory &quot;/data/www&quot;&gt; Require all granted &lt;/Directory&gt; 定义站点主页面DirectoryIndex index.html这一行在配置文件中，上面只定义了文件夹，这里定义文件夹下默认打开显示的文件index.html表示站点的默认页面如果定义的文件被删除了，他就会显示httpd默认的欢迎页面。这是由一个配置文件定义的/etc/httpd/conf.d/welcome.conf options 后跟1个或多个以空白字符分隔的选项列表 在选项前的+，- 表示增加或删除指定选项Indexes：指明的URL路径下不存在与定义的主页面资源相符的资源文件时，返回索引列表给用户也就是当定义的页面配置文件访问不到时，就会显示定义的文件夹目录给用户(点来点去的那种) FollowSymLinks：允许访问符号链接文件所指向的源文件None：全部禁用All： 全部允许这个选项就表示，当我在站点目录中使用软连接，链接到其他的文件到此目录中，也能够在网络上显示出来直接在配置文件中加入options indexes FollowSymLinks可以这样写 AllowOverride与访问控制相关的哪些指令可以放在指定目录下的 .htaccess（由AccessFileName指定）文件中，覆盖之前的配置指令只对&lt;directory&gt;语句有效AllowOverride All: .htaccess中所有指令都有效AllowOverride None： .htaccess 文件无效AllowOverride AuthConfig Indexes 除了AuthConfig 和Indexes的其它指令都无法覆盖注意：创建文件.htaccess以后，还需要在主配置文件中写入此类AllowOverride All而且这样命令要在括号里面 &lt;directory /data/www&gt; allowoverride all Require all granted &lt;/directory&gt; 基于IP的访问控制:无明确授权的目录，默认拒绝允许所有主机访问：Require all granted拒绝所有主机访问：Require all denied控制特定的IP访问：Require ip IPADDR：授权指定来源的IP访问Require not ip IPADDR：拒绝特定的IP访问控制特定的主机访问：Require host HOSTNAME：授权特定主机访问Require not host HOSTNAME：拒绝HOSTNAME：FQDN：特定主机domin.tld：指定域名下的所有主机 [root@tiger www]# cat /etc/httpd/conf.d/test.conf &lt;directory /data/www&gt; &lt;requireall&gt; 这个括号也要写 Require all granted require not ip 192.168.67.135 拒绝的ip &lt;/requireall&gt; &lt;/directory&gt; (word例子) 不能有失败，至少有一个成功匹配才成功，即失败优先 &lt;RequireAll&gt; Require all granted Require not ip 172.16.1.1 拒绝特定IP &lt;/RequireAll&gt; 多个语句有一个成功，则成功，即成功优先 &lt;RequireAny&gt; Require all denied require ip 172.16.1.1 允许特定IP &lt;/RequireAny&gt; 允许主目录下的配置文件进行访问，拒绝主目录下的新建的目录下的文件进行访问 [root@tiger news]# cat /etc/httpd/conf.d/test.conf &lt;directory /data/www&gt; 允许 Require all granted &lt;/directory&gt; &lt;directory /data/www/news&gt; 拒绝 require all denied &lt;/directory&gt; 日志设定 日志类型：访问日志错误日志 错误日志：ErrorLog logs/error_logLogLevel warnLogLevel 可选值: debug, info, notice, warn,error, crit, alert, emerg日志路径:/var/log/httpd 定义路径别名alias /s /data2/sports 这里/s只网络访问的一个URL名称，实际访问的路径还是后面的地址 &lt;directory /data2/sports&gt; 给权限允许访问 require all granted &lt;/directory&gt; http://192.168.67.128/s/ 访问看到的就是/data2/sports 里面的文件 基于用户的访问控制认证质询：WWW-Authenticate：响应码为401，拒绝客户端请求，并说明要求客户端提供账号和密码认证：Authorization：客户端用户填入账号和密码后再次发送请求报文；认证通过时，则服务器发送响应的资源认证方式两种：basic：明文digest：消息摘要认证,兼容性差安全域：需要用户认证后方能访问的路径；应该通过名称对其进行标识，以便于告知用户认证的原因用户的账号和密码虚拟账号：仅用于访问某服务时用到的认证标识存储：文本文件，SQL数据库，ldap目录存储，nis等 使用专用命令完成此类文件的创建及用户管理htpasswd [options] /PATH/HTTPD_PASSWD_FILE username -c 自动创建文件，仅应该在文件不存在时使用-p 明文密码-d CRYPT格式加密，默认-m md5格式加密-s sha格式加密-D 删除指定用户 第一次建立账户时加-c选项 htpasswd 建立，后面跟路径 用户名 [root@tiger conf.d]# htpasswd -c /etc/httpd/conf.d/httpdpass tom 以后都不加，不然会把之前建立的用户清空 [root@tiger conf.d]# htpasswd /etc/httpd/conf.d/httpdpass jerr [root@tiger conf.d]# cat httpdpass 查看建立的账户 tom:$apr1$gVIqXX66$IkBt5w2KbS.SmVHJOPD5d. jerry:$apr1$44glLZKy$RC/1cG4dKiacdKaOrqabq0 [root@tiger conf.d]# chmod 600 /etc/httpd/conf.d/httpdpass 改个权限 修改配置文件 &lt;directory /data/www/admin&gt; 表示这个目录是需要账户访问的 AuthType Basic AuthName &quot;welcome to login&quot; AuthUserFile &quot;/etc/httpd/conf.d/httpdpass&quot; 使用的账户文件路径 Require user tom 这里只写了tom表示只有tom可以登录进去。如果写Require valid-user表示所有账号都可以登录 &lt;/directory&gt; [root@tiger www]# setfacl -m u:apache:r /etc/httpd/conf.d/httpdpass 这里是因为之前给了文件600的权限，现在无法访问，就加一个acl可读权限 基于组账号进行认证&lt;directory /data/www/admin&gt; AuthType Basic AuthName &quot;welcome to login&quot; AuthUserFile &quot;/etc/httpd/conf.d/httpdpass&quot; ##继续上面的配置文件 AuthUserFile &quot;/etc/httpd/conf.d/httpgroup&quot; ##添加一个组访问 Require group testgroup ##添加哪个组？添加的是testgroup这个组 &lt;/directory&gt; [root@tiger conf.d]# cat /etc/httpd/conf.d/httpdgroup 组内成员 testgroup:tom jerry [root@tiger conf.d]# cat /etc/httpd/conf.d/httpdpass 成员文件 tom:$apr1$gVIqXX66$IkBt5w2KbS.SmVHJOPD5d. jerry:$apr1$jm3xS1Ty$B0gUZ/keYSzC5XOsw7i5p. 实现用户家目录的http共享基于模块mod_userdir.so实现 SELinux: http_enable_homedirs 相关设置： vim /etc/httpd/conf/httpd.conf ;centos7在[root@tiger conf.d]# vim /etc/httpd/conf.d/userdir.conf &lt;IfModule mod_userdir.c&gt; #UserDir disabled 默认是关闭的，加注释，就打开了 UserDir public_html #public_html指定共享目录的名称(这个目录就在pan用户的家目录下) &lt;/IfModule&gt; &lt;directory /home/pan/public_html&gt; ##这里是允许访问 require all granted &lt;/directory&gt; 如果是要加入验证功能就只需要添加这些 &lt;directory /home/pan/public_html&gt; authtype basic authname &quot;pan home&quot; authuserfile &quot;/etc/httpd/conf.d/httpdpass&quot; require user tom &lt;/directory&gt; 访问: 192.168.67.128/~pan/ erverSignature On | Off | EMail当客户请求的网页并不存在时，服务器将产生错误文档，缺省情况下由于打开了ServerSignature选项，错误文档的最后一行将包含服务器的名字、Apache的版本等信息如果不对外显示这些信息，就可以将这个参数设置为Off设置为Email，将显示ServerAdmin 的Email提示 status页面LoadModule status_module modules/mod_status.so SetHandler server-status ExtendedStatus On 显示扩展信息 &lt;Location &quot;/status&quot;&gt; 这里是文件夹名称，随便取一个名字就行，不用去建立文件夹 SetHandler server-status &lt;/Location&gt; ExtendedStatus On 这里是显示扩展信息 http://192.168.67.128/status 访问可以查看到很多关于Apache的信息 虚拟主机也就是一个主机建立多个网站站点标识： socketIP相同，但端口不同IP不同，但端口均为默认端口FQDN不同： 请求报文中首部 Host: www.magedu.com 有三种实现方案：基于ip：为每个虚拟主机准备至少一个ip地址基于port：为每个虚拟主机使用至少一个独立的port基于FQDN：为每个虚拟主机使用至少一个FQDN 实验: mkdir /data/{a,b,c}site [root@tiger conf.d]# echo www.a.com &gt; /data/asite/index.html [root@tiger conf.d]# echo www.b.com &gt; /data/bsite/index.html [root@tiger conf.d]# echo www.c.com &gt; /data/csite/index.html ##根据IP区分 ip a a 192.168.67.130 dev ens33 给ens33网卡增加一个IP 192.168.67.128 规划就是 对应A网站 192.168.122.1 对应B网站 192.168.67.130 对应C网站 vim /etc/httpd/conf.d/test.conf &lt;virtualhost 192.168.67.128&gt; DocumentRoot &quot;/data/asite&quot; &lt;directory /data/asite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_a.log combined ##这里表示日志的路径，后面combined表示日志的格式主配置文件有设置 &lt;/virtualhost&gt; &lt;virtualhost 192.168.122.1&gt; DocumentRoot &quot;/data/bsite&quot; &lt;directory /data/bsite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_b.log combined &lt;/virtualhost&gt; &lt;virtualhost 192.168.67.130&gt; DocumentRoot &quot;/data/csite&quot; &lt;directory /data/csite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_c.log combined &lt;/virtualhost&gt; curl 192.168.67.128 这里注意一点就是如果配置文件中已经定义过访问目录和文件，之后又添加了虚拟主机，那么之后如果访问127.0.0.1，他还是会访问原来的目录和文件。不会访问虚拟主机-----根据端口区分------ 端口号 vim /etc/httpd/conf.d/test.conf listen 81 listen 82 listen 83 &lt;virtualhost *:81&gt; ##&quot;*&quot;表示本机所有IP DocumentRoot &quot;/data/asite&quot; &lt;directory /data/asite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_a.log combined &lt;/virtualhost&gt; &lt;virtualhost *:82&gt; DocumentRoot &quot;/data/bsite&quot; &lt;directory /data/bsite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_b.log combined &lt;/virtualhost&gt; &lt;virtualhost *:83&gt; DocumentRoot &quot;/data/csite&quot; &lt;directory /data/csite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_c.log testlog &lt;/virtualhost&gt; -----------通过FQDN访问------------ vim /etc/hosts 192.168.67.128 www.a.com www.b.net www.c.cn &lt;virtualhost *:80&gt; servername www.a.com DocumentRoot &quot;/data/asite&quot; &lt;directory /data/asite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_a.log combined &lt;/virtualhost&gt; &lt;virtualhost *:80&gt; servername www.b.net DocumentRoot &quot;/data/bsite&quot; &lt;directory /data/bsite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_b.log combined &lt;/virtualhost&gt; &lt;virtualhost *:80&gt; servername www.c.cn DocumentRoot &quot;/data/csite&quot; &lt;directory /data/csite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_c.log testlog &lt;/virtualhost&gt; [root@tiger ~]# curl www.a.com www.a.com [root@tiger ~]# curl www.b.net www.b.com 这里如果是访问ip [root@tiger ~]# curl 192.168.67.128 www.a.com 这是因为配置文件中，哪个第一个出现，那么这里就会显示哪个 mod_deflate模块使用mod_deflate模块压缩页面优化传输速度适用场景：(1) 节约带宽，额外消耗CPU；同时，可能有些较老浏览器不支持(2) 压缩适于压缩的资源，例如文本文件Level of compression (Highest 9 - Lowest 1)DeflateCompressionLevel 9排除特定旧版本的浏览器，不支持压缩Netscape 4.x 只压缩text/htmlBrowserMatch ^Mozilla/4 gzip-only-text/html Netscape 4.06-08三个版本 不压缩 BrowserMatch ^Mozilla/4.0[678] no-gzip httpd -M 查看加载的模块 cat /etc/httpd/conf.d/test.conf &lt;virtualhost *:80&gt; servername www.a.com DocumentRoot &quot;/data/asite&quot; &lt;directory /data/asite&gt; Require all granted &lt;/directory&gt; customlog /var/log/httpd/access_a.log combined AddOutputFilterByType DEFLATE text/plain 压缩类型 AddOutputFilterByType DEFLATE text/html DeflateCompressionLevel 9 压缩比 &lt;/virtualhost&gt; 浏览器访问文件F12,Headers可以看到大小，如果启用了压缩，就能看到gzip，不显示大小 命令行查看curl -I --compressed www.a.com/m.txt 证书yum install -y mod_ssl ##安装加密模块以后就可以了，但是现在浏览器显示不安全，因为证书 cd /etc/pki/CA [root@tiger CA]# (umask 066;openssl genrsa -out private/cakey.pem 2048) 生成私钥 [root@tiger CA]# tree . ├── certs ├── crl ├── newcerts └── private └── cakey.pem 私钥文件 [root@tiger CA]# openssl req -new -x509 -key private/cakey.pem -out cacert.pem 自签名证书 [root@tiger CA]# touch index.txt [root@tiger CA]# echo 01 &gt; serial [root@tiger CA]# tree . ├── cacert.pem 自签名证书 ├── certs ├── crl ├── index.txt 颁发证书的数据库 ├── newcerts ├── private │ └── cakey.pem 私钥文件 └── serial 颁发证书的序列号 4 directories, 4 files [root@tiger CA]# cd /etc/httpd/conf.d [root@tiger conf.d]# mkdir ssl [root@tiger conf.d]# cd ssl [root@tiger ssl]# pwd /etc/httpd/conf.d/ssl [root@tiger ssl]# (umask 077;openssl genrsa -out httpd.key 1024) [root@tiger ssl]# openssl req -new -key httpd.key -out httpd.csr 这里要填的和之前的一样 [root@tiger ssl]# ls httpd.csr httpd.key 生成的文件 [root@tiger ssl]# cd /etc/pki/CA [root@tiger CA]# openssl ca -in /etc/httpd/conf.d/ssl/httpd.csr -out certs/httpd.crt -days 100 [root@tiger CA]# cp certs/httpd.crt /etc/httpd/conf.d/ssl/ [root@tiger CA]# cp cacert.pem /etc/httpd/conf.d/ssl [root@tiger CA]# ll !$ ll /etc/httpd/conf.d/ssl total 16 -rw-r--r--. 1 root root 1330 Dec 16 21:47 cacert.pem -rw-r--r--. 1 root root 3721 Dec 16 21:47 httpd.crt -rw-r--r--. 1 root root 655 Dec 16 21:33 httpd.csr -rw-------. 1 root root 887 Dec 16 21:31 httpd.key [root@tiger CA]# vim /etc/httpd/conf.d/ssl.conf SSLCertificateFile /etc/httpd/conf.d/ssl/httpd.crt SSLCertificateKeyFile /etc/httpd/conf.d/ssl/httpd.key curl##-A是伪造IE20访问的。-e是伪造通过www.baidu.com这个网站跳转的 [root@tiger ~]# curl -A &#39;IE20&#39; -e &#39;www.baidu.com&#39; http://192.168.67.128 LAMP模块化 这里实现wordpress的博客搭建 phpMyAdmin-4.0.10.20-all-languages.tar 简写pma 安装 php,php-mysql,httpd,mariadb-server 下载下方的两个文件传到/var/www/httpd目录下 mv config.sample.inc.php config.inc.php 解压缩后，进入pma,改名 mv wp-config-sample.php wp-config.php 解压缩后改名 mysql_secure_installation 然后mysql跑一个安全脚本，设定一个密码 然后浏览器访问pma这个目录 网页上就可以创建一个数据库wordpress和添加一个用户(具体查看下方图片)，然后给他所有的权限 MariaDB [(none)]&gt; select user,password,host from mysql.user; 可以进入mysql里面查看 vim /var/www/html/wordpress/wp-config.php // ** MySQL 设置 - 具体信息来自您正在使用的主机 ** // /** WordPress数据库的名称 */ define(&#39;DB_NAME&#39;, &#39;wordpress&#39;); /** MySQL数据库用户名 */ define(&#39;DB_USER&#39;, &#39;wpuser&#39;); /** MySQL数据库密码 */ define(&#39;DB_PASSWORD&#39;, &#39;centos&#39;); /** MySQL主机 */ define(&#39;DB_HOST&#39;, &#39;192.168.67.138&#39;); 现在可以直接访问192.168.67.128/wordpress phpMyAdmin-4.0.10.20-all-languages.tar ——Extraction Code:9xuv wordpress-5.0-zh_CN.zip ——Extraction Code:gnyr FASTCGI 方式三台机器实现的LAMP 1:[root@tiger html]# cat /etc/httpd/conf.d/fcgi.conf DirectoryIndex index.php ProxyRequests Off ProxyPassMatch ^/(.*\.php)$ fcgi://192.168.67.138:9000/data/html/$1 检测来自138主机的文件夹 2:php-fpm php-mysql vim /etc/php-fpm.d/www.conf listen = 9000 #listen.allowed_clients = 127.0.0.1 systemctl restart php-fpm.service 可以看到9000端口已经开启了 [root@pan html]# cat /data/html/pdo.php &lt;?php try{ $user= &#39;text&#39;; $pass= &#39;centos&#39;; $dbh = new PDO(&#39;mysql:host=192.168.67.128;dbname=mysql&#39;, $user, $pass); foreach($dbh-&gt;query(&#39;SELECT user,host from user&#39;) as $row) { print_r($row); } $dbh = null; } catch (PDOException $e) { print &quot;Error!: &quot; . $e-&gt;getMessage() . &quot;&lt;br/&gt;&quot;; die(); } ?&gt; 192.168.67.128安装的是mysql，创建的用户test 密码centos Php-xcache加速访问先搭建一个lamp，mysql数据库建立在.128主机上。 yum install -y httpd php php-mysql 传入wordpress压缩包 tar -xvf wordpress-4.9.4-zh_CN.tar.gz cd wordpress cp -av . /var/www/html ##这里是希望默认访问就是可以访问到，所有直接复制到html目录 mv wp-config-sample.php wp-config.php 编译安装(yum包没有这里编译安装php-cache) yum -y install php-devel 下载并解压缩xcache-3.2.0.tar.bz2h phpize 生成编译环境 cd xcache-3.2.0 ./configure --enable-xcache --with-php-config=/usr/bin/php-config make &amp;&amp; make install cp xcache.ini /etc/php.d/ systemctl restart httpd.service 可以建立此文件，浏览器访问http://192.168.67.138/phpinfo.php，看有没有xcache.ini [root@pan html]# cat phpinfo.php &lt;?php phpinfo(); ?&gt; centos7编译安装LAMP php-7.1.18.tar.bz2 ——Extraction Code:rvqx httpd-2.4.37.tar.bz2 ——Extraction Code:8e2w apr-1.6.5.tar.bz2 ——Extraction Code:rpbz apr-util-1.6.1.tar.bz2 ——Extraction Code:6bq9 wordpress-4.9.4-zh_CN.tar.gz ——Extraction Code:4e52 源码安装Apache 五个文件都下载到lamp文件夹下 [root@tiger lamp]# tar xf apr-1.6.5.tar.bz2 [root@tiger lamp]# tar xf apr-util-1.6.1.tar.bz2 [root@tiger lamp]# tar xf httpd-2.4.37.tar.bz2 [root@tiger lamp]# cp -r apr-1.6.5 httpd-2.4.37/srclib/apr [root@tiger lamp]# cp -r apr-util-1.6.1 httpd-2.4.37/srclib/apr-util [root@tiger lamp]# cd httpd-2.4.37/ yum groupinstall &quot;Development tools&quot; yum install -y pcre-devel openssl-devel expart-devel ##安装依赖包 yum install -y expat cd /root/lamp/httpd-2.4.37 ./configure --prefix=/app/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-included-apr --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork make &amp;&amp; make install [root@pan ~]# echo &#39;PATH=/app/httpd24/bin:$PATH&#39; &gt; /etc/profile.d/lamp.sh [root@pan ~]# . /etc/profile.d/lamp.sh apachectl start ##启动 useradd -r -s /sbin/nologin apache vim /app/httpd24/conf/httpd.conf User apache Group apache apachectl restart mariadb-10.2.19.tar.gz ——Extraction Code:tzgg 现在在另外一台机器上准备数据库 tar -xvf mariadb-10.2.19-linux-x86_64/ -C /usr/local/ 这里解压到指定的目录 useradd -s /sbin/nologin -r mysql -d /data/mysql 建立系统用户mysql cd /usr/local chown -R root:root mysql ln -s mariadb-10.2.19-linux-x86_64/ mysql mkdir /data/mysql -p ##存放数据库的数据路径 chown mysql:mysql /data/mysql/ cd /mysql scripts/mysql_install_db --user=mysql --datadir=/data/mysql ##生成数据库文件到指定目录 mkdir /etc/mysql ##建立配置文件目录 cp /usr/local/mysql/support-files/my-huge.cnf /etc/mysql/my.cnf ##复制配置文件 datadir=/data/mysql ##只修改这一行 cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld ##复制启动脚本 chkconfig --add mysqld 然后启动脚本 echo &#39;PATH=/usr/local/mysql/bin:$PATH&#39; &gt; /etc/profile.d/mysql.sh . /etc/profile.d/mysql.sh ##这里详见 Seven-通用二进制格式安装过程 MariaDB [(none)]&gt; create database wpdb; ##创建数据库和账号 MariaDB [(none)]&gt; grant all on wpdb.* to wpuser@&#39;192.168.67.%&#39; identified by &#39;centos&#39;; 配置phpyum install -y libxml2-devel bzip2-devel libmcrypt-devel(epel) tar -xvf php-7.1.18.tar.bz2 ./configure --prefix=/app/php \ --enable-mysqlnd \ --with-mysqli=mysqlnd \ --with-openssl \ --with-pdo-mysql=mysqlnd \ --enable-mbstring \ --with-freetype-dir \ --with-jpeg-dir \ --with-png-dir \ --with-zlib \ --with-libxml-dir=/usr \ --enable-xml \ --enable-sockets \ --enable-fpm \ --with-config-file-path=/etc \ --with-config-file-scan-dir=/etc/php.d \ --enable-maintainer-zts \ --disable-fileinfo make &amp;&amp; make install vim /app/httpd24/conf/httpd.conf DirectoryIndex index.php index.html ##加上index.php AddType application/x-httpd-php .php ##加在末尾 AddType application/x-httpd-php-source .phps ##加在末尾 cp /root/lamp/php-7.1.18/php.ini-production /etc/php.ini ##准备php的配置文件 cp /root/lamp/php-7.1.18/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm ##准备php的启动程序 chmod +x /etc/init.d/php-fpm chkconfig --add php-fpm vim /app/httpd24/conf/httpd.conf ProxyRequests Off ##将这两行添加到末尾 ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/app/httpd24/htdocs/$1 ##取消下面两行的注释 LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so cd /app/php/etc mv php-fpm.conf.default php-fpm.conf cd php-fpm.d/ mv www.conf.default www.conf service php-fpm start ##启动服务 ss -ntl可以看到服务端口已经打开 配置WordPresstar xf wordpress-4.9.4-zh_CN.tar.gz mv * /app/httpd24/htdocs/ cd /app/httpd24/htdocs/ mv wp-config-sample.php wp-config.php vim wp-config.php /** WordPress数据库的名称 */ define(&#39;DB_NAME&#39;, &#39;wpdb&#39;); /** MySQL数据库用户名 */ define(&#39;DB_USER&#39;, &#39;wpuser); /** MySQL数据库密码 */ define(&#39;DB_PASSWORD&#39;, &#39;centos&#39;); /** MySQL主机 */ define(&#39;DB_HOST&#39;, &#39;192.168.67.141&#39;); 除数据库在另外一台机器上安装以外，其他都是在一台机器上。两台机器需要关闭防火墙 192.168.67.138 直接访问即可 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seven]]></title>
    <url>%2F2019%2F09%2F25%2FDNS%2Bmysql%2F</url>
    <content type="text"><![CDATA[DNS+Mysql DNSyum install -y bind ##安装此软件来做DNS实验 [root@ansible ~]# vim /etc/named.conf 12 options { 13 listen-on port 53 { localhost; }; ##localhost代表本机所有IP address,都能访问 21 allow-query { any; }; ##这里更改了以后，其他机器才能连 或者将这句注释掉，也代表本机所有ip都能访问 [root@ansible ~]# named-checkconf ##直接敲语法检查 [root@ansible ~]# rndc reload 重启生效，其他主机添加了此DNS后，也就可以访问外网了 dig -t ns magedu.com 查看是哪个dns服务器提供解析的 dig www.magedu.com @dns10.hichina.com. ##指定某个dns提供解析 ;; flags: qr aa rd; ##这里有aa字样的就是权威的DNS服务器解析的 资源记录区域解析库：由众多RR组成：资源记录：Resource Record, RR记录类型：A, AAAA, PTR, SOA, NS, CNAME, MXSOA：Start Of Authority，起始授权记录；一个区域解析库有且仅能有一个SOA记录，必须位于解析库的第一条记录A：internet Address，作用，FQDN –&gt; IPAAAA：FQDN –&gt; IPv6PTR：PoinTeR，IP –&gt; FQDNNS：Name Server，专用于标明当前区域的DNS服务器CNAME ： Canonical Name，别名记录MX：Mail eXchanger，邮件交换器TXT：对域名进行标识和说明的一种方式，一般做验证记录时会使用此项，如：SPF（反垃圾邮件）记录，https验证等示例：_dnsauth TXT 2012011200000051qgs69bwoh4h6nht4n1h0lr038x 资源记录定义的格式：vim magedu.com.zone语法：name [TTL] IN rr_type value注意：(1) TTL可从全局继承(2) @可用于引用当前区域的名字(3) 同一个名字可以通过多条记录定义多个不同的值；此时DNS服务器会以轮询方式响应(4) 同一个值也可能有多个不同的定义名字；通过多个不同的名字指向同一个值进行定义；此仅表示通过多个不同的名字可以找到同一个主机 搭建一个DNS服务器-正向解析[root@ansible named]# vim /etc/named.rfc1912.zones ##这是主配置文件中记录的另外一个文件 zone &quot;magedu.com&quot; { type master; ##添加这些 file &quot;magedu.com.zone&quot;; }; [root@ansible named]# cd /var/named/ ##主配置文件中记录的位置 [root@ansible named]# cp -p named.localhost magedu.com.zone [root@ansible named]# vim magedu.com.zone ##修改此文件 $TTL 1D @ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS @ A 127.0.0.1 AAAA ::1 www 1D IN A 6.6.6.6 ##添加的文件 blog.magedu.com. A 7.7.7.7 ##这里写的全称一定要加.简称就是blog [root@ansible named]# named-checkzone magedu.com /var/named/magedu.com.zone ##检查文件语法 [root@ansible named]# rndc reload ##重启生效 ##到另外一台机器上，指定了DNS地址到刚才那台机器上。三种解析工具都可以，得到的是自动定义的ip，dig也有aa的记录 dig blog.magedu.com host www.magedu.com nslookup blog.magedu.com ##这里问题在于除了hosts和ping都可以解析出来(还没解决) 文件分析[root@ansible named]# cat /var/named/magedu.com.zone $TTL 1D @ IN SOA dns1 admin.magedu.com. ##邮箱地址,这里的@有特殊含义，所以用.代替 ( ##本域 ##主DNS服务器名 0 ; serial ##主从版本号对比，数值增加就会和从服务器同步 1D ; refresh ##同步时间间隔 1H ; retry ##如果上一步失败了，重试时间间隔 1W ; expire ##超过此时间从服务器记录将不可查询 3H ) ; minimum ##如果用户查询其他的记录，我这没有，我就会把不存在的记录缓存到服务器上， ##NS,当前DNS服务器 就不会到DNS服务器上去查询，缓存时间就是这里定义的时间 NS dns1 ##本域的DNS服务器 dns1 A 192.168.175.22 ##主DNS服务器地址，当前主机ip NS dns1 dns1 A 192.168.175.22 www CNAME websrv websrv A 6.6.6.6 websrv A 8.8.8.8 websrv A 7.7.7.7 @ MX 10 mailsrv mailsrv A 9.9.9.9 反向解析[root@ansible named]# vim /etc/named.rfc1912.zones 40 zone &quot;175.168.192175.168.in-addr.arpa&quot; IN { 41 type master; 42 file &quot;named.loopback&quot;; 43 allow-update { none; }; 44 }; [root@ansible named]# cat /var/named/192.168.175.zone $TTL 86400 @ IN SOA dnsserver admin.magedu.com. ( 2019101943 3H 10M 1D 1H ) NS dnsserver dnsserver A 192.168.175.22 22 PTR dnsserver.magedu.com. 100 PTR www.magedu.com. 200 PTR blog.magedu.com. [root@ansible named]# named-checkconf [root@ansible named]# named-checkzone 175.168.192.in-addr 192.168.175.zone 检查语法配置 dig -x 192.168.175.22 测试成功 [root@ansible named]# cat magedu.com.zone $TTL 1D @ IN SOA dns1 admin.magedu.com. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.175.22 www CNAME websrv websrv A 6.6.6.6 websrv A 8.8.8.8 websrv A 7.7.7.7 @ MX 10 mailsrv mailsrv A 9.9.9.9 @ A 8.8.8.8 ##这里只需要加上只一句，解析时就不需要再敲www。也就是ping www.magedu.com和ping magedu.com的结果是一样的 * A 8.8.8.8 ##这里的*表示通配符，也就是*.magedu.com的时候，也能识别出来。这种叫做泛域名解析 $GENERATE 1-200 server$ A 192.168.175.$ ##这句表示下面的 server1 A 192.168.175.1 server2 A 192.168.175.2 server3 A 192.168.175.3 server4 A 192.168.175.4 .. server200 A 192.168.175.200 [root@ansible named]# rndc reload [root@ansible named]# dig server50.magedu.com ##测试记录 Set up backup the dns server在另外一台机器上安装修改端口，详见第一步骤 [root@centos7 ~]# vim /etc/named.rfc1912.zones zone &quot;magedu.com&quot; { ## 需要和主服务器同样的域名magedu.com type slave; ##类型 从服务器 masters { 192.168.175.22;}; ##主服务器 file &quot;slaves/magedu.com.zone.slave&quot;; ##将主服务器的数据库复制到本机的指定目录 }; 既然要建立从服务器那么就还要在主服务器上添加从服务器的地址 NS记录表示谁是这个域里面的DNS服务器 [root@ansible named]# vim magedu.com.zone NS dns2 $TTL 1D @ IN SOA dns1 admin.magedu.com. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 NS dns2 dns1 A 192.168.175.22 dns2 A 192.168.175.136 ##这一行就是添加的从服务器的记录 在测试机上，当主服务器网络down了后，从服务器就自动开始工作 DNS安全注意当设置DNS备用服务器时，并没有设置安全机制，也就是说任何机器都可以获取主DNS服务器的配置信息，那么就需要在主DNS服务器里加安全配置，只允许某个地址访问 [root@ansible ~]# vim /etc/named.conf 22 allow-transfer { 192.168.175.136; }; 23 ##只允许这个地址当从DNS服务器 同样的如果别人从备用DNS服务器上拉取文件也有安全隐患，所以备用DNS服务器也要设置 [root@centos7 ~]# vim /etc/named.conf 20 allow-transfer { none; }; 主DNS服务器进行文件推送需要更改serial号 TCP端口负责主从复制，如果只是关闭TCP端口，还是可以查询的，只是文件不能复制 UDP端口负责查询 子域和父域委派放在同一台电脑上配置子域 [root@ansible named]# vim /etc/named.rfc1912.zones zone &quot;beijing.magedu.com&quot; { type master; file &quot;beijing.magedu.com.zone&quot;; }; [root@ansible named]# cat beijing.magedu.com.zone $TTL 1D @ IN SOA dns1 admin. ( 1 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.175.22 www CNAME websrv websrv A 8.8.8.8 dig www.beijing.magedu.com 在其他的机器上测试子域 子域和父域委派(不同机器)需要在主DNS服务器上添加子域的地址 [root@ansible named]# cat magedu.com.zone $TTL 1D @ IN SOA dns1 admin.magedu.com. ( 2 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 NS dns2 shenzhen NS dns3 ##子域 dns1 A 192.168.175.22 dns2 A 192.168.175.136 dns3 A 192.168.175.137 ##子域的地址 www CNAME websrv websrv A 66.66.66.66 1.在另外一台机器上安装DNS服务bind；并修改主配置文件端口信息vim /etc/named.conf 2.[root@c7 yum.repos.d]# vim /etc/named.rfc1912.zones zone &quot;shenzhen.magedu.com&quot; { type master; file &quot;shenzhen.magedu.com.zone&quot;; }; 3.cat /var/named/shenzhen.magedu.com.zone $TTL 1D @ IN SOA dns1 admin ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.175.137 www CNAME websrv websrv A 7.7.7.7 shenzhen.magedu.com.zone 这个文件的所属主要改成named systemctl restart named ##启动服务 在其他机器测试时，dns只写主dns或备用dns服务器地址。看dig是否识别(还未识别实验为成功) DNS转发第一台搭建的DNS [root@ansible ~]# vim /etc/named.rfc1912.zones zone &quot;magedu.com&quot; { type master; file &quot;magedu.com.zone&quot;; }; [root@ansible ~]# cat /var/named/magedu.com.zone $TTL 1D @ IN SOA dns1 admin.magedu.com. ( 2 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 NS dns2 shenzhen NS dns3 dns1 A 192.168.175.22 dns2 A 192.168.175.101 dns3 A 192.168.175.138 www CNAME websrv websrv A 66.66.66.66 当第一台DNS服务器建立好了之后，再另外一台主机再搭一台 [root@centos7 ~]# vim /etc/named.rfc1912.zones zone &quot;wang.com&quot; { type master; file &quot;wang.com.zone&quot;; }; [root@centos7 ~]# cat /var/named/wang.com.zone $TTL 1D @ IN SOA dns1 admin ( 2 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 dns1 A 192.168.175.101 www A 6.6.6.6 ##再到另外一台主机上面检测，现在这台主机上只有主DNS的地址，是检测不到新搭建的，所以要设置转发在主dns主机上 [root@ansible ~]# vim /etc/named.conf forwarde only; ##我这台机器没有，只允许到转发到下面这个地址，如果他没有，就失败 forwarders { 192.168.175.101;}; ##forward first;我这没有转发到指定的机器上，如果指定的机器也没有，我再到互联网上去问 [root@ansible network-scripts]# vim /etc/named.conf ##下面两行记得改为no，不然无法访问 39 dnssec-enable no; 40 dnssec-validation no; ##这样就可以访问了，如果去访问一个不存在的记录，dig www.wnagge.com 我——第一台DNS机器上没有——转发的DNS机器找，如果也没有，——到互联网上去找 如果把机器的网络down了，也能查，因为有缓存。 清缓存rndc flush ##现在改成first first:你问我，我没有，我转到转发的服务器上去，转发的服务器上没有，我再去网络上问 [root@ansible network-scripts]# vim /etc/named.conf forward first; forwarders { 192.168.175.101;}; 那么这个时候，主dns联网，转发的dns没有联网，到其他主机上查一个不存在的记录，只要主dns联网他就可以解析出来 实现智能DNSbind中ACLbind有四个内置的acl:none 没有一个主机any 任意主机localhost 本机localnet 本机的IP同掩码运算后得到的网络地址注意：只能先定义后使用；因此一般定义在配置文件中，处于options的前面----------------------------------实验 ##First [root@ansible named]# cat magedu.com.zone.bj ##表示北京地区 $TTL 1D @ IN SOA dns1 admin.magedu.com. ( 2 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 NS dns2 shenzhen NS dns3 dns1 A 192.168.175.22 dns2 A 192.168.175.101 dns3 A 192.168.175.138 www CNAME websrv websrv A 6.6.6.6 [root@ansible named]# cat magedu.com.zone.sh ##表示上海地区 $TTL 1D @ IN SOA dns1 admin.magedu.com. ( 2 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 NS dns2 shenzhen NS dns3 dns1 A 192.168.175.22 dns2 A 192.168.175.101 dns3 A 192.168.175.138 www CNAME websrv websrv A 7.7.7.7 [root@ansible named]# cat magedu.com.zone.sz $TTL 1D @ IN SOA dns1 admin.magedu.com. ( 2 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1 NS dns2 shenzhen NS dns3 dns1 A 192.168.175.22 dns2 A 192.168.175.101 dns3 A 192.168.175.138 www CNAME websrv websrv A 8.8.8.8 ##Second [root@ansible named]# vim /etc/named.conf acl beijingnet { 192.168.175.0/24; }; acl shanghainet { 192.168.152.0/24; }; acl shenzhennet { any; }; ....................... view view_beijing { match-clients { beijingnet;}; include &quot;/etc/named.rfc1912.zones&quot;; }; view view_shanghai { match-clients { shanghainet;}; include &quot;/etc/named.rfc1912.zones.shanghai&quot;; }; view view_shenzhen { match-clients { shenzhennet;}; include &quot;/etc/named.rfc1912.zones.shenzhen&quot;; }; ##Third: [root@ansible named]# vim /etc/named.rfc1912.zones zone &quot;.&quot; IN { type hint; file &quot;named.ca&quot;; }; zone &quot;magedu.com&quot; { type master; file &quot;magedu.com.zone.bj&quot;; }; [root@ansible named]# cat /etc/named.rfc1912.zones.shanghai zone &quot;.&quot; IN { type hint; file &quot;named.ca&quot;; }; zone &quot;magedu.com&quot; { type master; file &quot;magedu.com.zone.sh&quot;; }; [root@ansible named]# cat /etc/named.rfc1912.zones.shenzhen zone &quot;.&quot; IN { type hint; file &quot;named.ca&quot;; }; zone &quot;magedu.com&quot; { type master; file &quot;magedu.com.zone.sz&quot;; }; Mysqlyum -y install mariadb mariadb-server 本地磁盘安装mariadb ##不进入mysql就执行命令 [root@ansible ~]# mysql -e &quot;show databases;&quot; [root@ansible mysql]# cat /etc/my.cnf [mysqld] skip-networking ##这句表示不走网络连接，加了这句后重启服务，就会默认关闭3306端口 datadir=/var/lib/mysql ##数据库的目录 symbolic-links=0 ##是否支持软链接，0表示禁用，不支持 创建逻辑卷，更换数据库的目录[root@ansible ~]# pvcreate /dev/sda6(干净的分区) Physical volume &quot;/dev/sda6&quot; successfully created. [root@ansible ~]# vgcreate vg0 /dev/sda6 Volume group &quot;vg0&quot; successfully created [root@ansible ~]# lvcreate -n mysql -l 100%FREE vg0 ##使用逻辑卷的所有空间 Logical volume &quot;mysql&quot; created. [root@ansible ~]# lvdisplay ##查看 --- Logical volume --- LV Path /dev/vg0/mysql LV Name mysql VG Name vg0 LV UUID 935qed-srm4-AfkE-ar1U-ca6K-vhxf-gaCeun LV Write Access read/write LV Creation host, time ansible, 2019-11-03 19:19:14 +0800 LV Status available # open 0 LV Size 1020.00 MiB Current LE 255 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:0 [root@ansible ~]# mkfs.xfs /dev/vg0/mysql ##创建文件系统 blkid ##查看 [root@ansible data]# mount /dev/vg0/mysql /data/mysql ##挂载到目录 [root@ansible data]# chown mysql:mysql /data/mysql [root@ansible data]# cat /etc/my.cnf datadir=/data/mysql/ 重启服务，后该目录下方，已有文件产生 通用二进制格式安装过程到mariadb官网下载已经linux-64位编译好的源码包，传入linux中。 tar -xvf mariadb-10.2.19-linux-x86_64.tar.gz -C /usr/local 解压到指定的目录 ln -s /usr/local/mariadb-10.2.19-linux-x86_64/ /usr/local/mysql [root@new local]# chown root:root -R /usr/local/mysql/ ##修改权限 [root@new local]# useradd -r -s /sbin/nologin -d /data/mysql -c &quot;mariadb user&quot; mysql install -d /data/mysql -o mysql -g mysql ##创建目录，install见脚本一章 ##执行mysql的安装数据库脚本在/usr/local/mysql/scripts/mysql_install_db --help 只能在这个目录下执行/usr/local/mysql，因为如果在/usr/local/mysql/scripts/目录下执行，他会报错需要调用一个文件， 在上级目录的bin中。所以要执行这个/usr/local/mysql/scripts/mysql_install_db，只能在他的上级目录执行:/usr/local/mysql scripts/mysql_install_db --user=mysql --datadir=/data/mysql 指定以mysql的身份去去创建，指定创建的文件放在/data/mysql目录 cp support-files/my-huge.cnf /etc/mysql/my.cnf ##复制程序的配置模板文件到指定目录 socket = /data/mysql/mysql.sock ##客户端的sock文件默认到此文件夹寻找 [mysqld] datadir=/data/mysql ##加入这一条 socket = /data/mysql/mysql.sock ##服务器端的sock文件 [root@new mysql]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d 复制服务脚本 cd /etc/init.d/ mv mysql.server mysqld ##改名 chkconfig --list ##查看没有 ， chkconfig --add mysqld ##将此服务加入进去。 注意这都是在centos7上实验。 service restart mysqld ##启动服务 3306端口已开启 此时执行mysql，报错没有办法找到文件目录，是因为执行路径在/usr/local/mysql/bin这个目录下，为了方便使用 echo &#39;PATH=/usr/local/mysql/bin:$PATH&#39; &gt; /etc/profile.d/mysql.sh . /etc/profile.d/mysql.sh mysql ##成功执行 MariaDB [(none)]&gt; show variables like &#39;datadir&#39;; ##查看数据库路径 MariaDB [(none)]&gt; select @@datadir; ##变量的写法 /usr/local/mysql/bin/mysql_secure_installation 给mysql设置密码，但是更改了mysql.sock文件路径报错 vim /etc/mysql/my.cnf 只能先将这里改回来 socket = /tmp/mysql.sock ##客户端的sock文件默认到此文件夹寻找 socket = /tmp/mysql.sock ##服务器端的sock文件 重新启动服务 [root@new mysql]# mysql -uroot -p123456 ##进去mysql use mysql MariaDB [mysql]&gt; select user,host,password,authentication_string from user; ##查看口令 源码安装mariadb安装包 yum install bison bison-devel zlib-devel libcurl-devel libarchive-devel boost-devel gcc gcc-c++ cmake ncurses-devel gnutls-devel libxml2-devel openssl-devel libevent-devel libaio-devel 做准备做准备用户和数据目录 useradd -r -s /sbin/nologin -d /data/mysql/ mysql mkdir /data/mysql chown mysql:mysql /data/mysql 解压 tar -xvf mariadb-10.2.18.tar.gz cmake的重要特性之一是其独立于源码(out-of-source)的编译功能，即编译工作可以在另一个指定的目录中而非源码目录中进行，这可以保证源码目录不受任何一次编译的影响，因此在同一个源码树上可以进行多次不同的编译，如针对于不同平台编译 源码编译安装mariadb cd mariadb-10.2.18/ cmake . \ -DCMAKE_INSTALL_PREFIX=/app/mysql \ -DMYSQL_DATADIR=/data/mysql/ \ -DSYSCONFDIR=/etc/mysql \ -DMYSQL_USER=mysql \ -DWITH_INNOBASE_STORAGE_ENGINE=1 \ -DWITH_ARCHIVE_STORAGE_ENGINE=1 \ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ -DWITH_PARTITION_STORAGE_ENGINE=1 \ -DWITHOUT_MROONGA_STORAGE_ENGINE=1 \ -DWITH_DEBUG=0 \ -DWITH_READLINE=1 \ -DWITH_SSL=system \ -DWITH_ZLIB=system \ -DWITH_LIBWRAP=0 \ -DENABLED_LOCAL_INFILE=1 \ -DMYSQL_UNIX_ADDR=/data/mysql/mysql.sock \ -DDEFAULT_CHARSET=utf8 \ -DDEFAULT_COLLATION=utf8_general_ci -DPLUGIN_TOKUDB=NO ##不加会报错 make -j &amp;&amp; make install 提示：如果出错，执行rm -f CMakeCache.txt /data/mysql ##数据库二进制程序目录 cd /app/mysql/ scripts/mysql_install_db --user=mysql --datadir=/data/mysql echo &#39;PATH=/app/mysql/bin:$PATH&#39; &gt; /etc/profile.d/mysql.sh . /etc/profile.d/mysql.sh cp support-files/my-huge.cnf /etc/my.cnf vim /etc/my.cnf socket=/data/mysql/mysql.sock ##可以看到都已经改好了，编译好了 cp support-files/mysql.server /etc/init.d/mysqld chkconfig --add mysqld 然后启动 SQL语言规范在数据库系统中，SQL语句不区分大小写(建议用大写)SQL语句可单行或多行书写，以“;”结尾关键词不能跨多行或简写用空格和缩进来提高语句的可读性子句通常位于独立行，便于编辑，提高可读性注释：SQL标准： /*注释内容*/ 多行注释 -- 注释内容 单行注释，注意有空格 MySQL注释： # mysql多实例的实现二进制安装完成后的多实例 MariaDB [(none)]&gt; show variables like &#39;datadir&#39;; ##查看mysql数据库路径 +---------------+--------------+ | Variable_name | Value | +---------------+--------------+ | datadir | /data/mysql/ | +---------------+--------------+ 1 row in set (0.04 sec) 退出mysql, cd /data/ [root@new data]# mkdir /mysql/{3306,3307,3308} -pv systemctl stop mariadb ##先停掉现在的mysql cd /mysql [root@new mysql]# mkdir {3306,3307,3308}/{etc,socket,log,pid} -pv [root@new mysql]# chown -R mysql:mysql * ##准备数据库文件。现在执行mysql的安装数据脚本，并生成文件到我们刚刚创建的目录中(去刚刚已经利用二进制安装包安装的mysql目录) cd /usr/local/mysql [root@new mysql]# ./scripts/mysql_install_db --user=mysql --datadir=/mysql/3306 [root@new mysql]# ./scripts/mysql_install_db --user=mysql --datadir=/mysql/3307 [root@new mysql]# ./scripts/mysql_install_db --user=mysql --datadir=/mysql/3308 ##继续准备数据库的配置文件 [root@new mysql]# cp /etc/mysql/my.cnf /mysql/3306/etc [root@new mysql]# cp /etc/mysql/my.cnf /mysql/3307/etc [root@new mysql]# cp /etc/mysql/my.cnf /mysql/3308/etc [root@new mysql]# vim /mysql/3306/etc/my.cnf [client] #password = your_password port = 3306 ##修改端口号 socket = /mysql/3306/socket/mysql.sock ##主要修改这里 [mysqld] datadir=/data/mysql port = 3306 socket = /mysql/3306/socket/mysql.sock ##主要修改这里 依次复制到/mysql/3307/etc/my.cnf 并修改端口和文件夹位置 依次复制到/mysql/3308/etc/my.cnf 准备服务的启动脚本，详情看下面的服务启动脚本。 [root@new mysql]# chmod +x 3306/mysqld ##给脚本加上执行权限 [root@new mysql]# chmod +x 3307/mysqld [root@new mysql]# chmod +x 3308/mysqld [root@new mysql]# . 3306/mysqld start ss -ntl 可以看到对应的端口已经开启 [root@new mysql]# mysql -uroot -p -S /mysql/3308/socket/mysql.sock 或者 [root@new mysql]# mysql -uroot -h127.0.0.1 -P 3308 [root@new 3308]# ./mysqld stop ##停止运行 [root@new 3308]# mysql -uroot -h127.0.0.1 -P 3308 MariaDB [(none)]&gt; select user,password,host from mysql.user; ##查看口令 [root@new 3308]# mysql_secure_installation -S /mysql/3308/socket/mysql.sock ##设置安全选项，设置口令 [root@new 3308]# mysql -uroot -h127.0.0.1 -P 3308 -P123456 ##进入mysql需要加密码 [root@new 3308]# cp mysqld /etc/init.d/mysqld3308 ##使用service命令来控制 [root@new 3308]# service mysqld3308 start ##启动成功 chkconfig --add mysqld3308 如果要使用chkconfig命令来控制，就还需要在服务启动脚本文件中加入这一行 #chkconfig: 345 80 2 345 代表在哪些模式下使用，80表示启动顺序可以在cat /etc/rc.5d(我现在是桌面模式下)里面进行查看各个服务的启动顺序 -----------------------服务启动脚本----------------------------- 依次拷贝到3306,3307,3308 下，并更改port端口号 [root@new mysql]# cat 3306/mysqld #!/bin/bash #chkconfig: 345 80 2 port=3306 mysql_user=&quot;root&quot; mysql_pwd=&quot;&quot; ##这里填写设置的口令 cmd_path=&quot;/usr/local/mysql/bin&quot; ##数据库的二进制路径，注意这里之前是以二进制安装的路径(上面) mysql_basedir=&quot;/mysql&quot; mysql_sock=&quot;${mysql_basedir}/${port}/socket/mysql.sock&quot; function_start_mysql() { if [ ! -e &quot;$mysql_sock&quot; ];then printf &quot;Starting MySQL...\n&quot; ${cmd_path}/mysqld_safe --defaults-file=${mysql_basedir}/${port}/etc/my.cnf &amp;&gt; /dev/null &amp; else printf &quot;MySQL is running...\n&quot; exit fi } function_stop_mysql() { if [ ! -e &quot;$mysql_sock&quot; ];then printf &quot;MySQL is stopped...\n&quot; exit else printf &quot;Stoping MySQL...\n&quot; ${cmd_path}/mysqladmin -u ${mysql_user} -p${mysql_pwd} -S ${mysql_sock} shutdown fi } ## -p${mysql_pwd} 这个表示关闭mysql时是否提示需要输入密码 ##如果设置了口令，这里被注释掉，关闭mysql的时候就会报错。也就是设置了口令后 ##这里不能被注释，而且上面还需要添加这是的口令，在这个文件中 function_restart_mysql() { printf &quot;Restarting MySQL...\n&quot; function_stop_mysql sleep 2 function_start_mysql } case $1 in start) function_start_mysql ;; stop) function_stop_mysql ;; restart) function_restart_mysql ;; *) printf &quot;Usage: ${mysql_basedir}/${port}/bin/mysqld {start|stop|restart}\n&quot; esac [root@new 3307]# cat ../3306/etc/my.cnf [mysqld] port=3306 datadir=/mysql/3306 socket=/mysql/3306/socket/mysql.sock # Disabling symbolic-links is recommended to prevent assorted security risks symbolic-links=0 # Settings user and group are ignored when systemd is used. # If you need to run mysqld under a different user or group, # customize your systemd unit file for mariadb according to the # instructions in http://fedoraproject.org/wiki/Systemd [mysqld_safe] log-error=/mysql/3306/log/mariadb.log pid-file=/mysql/3306/pid/mariadb.pid # # include all files from the config directory # #!includedir /etc/my.cnf.d ## 因为现在的mysql里面show databases;etc目录也会显示出来，所以先给数据库文件夹换一个目录 [root@new 3307]# mv mysqld etc/ /mnt rm -fr * mkdir {data,etc,pid,socker,log} cd /usr/local/mysql ./scripts/mysql_install_db --user=mysql --datadir=/mysql/3307/data cd /mysql/3307/data [root@new data]# mv /mnt/etc /mnt/mysqld /mysql/3307 [root@new 3307]# vim etc/my.cnf datadir=/mysql/3307/data [root@new 3307]# ./mysqld start [root@new 3307]# mysql -uroot -S socket/mysql.sock 数据库和表管理mysql -uroot -S /mysql/3307/socket/mysql.sock MariaDB [(none)]&gt; create database testdb; ##创建数据库，对应的自动建立/mysql/3307/data/testdb这个目录 MariaDB [(none)]&gt; show create database testdb; ##查看当初是怎么建立数据库的 +----------+-------------------------------------------------------------------+ | Database | Create Database | +----------+-------------------------------------------------------------------+ | testdb | CREATE DATABASE `testdb` /*!40100 DEFAULT CHARACTER SET latin1 */ | latin1 就是字符集 +----------+-------------------------------------------------------------------+ 1 row in set (0.00 sec) MariaDB [(none)]&gt;create database db_utf8mb64 CHARCTER SET=utf8mb4; ##创建数据库，指定字符集 MariaDB [(none)]&gt;drop database testdb; ##删除数据库 create database studentdb; use studentdb; MariaDB [studentdb]&gt; create table student (id int unsigned auto_increment primary key,name varchar(10) not null,sex enum(&#39;f&#39;,&#39;m&#39;) default &#39;m&#39;,age tinyint unsigned ,mobile char(11),address varchar(50)); ##创建表 unsigned 全是正数,auto_increment 自动递增。primary key 表示主键，varchar 占用空间不一样(char 占用一样的空间)， not null 不允许为空，enum 指定输入值，default &#39;m&#39; 默认值是m，就是如果不输入自动填m，不允许空值。TINYINT 1字节。 char 字符串 固定最大字符长度 MariaDB [studentdb]&gt;desc student; 或者 show columns from student; ##查看表 show table status like &#39;student&#39;\G ##查看表状态 show table status status from mysql\G ##查看mysql仓库中的表 show indexes from student\G ##查看索引 DML语句增，删，改 MariaDB [studentdb]&gt; select * from student; ##可以看出这张表是空表 Empty set (0.01 sec) MariaDB [studentdb]&gt; select count(*) student; ##查询这张表中的记录数，现在还未添加记录 +----------+ | count(*) | +----------+ | 0 | +----------+ MariaDB [studentdb]&gt; desc student; +---------+---------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +---------+---------------------+------+-----+---------+----------------+ | id | int(10) unsigned | NO | PRI | NULL | auto_increment | | name | varchar(10) | NO | | NULL | | | sex | enum(&#39;f&#39;,&#39;m&#39;) | YES | | m | | | age | tinyint(3) unsigned | YES | | NULL | | | mobile | char(11) | YES | | NULL | | | address | varchar(50) | YES | | NULL | | +---------+---------------------+------+-----+---------+----------------+ 6 rows in set (0.01 sec) ##添加记录一，id会自动增加没有添加，sex默认自动指定也没有添加 MariaDB [studentdb]&gt; insert into student (name,age,mobile,address) values (&#39;mage&#39;,30,10086,&#39;beijing&#39;), -&gt; (&#39;zhangsir&#39;,28,10010,&#39;zhengzhou&#39;); Query OK, 2 rows affected (0.03 sec) Records: 2 Duplicates: 0 Warnings: 0 MariaDB [studentdb]&gt; select * from student; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | +----+----------+------+------+--------+-----------+ [studentdb]&gt; select count(*) from student; ##只添加了两条记录 +----------+ | count(*) | +----------+ | 2 | +----------+ 添加数据---------------------------------添加记录二----------------------------- 另外一种添加数据的方式 MariaDB [studentdb]&gt; insert student set name=&apos;wang&apos;,age=18,address=&apos;beijing&apos;; Query OK, 1 row affected (0.00 sec) MariaDB [studentdb]&gt; select * from student; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 3 | wang | m | 18 | NULL | beijing | +----+----------+------+------+--------+-----------+ 3 rows in set (0.00 sec) MariaDB [studentdb]&gt; insert into student (age,name,mobile,address) values (20,&apos;zhao&apos;,null,&apos;shanghai&apos;); Query OK, 1 row affected (0.01 sec) MariaDB [studentdb]&gt; select * from student; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 3 | wang | m | 18 | NULL | beijing | | 4 | zhao | m | 20 | NULL | shanghai | +----+----------+------+------+--------+-----------+ 4 rows in set (0.00 sec) ------------------------------克隆表到新表(复制数据和不复制数据)--------------------------------- ##克隆某个表到新表 MariaDB [studentdb]&gt; create table employee select * from student; Query OK, 2 rows affected (0.02 sec) Records: 2 Duplicates: 0 Warnings: 0 MariaDB [studentdb]&gt; desc employee; ##可以看到表结构与原表一样 +---------+---------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+---------------------+------+-----+---------+-------+ | id | int(10) unsigned | NO | | 0 | | | name | varchar(10) | NO | | NULL | | | sex | enum(&apos;f&apos;,&apos;m&apos;) | YES | | m | | | age | tinyint(3) unsigned | YES | | NULL | | | mobile | char(11) | YES | | NULL | | | address | varchar(50) | YES | | NULL | | +---------+---------------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) ##刚刚添加的内容也是一样的，都克隆过去了 MariaDB [studentdb]&gt; select * from employee; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | +----+----------+------+------+--------+-----------+ 2 rows in set (0.00 sec) ##只克隆表结构，不克隆内容 MariaDB [studentdb]&gt; create table custom like student; Query OK, 0 rows affected (0.01 sec) MariaDB [studentdb]&gt; desc custom; +---------+---------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +---------+---------------------+------+-----+---------+----------------+ | id | int(10) unsigned | NO | PRI | NULL | auto_increment | | name | varchar(10) | NO | | NULL | | | sex | enum(&apos;f&apos;,&apos;m&apos;) | YES | | m | | | age | tinyint(3) unsigned | YES | | NULL | | | mobile | char(11) | YES | | NULL | | | address | varchar(50) | YES | | NULL | | +---------+---------------------+------+-----+---------+----------------+ 6 rows in set (0.00 sec) ##将现有的表student的数据克隆到另外一张表custom上(前提条件为:现有的表与原表的结构是一样的) MariaDB [studentdb]&gt; insert custom select * from student; 添加中文到db_utf8mb4仓库里面，新建student表并且复制studentdb仓库的student表(没有数据) MariaDB [db_utf8mb4]&gt; create table student like studentdb.student; ##在db_utf8mb4仓库中,将studentdb仓库中的student表中的数据拷贝到db_utf8mb4仓库中的student表里面 MariaDB [db_utf8mb4]&gt; insert student select * from studentdb.student; MariaDB [db_utf8mb4]&gt; alter table student CHARACTER SET = utf8mb4; ##更改字符集，这条命令执行以后，status查看，可以看到utf8mb8只有一个生效了，编码不一致 那么修改整个数据库的编码需要在/etc/my.cnf和/etc/my.cnf.d/mysql-clients.cnf的配置文件里面修改， 一个服务器，一个客户端。 vim /etc/my.cnf ##这里的两个文件是磁盘下安装的mysql里面的文件试验成功的 character-set-server=utf8mb4 vim /etc/my.cnf.d/mysql-clients.cnf [mysql] default-character-set=utf8mb4 再次进入mysql，status就能看到编码都是utf8mb4，这个数据库的实例就都是这个编码，那么此时此刻就可以在表中 存取中文的字符了。 MariaDB [db_utf8mb4]&gt; desc t1; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | char(3) | YES | | NULL | | +-------+---------+------+-----+---------+-------+ 2 rows in set (0.01 sec) MariaDB [db_utf8mb4]&gt; insert t1 values(1,&#39;王&#39;); MariaDB [db_utf8mb4]&gt; select * from t1; +------+------+ | id | name | +------+------+ | 1 | 王 | +------+------+ 这里需要注意的是，虽然默认改了配置文件可以添加中文字段了，但是如果在建立表的时候字段指定的是其他的(例:latin1)，也是无法添加中文字段的。show create table 表名:可以查看到 show create table t2 后，经过删除某些代码后，可以直接粘贴，自动创建 CREATE TABLE `t2` ( `id` int(10) unsigned NOT NULL DEFAULT 0, `name` varchar(10) NOT NULL, `sex` enum(&#39;f&#39;,&#39;m&#39;) DEFAULT &#39;m&#39;, `age` tinyint(3) unsigned DEFAULT NULL, `mobile` char(11) DEFAULT NULL, `address` varchar(50) DEFAULT NULL ) ENGINE=InnoDB 然后自动创建t2表后，没有指定字符集，他会用自动指定的字符集，再次用show table t2 查看 MariaDB [db_utf8mb4]&gt; insert t2 (name,age,address) values(&#39;马哥&#39;,22,&#39;北京&#39;); ##添加中文 Query OK, 1 row affected (0.01 sec) MariaDB [db_utf8mb4]&gt; select * from t2; +----+--------+------+------+--------+---------+ | id | name | sex | age | mobile | address | +----+--------+------+------+--------+---------+ | 0 | 马哥 | m | 22 | NULL | 北京 | +----+--------+------+------+--------+---------+ 删除MariaDB [db_utf8mb4]&gt; select * from student; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 3 | wang | m | 18 | NULL | beijing | | 4 | zhao | m | 20 | NULL | shanghai | | 5 | libai | m | 26 | NULL | changan | +----+----------+------+------+--------+-----------+ 5 rows in set (0.00 sec) MariaDB [db_utf8mb4]&gt; delete from student where id &gt;=5; ##删除数据一定记得加上条件 Query OK, 1 row affected (0.00 sec) MariaDB [db_utf8mb4]&gt; select * from student; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 3 | wang | m | 18 | NULL | beijing | | 4 | zhao | m | 20 | NULL | shanghai | +----+----------+------+------+--------+-----------+ [21:27:504 rows in set (0.00 sec) truncate table student; ##也可以使用这条命令，他也可以删除，都是删除数据，不删除表 将每个表的文件独立分开，强烈建议加上。MariaDB [db_utf8mb4]&gt; show variables like &#39;%per_table%&#39;; +-----------------------+-------+ | Variable_name | Value | +-----------------------+-------+ | innodb_file_per_table | ON | ##ON表示开启的，如果是OFF需要在配置文件中打开 +-----------------------+-------+ 在配置文件中加上 innodb_file_per_table 修改表的数据字段MariaDB [db_utf8mb4]&gt; select * from student; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 3 | wang | m | 18 | NULL | beijing | | 4 | zhao | m | 20 | NULL | shanghai | +----+----------+------+------+--------+-----------+ 4 rows in set (0.00 sec) MariaDB [db_utf8mb4]&gt; update student set name=&#39;bbb&#39; where id=4; ##修改注意加上where条件 Query OK, 1 row affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 0 MariaDB [db_utf8mb4]&gt; select * from student; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 3 | wang | m | 18 | NULL | beijing | | 4 | bbb | m | 20 | NULL | shanghai | +----+----------+------+------+--------+-----------+ 4 rows in set (0.00 sec) 这种where容易忘记，容易出错，为了避免人间惨剧的发生,加一条语句到客户端里面去 [root@new etc]# vim my.cnf.d/mysql-clients.cnf [mysql] safe-updates ##那么以后删除表的不加where就不会执行 DML语言MariaDB [studentdb]&gt; select * from student; ##&quot;*&quot;表示所有字段的字段名 +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 3 | wang | m | 18 | NULL | beijing | | 4 | zhao | m | 20 | NULL | shanghai | | 5 | libai | m | 26 | NULL | changan | +----+----------+------+------+--------+-----------+ 5 rows in set (0.02 sec) MariaDB [studentdb]&gt; select name,id,age from student; ##这里的顺序不同，显示也就不同 +----------+----+------+ | name | id | age | +----------+----+------+ | mage | 1 | 30 | | zhangsir | 2 | 28 | | wang | 3 | 18 | | zhao | 4 | 20 | | libai | 5 | 26 | +----------+----+------+ 5 rows in set (0.00 sec) ##设置查看时显示中文 MariaDB [studentdb]&gt; select name as 姓名,id ,age from student; +----------+----+------+ | 姓名 | id | age | +----------+----+------+ | mage | 1 | 30 | | zhangsir | 2 | 28 | | wang | 3 | 18 | | zhao | 4 | 20 | | libai | 5 | 26 | +----------+----+------+ 5 rows in set (0.00 sec) ##as可以带也可以不带 MariaDB [studentdb]&gt; select name as 姓名,id 序号,age 年龄 from student; +----------+--------+--------+ | 姓名 | 序号 | 年龄 | +----------+--------+--------+ | mage | 1 | 30 | | zhangsir | 2 | 28 | | wang | 3 | 18 | | zhao | 4 | 20 | | libai | 5 | 26 | +----------+--------+--------+ ##加入条件显示 MariaDB [studentdb]&gt; select * from student where age &gt; 20; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 5 | libai | m | 26 | NULL | changan | +----+----------+------+------+--------+-----------+ 3 rows in set (0.02 sec) ##and条件 MariaDB [studentdb]&gt; select * from student where age &gt;=26 and age &lt;=28; 或者使用这句一样的效果: select * from student where age between 26 and 28; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 5 | libai | m | 26 | NULL | changan | +----+----------+------+------+--------+-----------+ ##表示只显示20和30 MariaDB [studentdb]&gt; select * from student where age in (20,30); ##mobile是null的显示 MariaDB [studentdb]&gt; select * from student where mobile is null; ##查询为空的 +----+-------+------+------+--------+----------+ | id | name | sex | age | mobile | address | +----+-------+------+------+--------+----------+ | 3 | wang | m | 18 | NULL | beijing | | 4 | zhao | m | 20 | NULL | shanghai | | 5 | libai | m | 26 | NULL | changan | +----+-------+------+------+--------+----------+ MariaDB [studentdb]&gt; select * from student where mobile is not null; ##查询不为空的 模糊匹配MariaDB [studentdb]&gt; select * from student where name like &#39;%a%&#39;; +----+----------+------+------+--------+-----------+ ##这句表示name包含a的字段，%是通配符 | id | name | sex | age | mobile | address | ##如果查找已a开头的就是a% +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 3 | wang | m | 18 | NULL | beijing | | 4 | zhao | m | 20 | NULL | shanghai | | 5 | libai | m | 26 | NULL | changan | +----+----------+------+------+--------+-----------+ MariaDB [studentdb]&gt; insert student (name,sex,age)values(&#39;xieshan&#39;,&#39;f&#39;,20); MariaDB [studentdb]&gt; select * from student; +----+----------+------+------+--------+-----------+ | id | name | sex | age | mobile | address | +----+----------+------+------+--------+-----------+ | 1 | mage | m | 30 | 10086 | beijing | | 2 | zhangsir | m | 28 | 10010 | zhengzhou | | 3 | wang | m | 18 | NULL | beijing | | 4 | zhao | m | 20 | NULL | shanghai | | 5 | libai | m | 26 | NULL | changan | | 6 | xieshan | f | 20 | NULL | NULL | +----+----------+------+------+--------+-----------+ MariaDB [studentdb]&gt; select distinct sex from student; ##去除重复显示 +------+ | sex | +------+ | m | | f | +------+ 最大值，最小值，分组---------------------------------实验sql脚本----------------------------- [root@new ~]# cat hellodb_MyISAM.sql -- MySQL dump 10.13 Distrib 5.5.33, for Linux (x86_64) -- -- Host: localhost Database: hellodb -- ------------------------------------------------------ -- Server version 5.5.33-log /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */; /*!40101 SET NAMES utf8 */; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */; /*!40103 SET TIME_ZONE=&apos;+00:00&apos; */; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&apos;NO_AUTO_VALUE_ON_ZERO&apos; */; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */; -- -- Current Database: `hellodb` -- CREATE DATABASE /*!32312 IF NOT EXISTS*/ `hellodb` /*!40100 DEFAULT CHARACTER SET utf8 */; USE `hellodb`; -- -- Table structure for table `classes` -- DROP TABLE IF EXISTS `classes`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `classes` ( `ClassID` tinyint(3) unsigned NOT NULL AUTO_INCREMENT, `Class` varchar(100) DEFAULT NULL, `NumOfStu` smallint(5) unsigned DEFAULT NULL, PRIMARY KEY (`ClassID`) ) ENGINE=MyISAM AUTO_INCREMENT=9 DEFAULT CHARSET=utf8; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `classes` -- LOCK TABLES `classes` WRITE; /*!40000 ALTER TABLE `classes` DISABLE KEYS */; INSERT INTO `classes` VALUES (1,&apos;Shaolin Pai&apos;,10),(2,&apos;Emei Pai&apos;,7),(3,&apos;QingCheng Pai&apos;,11),(4,&apos;Wudang Pai&apos;,12),(5,&apos;Riyue Shenjiao&apos;,31),(6,&apos;Lianshan Pai&apos;,27),(7,&apos;Ming Jiao&apos;,27),(8,&apos;Xiaoyao Pai&apos;,15); /*!40000 ALTER TABLE `classes` ENABLE KEYS */; UNLOCK TABLES; -- -- Table structure for table `coc` -- DROP TABLE IF EXISTS `coc`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `coc` ( `ID` int(10) unsigned NOT NULL AUTO_INCREMENT, `ClassID` tinyint(3) unsigned NOT NULL, `CourseID` smallint(5) unsigned DEFAULT NULL, PRIMARY KEY (`ID`) ) ENGINE=MyISAM AUTO_INCREMENT=15 DEFAULT CHARSET=utf8; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `coc` -- LOCK TABLES `coc` WRITE; /*!40000 ALTER TABLE `coc` DISABLE KEYS */; INSERT INTO `coc` VALUES (1,1,2),(2,1,5),(3,2,2),(4,2,6),(5,3,1),(6,3,7),(7,4,5),(8,4,2),(9,5,1),(10,5,9),(11,6,3),(12,6,4),(13,7,4),(14,7,3); /*!40000 ALTER TABLE `coc` ENABLE KEYS */; UNLOCK TABLES; -- -- Table structure for table `courses` -- DROP TABLE IF EXISTS `courses`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `courses` ( `CourseID` smallint(5) unsigned NOT NULL AUTO_INCREMENT, `Course` varchar(100) NOT NULL, PRIMARY KEY (`CourseID`) ) ENGINE=MyISAM AUTO_INCREMENT=8 DEFAULT CHARSET=utf8; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `courses` -- LOCK TABLES `courses` WRITE; /*!40000 ALTER TABLE `courses` DISABLE KEYS */; INSERT INTO `courses` VALUES (1,&apos;Hamo Gong&apos;),(2,&apos;Kuihua Baodian&apos;),(3,&apos;Jinshe Jianfa&apos;),(4,&apos;Taiji Quan&apos;),(5,&apos;Daiyu Zanghua&apos;),(6,&apos;Weituo Zhang&apos;),(7,&apos;Dagou Bangfa&apos;); /*!40000 ALTER TABLE `courses` ENABLE KEYS */; UNLOCK TABLES; -- -- Table structure for table `scores` -- DROP TABLE IF EXISTS `scores`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `scores` ( `ID` int(10) unsigned NOT NULL AUTO_INCREMENT, `StuID` int(10) unsigned NOT NULL, `CourseID` smallint(5) unsigned NOT NULL, `Score` tinyint(3) unsigned DEFAULT NULL, PRIMARY KEY (`ID`) ) ENGINE=MyISAM AUTO_INCREMENT=16 DEFAULT CHARSET=utf8; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `scores` -- LOCK TABLES `scores` WRITE; /*!40000 ALTER TABLE `scores` DISABLE KEYS */; INSERT INTO `scores` VALUES (1,1,2,77),(2,1,6,93),(3,2,2,47),(4,2,5,97),(5,3,2,88),(6,3,6,75),(7,4,5,71),(8,4,2,89),(9,5,1,39),(10,5,7,63),(11,6,1,96),(12,7,1,86),(13,7,7,83),(14,8,4,57),(15,8,3,93); /*!40000 ALTER TABLE `scores` ENABLE KEYS */; UNLOCK TABLES; -- -- Table structure for table `students` -- DROP TABLE IF EXISTS `students`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `students` ( `StuID` int(10) unsigned NOT NULL AUTO_INCREMENT, `Name` varchar(50) NOT NULL, `Age` tinyint(3) unsigned NOT NULL, `Gender` enum(&apos;F&apos;,&apos;M&apos;) NOT NULL, `ClassID` tinyint(3) unsigned DEFAULT NULL, `TeacherID` int(10) unsigned DEFAULT NULL, PRIMARY KEY (`StuID`) ) ENGINE=MyISAM AUTO_INCREMENT=26 DEFAULT CHARSET=utf8; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `students` -- LOCK TABLES `students` WRITE; /*!40000 ALTER TABLE `students` DISABLE KEYS */; INSERT INTO `students` VALUES (1,&apos;Shi Zhongyu&apos;,22,&apos;M&apos;,2,3),(2,&apos;Shi Potian&apos;,22,&apos;M&apos;,1,7),(3,&apos;Xie Yanke&apos;,53,&apos;M&apos;,2,16),(4,&apos;Ding Dian&apos;,32,&apos;M&apos;,4,4),(5,&apos;Yu Yutong&apos;,26,&apos;M&apos;,3,1),(6,&apos;Shi Qing&apos;,46,&apos;M&apos;,5,NULL),(7,&apos;Xi Ren&apos;,19,&apos;F&apos;,3,NULL),(8,&apos;Lin Daiyu&apos;,17,&apos;F&apos;,7,NULL),(9,&apos;Ren Yingying&apos;,20,&apos;F&apos;,6,NULL),(10,&apos;Yue Lingshan&apos;,19,&apos;F&apos;,3,NULL),(11,&apos;Yuan Chengzhi&apos;,23,&apos;M&apos;,6,NULL),(12,&apos;Wen Qingqing&apos;,19,&apos;F&apos;,1,NULL),(13,&apos;Tian Boguang&apos;,33,&apos;M&apos;,2,NULL),(14,&apos;Lu Wushuang&apos;,17,&apos;F&apos;,3,NULL),(15,&apos;Duan Yu&apos;,19,&apos;M&apos;,4,NULL),(16,&apos;Xu Zhu&apos;,21,&apos;M&apos;,1,NULL),(17,&apos;Lin Chong&apos;,25,&apos;M&apos;,4,NULL),(18,&apos;Hua Rong&apos;,23,&apos;M&apos;,7,NULL),(19,&apos;Xue Baochai&apos;,18,&apos;F&apos;,6,NULL),(20,&apos;Diao Chan&apos;,19,&apos;F&apos;,7,NULL),(21,&apos;Huang Yueying&apos;,22,&apos;F&apos;,6,NULL),(22,&apos;Xiao Qiao&apos;,20,&apos;F&apos;,1,NULL),(23,&apos;Ma Chao&apos;,23,&apos;M&apos;,4,NULL),(24,&apos;Xu Xian&apos;,27,&apos;M&apos;,NULL,NULL),(25,&apos;Sun Dasheng&apos;,100,&apos;M&apos;,NULL,NULL); /*!40000 ALTER TABLE `students` ENABLE KEYS */; UNLOCK TABLES; -- -- Table structure for table `teachers` -- DROP TABLE IF EXISTS `teachers`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `teachers` ( `TID` smallint(5) unsigned NOT NULL AUTO_INCREMENT, `Name` varchar(100) NOT NULL, `Age` tinyint(3) unsigned NOT NULL, `Gender` enum(&apos;F&apos;,&apos;M&apos;) DEFAULT NULL, PRIMARY KEY (`TID`) ) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `teachers` -- LOCK TABLES `teachers` WRITE; /*!40000 ALTER TABLE `teachers` DISABLE KEYS */; INSERT INTO `teachers` VALUES (1,&apos;Song Jiang&apos;,45,&apos;M&apos;),(2,&apos;Zhang Sanfeng&apos;,94,&apos;M&apos;),(3,&apos;Miejue Shitai&apos;,77,&apos;F&apos;),(4,&apos;Lin Chaoying&apos;,93,&apos;F&apos;); /*!40000 ALTER TABLE `teachers` ENABLE KEYS */; UNLOCK TABLES; -- -- Table structure for table `toc` -- DROP TABLE IF EXISTS `toc`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `toc` ( `ID` int(10) unsigned NOT NULL AUTO_INCREMENT, `CourseID` smallint(5) unsigned DEFAULT NULL, `TID` smallint(5) unsigned DEFAULT NULL, PRIMARY KEY (`ID`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `toc` -- LOCK TABLES `toc` WRITE; /*!40000 ALTER TABLE `toc` DISABLE KEYS */; /*!40000 ALTER TABLE `toc` ENABLE KEYS */; UNLOCK TABLES; /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */; /*!40101 SET SQL_MODE=@OLD_SQL_MODE */; /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */; /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */; /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */; /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */; /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; -- Dump completed on 2013-09-03 [root@new ~]# mysql -uroot -S /mysql/3307/socket/mysql.sock &lt; hellodb_MyISAM.sql ##将这个脚本导入到Mysql 然后进入mysql，进入此脚本 MariaDB [hellodb]&gt; select * from students; +-------+---------------+-----+--------+---------+-----------+ | StuID | Name | Age | Gender | ClassID | TeacherID | +-------+---------------+-----+--------+---------+-----------+ | 1 | Shi Zhongyu | 22 | M | 2 | 3 | | 2 | Shi Potian | 22 | M | 1 | 7 | | 3 | Xie Yanke | 53 | M | 2 | 16 | | 4 | Ding Dian | 32 | M | 4 | 4 | | 5 | Yu Yutong | 26 | M | 3 | 1 | | 6 | Shi Qing | 46 | M | 5 | NULL | | 7 | Xi Ren | 19 | F | 3 | NULL | | 8 | Lin Daiyu | 17 | F | 7 | NULL | | 9 | Ren Yingying | 20 | F | 6 | NULL | | 10 | Yue Lingshan | 19 | F | 3 | NULL | | 11 | Yuan Chengzhi | 23 | M | 6 | NULL | | 12 | Wen Qingqing | 19 | F | 1 | NULL | | 13 | Tian Boguang | 33 | M | 2 | NULL | | 14 | Lu Wushuang | 17 | F | 3 | NULL | | 15 | Duan Yu | 19 | M | 4 | NULL | | 16 | Xu Zhu | 21 | M | 1 | NULL | | 17 | Lin Chong | 25 | M | 4 | NULL | | 18 | Hua Rong | 23 | M | 7 | NULL | | 19 | Xue Baochai | 18 | F | 6 | NULL | | 20 | Diao Chan | 19 | F | 7 | NULL | | 21 | Huang Yueying | 22 | F | 6 | NULL | | 22 | Xiao Qiao | 20 | F | 1 | NULL | | 23 | Ma Chao | 23 | M | 4 | NULL | | 24 | Xu Xian | 27 | M | NULL | NULL | | 25 | Sun Dasheng | 100 | M | NULL | NULL | +-------+---------------+-----+--------+---------+-----------+ 2MariaDB [hellodb]&gt; select * from students where gender &lt;&gt; &#39;m&#39;; ##性别不等于m 2MariaDB [hellodb]&gt; select * from students where gender != &#39;m&#39;; ##写法等价 +-------+---------------+-----+--------+---------+-----------+ | StuID | Name | Age | Gender | ClassID | TeacherID | +-------+---------------+-----+--------+---------+-----------+ | 7 | Xi Ren | 19 | F | 3 | NULL | | 8 | Lin Daiyu | 17 | F | 7 | NULL | | 9 | Ren Yingying | 20 | F | 6 | NULL | | 10 | Yue Lingshan | 19 | F | 3 | NULL | | 12 | Wen Qingqing | 19 | F | 1 | NULL | | 14 | Lu Wushuang | 17 | F | 3 | NULL | | 19 | Xue Baochai | 18 | F | 6 | NULL | | 20 | Diao Chan | 19 | F | 7 | NULL | | 21 | Huang Yueying | 22 | F | 6 | NULL | | 22 | Xiao Qiao | 20 | F | 1 | NULL | +-------+---------------+-----+--------+---------+-----------+ MariaDB [hellodb]&gt; select count(*) from students; ##查询表有几条记录 +----------+ | count(*) | +----------+ | 25 | +----------+ MariaDB [hellodb]&gt; select gender,count(*) from students group by gender; ##按性别分组计数 +--------+----------+ | gender | count(*) | +--------+----------+ | F | 10 | | M | 15 | +--------+----------+ MariaDB [hellodb]&gt; select gender,avg(age) from students group by gender; ##显示平均年龄 +--------+----------+ | gender | avg(age) | +--------+----------+ | F | 19.0000 | | M | 33.0000 | +--------+----------+ MariaDB [hellodb]&gt; select classid,gender,max(age) from students group by classid,gender; +---------+--------+----------+ ##统计age的最大值，后面的表示先区分classid，在区分gender | classid | gender | max(age) | +---------+--------+----------+ | NULL | M | 100 | | 1 | F | 20 | | 1 | M | 22 | | 2 | M | 53 | | 3 | F | 19 | | 3 | M | 26 | | 4 | M | 32 | | 5 | M | 46 | | 6 | F | 22 | | 6 | M | 23 | | 7 | F | 19 | | 7 | M | 23 | +---------+--------+----------+ MariaDB [hellodb]&gt; select gender,avg(age) from students group by gender having gender=&#39;m&#39;; +--------+----------+ | gender | avg(age) | ##只统计男生的平均年龄，这里是先分完组之后，从分完组的结果中过滤 +--------+----------+ | M | 33.0000 | +--------+----------+ MariaDB [hellodb]&gt; select gender,avg(age) from students where gender = &#39;m&#39; group by gender; +--------+----------+ | gender | avg(age) | ##虽然结果一样但是这里表示的是，先过滤完了以后再分组 +--------+----------+ | M | 33.0000 | +--------+----------+ MariaDB [hellodb]&gt; select classid,count(*) from students where age &gt; 30 group by classid having classid &gt;=3; +---------+----------+ | classid | count(*) | ##先过滤age大于30的然后再次过滤classid大于等于3的 +---------+----------+ | 4 | 1 | | 5 | 1 | +---------+----------+ MariaDB [hellodb]&gt; select * from students order by age; ##默认从小到大排列 MariaDB [hellodb]&gt; select * from students order by age desc; ##从大到小排列 MariaDB [hellodb]&gt; select * from students order by age desc limit 3; ##将age从小到大排列以后，只取前3 +-------+-------------+-----+--------+---------+-----------+ | StuID | Name | Age | Gender | ClassID | TeacherID | +-------+-------------+-----+--------+---------+-----------+ | 25 | Sun Dasheng | 100 | M | NULL | NULL | | 3 | Xie Yanke | 53 | M | 2 | 16 | | 6 | Shi Qing | 46 | M | 5 | NULL | +-------+-------------+-----+--------+---------+-----------+ MariaDB [hellodb]&gt; select * from students order by age asc limit 3,4; ##跳过前三取后续的四个 +-------+--------------+-----+--------+---------+-----------+ | StuID | Name | Age | Gender | ClassID | TeacherID | +-------+--------------+-----+--------+---------+-----------+ | 15 | Duan Yu | 19 | M | 4 | NULL | | 12 | Wen Qingqing | 19 | F | 1 | NULL | | 10 | Yue Lingshan | 19 | F | 3 | NULL | | 7 | Xi Ren | 19 | F | 3 | NULL | +-------+--------------+-----+--------+---------+-----------+ MariaDB [hellodb]&gt; select * from students order by -classid desc; ##将classid空字段放在最后 MariaDB [hellodb]&gt; select classid,avg(age) from students group by classid having avg(age) &gt; 30; ##以classid为分组依据，显示每组的平均年龄大于30的分组及平均年龄 +---------+----------+ | classid | avg(age) | +---------+----------+ | NULL | 63.5000 | | 2 | 36.0000 | | 5 | 46.0000 | +---------+----------+ 3 rows in set (0.00 sec) 多表操作MariaDB [hellodb]&gt; select * from teachers; ##这是另外一张表 +-----+---------------+-----+--------+ | TID | Name | Age | Gender | +-----+---------------+-----+--------+ | 1 | Song Jiang | 45 | M | | 2 | Zhang Sanfeng | 94 | M | | 3 | Miejue Shitai | 77 | F | | 4 | Lin Chaoying | 93 | F | +-----+---------------+-----+--------+ 4 rows in set (0.00 sec) MariaDB [hellodb]&gt; select stuid,name,age,gender from students ##合并显示 -&gt; union ##用union合并表的时候会默认去重(现在没有重复) -&gt; select * from teachers; +-------+---------------+-----+--------+ | stuid | name | age | gender | +-------+---------------+-----+--------+ | 1 | Shi Zhongyu | 22 | M | | 2 | Shi Potian | 22 | M | | 3 | Xie Yanke | 53 | M | | 4 | Ding Dian | 32 | M | | 5 | Yu Yutong | 26 | M | | 6 | Shi Qing | 46 | M | | 7 | Xi Ren | 19 | F | | 8 | Lin Daiyu | 17 | F | | 9 | Ren Yingying | 20 | F | | 10 | Yue Lingshan | 19 | F | | 11 | Yuan Chengzhi | 23 | M | | 12 | Wen Qingqing | 19 | F | | 13 | Tian Boguang | 33 | M | | 14 | Lu Wushuang | 17 | F | | 15 | Duan Yu | 19 | M | | 16 | Xu Zhu | 21 | M | | 17 | Lin Chong | 25 | M | | 18 | Hua Rong | 23 | M | | 19 | Xue Baochai | 18 | F | | 20 | Diao Chan | 19 | F | | 21 | Huang Yueying | 22 | F | | 22 | Xiao Qiao | 20 | F | | 23 | Ma Chao | 23 | M | | 24 | Xu Xian | 27 | M | | 25 | Sun Dasheng | 100 | M | | 1 | Song Jiang | 45 | M | | 2 | Zhang Sanfeng | 94 | M | | 3 | Miejue Shitai | 77 | F | | 4 | Lin Chaoying | 93 | F | +-------+---------------+-----+--------+ 29 rows in set (0.00 sec) MariaDB [hellodb]&gt; select stuid ,name from students union select tid,name from teachers; ##也可以只查看某些字段 MariaDB [db1]&gt; select * from t2; ##新表 +------+ | id | +------+ | 1 | | 2 | | 2 | +------+ MariaDB [db1]&gt; select * from t2 union select * from t2; ##这里是自己给自己去重 +------+ | id | +------+ | 1 | | 2 | +------+ MariaDB [db1]&gt; select distinct * from t2; ##也是去重 +------+ | id | +------+ | 1 | | 2 | +------+ 横向合并以上介绍的都是竖向合并，现在横向合并，也就是交叉连接，cross jion。当两个表行数不一致时一张表中的所有内容(一列)就会和另一张表中的内容(一列)全部组合一遍这里显示的就是当两张表合并在一起的输出效果，一共125行(其余的已省略) ##students表25条记录*teachers表5条记录=125条记录。但是这种查看一般都没用，太混乱 MariaDB [hellodb]&gt; select * from students cross join teachers; +-------+---------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ | StuID | Name | Age | Gender | ClassID | TeacherID | TID | Name | Age | Gender | +-------+---------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ | 1 | Shi Zhongyu | 22 | M | 2 | 3 | 1 | Song Jiang | 45 | M | | 1 | Shi Zhongyu | 22 | M | 2 | 3 | 2 | Zhang Sanfeng | 94 | M | | 1 | Shi Zhongyu | 22 | M | 2 | 3 | 3 | Miejue Shitai | 77 | F | | 1 | Shi Zhongyu | 22 | M | 2 | 3 | 4 | Lin Chaoying | 93 | F | | 1 | Shi Zhongyu | 22 | M | 2 | 3 | 5 | Yu yutong | 26 | M | | 2 | Shi Potian | 22 | M | 1 | 7 | 1 | Song Jiang | 45 | M | | 2 | Shi Potian | 22 | M | 1 | 7 | 2 | Zhang Sanfeng | 94 | M | | 2 | Shi Potian | 22 | M | 1 | 7 | 3 | Miejue Shitai | 77 | F | | 2 | Shi Potian | 22 | M | 1 | 7 | 4 | Lin Chaoying | 93 | F | | 2 | Shi Potian | 22 | M | 1 | 7 | 5 | Yu yutong | 26 | M | | 3 | Xie Yanke | 53 | M | 2 | 16 | 1 | Song Jiang | 45 | M | | 3 | Xie Yanke | 53 | M | 2 | 16 | 2 | Zhang Sanfeng | 94 | M | | 3 | Xie Yanke | 53 | M | 2 | 16 | 3 | Miejue Shitai | 77 | F | | 3 | Xie Yanke | 53 | M | 2 | 16 | 4 | Lin Chaoying | 93 | F | | 3 | Xie Yanke | 53 | M | 2 | 16 | 5 | Yu yutong | 26 | M | +-------+---------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ ...... 125 rows in set (0.01 sec) 内连接将两张表横向合并在一起 这里表示只要两个表的ID相同就可以了(这种叫内连接) MariaDB [hellodb]&gt; select * from students,teachers where students.teacherid=teachers.tid; +-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ | StuID | Name | Age | Gender | ClassID | TeacherID | TID | Name | Age | Gender | +-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ | 5 | Yu Yutong | 26 | M | 3 | 1 | 1 | Song Jiang | 45 | M | | 1 | Shi Zhongyu | 22 | M | 2 | 3 | 3 | Miejue Shitai | 77 | F | | 4 | Ding Dian | 32 | M | 4 | 4 | 4 | Lin Chaoying | 93 | F | +-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ MariaDB [hellodb]&gt; update students set teacherid=1 where stuid=25; ##这里改了students这张表 | 25 | Sun Dasheng | 100 | M | NULL | 1 | 那么这两张表就增加了一组对应的行了 MariaDB [hellodb]&gt; select * from students,teachers where students.teacherid=teachers.tid; +-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ | StuID | Name | Age | Gender | ClassID | TeacherID | TID | Name | Age | Gender | +-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ | 5 | Yu Yutong | 26 | M | 3 | 1 | 1 | Song Jiang | 45 | M | | 25 | Sun Dasheng | 100 | M | NULL | 1 | 1 | Song Jiang | 45 | M | | 1 | Shi Zhongyu | 22 | M | 2 | 3 | 3 | Miejue Shitai | 77 | F | | 4 | Ding Dian | 32 | M | 4 | 4 | 4 | Lin Chaoying | 93 | F | +-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ 上面这种写法比较老(不推荐写) MariaDB [hellodb]&gt; select * from students inner join teachers on students.teacherid=teachers.tid; +-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ | StuID | Name | Age | Gender | ClassID | TeacherID | TID | Name | Age | Gender | +-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ | 5 | Yu Yutong | 26 | M | 3 | 1 | 1 | Song Jiang | 45 | M | | 25 | Sun Dasheng | 100 | M | NULL | 1 | 1 | Song Jiang | 45 | M | | 1 | Shi Zhongyu | 22 | M | 2 | 3 | 3 | Miejue Shitai | 77 | F | | 4 | Ding Dian | 32 | M | 4 | 4 | 4 | Lin Chaoying | 93 | F | +-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+ select stuid,students.name as sName,tid,teachers.name as tName from students inner join teachers on students.teacherid=teachers.tid; select stuid,s.name as student_name,tid,t.name teacher_name from students as s inner join teachers t on s.teacherid=t.tid; ##这里是给表起别名(一旦起了别名以后后面就必须用别名) +-------+-------------+-----+---------------+ | stuid | sName | tid | tName | +-------+-------------+-----+---------------+ | 5 | Yu Yutong | 1 | Song Jiang | | 25 | Sun Dasheng | 1 | Song Jiang | | 1 | Shi Zhongyu | 3 | Miejue Shitai | | 4 | Ding Dian | 4 | Lin Chaoying | +-------+-------------+-----+---------------+ 左外连接:左边全要，右边只要和左边相同的 MariaDB [hellodb]&gt; select * from students as s left outer join teachers as t on s.teacherid=t.tid; 右外连接:右边全要，左边只要和右边相同的 MariaDB [hellodb]&gt; select * from students as s right outer join teachers as t on s.teacherid=t.tid; 两张表，去除右边表和 右边表与左边表相同的内容 MariaDB [hellodb]&gt; select * from students as s left outer join teachers t on s.teacherid=t.tid where t.tid is null; 两张表，去除左边表和 左边表与右边表相同的内容 MariaDB [hellodb]&gt; select * from students as s right outer join teachers t on s.teacherid=t.tid where s.teacherid is null; ##查询teacher表里面age大于students表里面的age的平均数 子查询:MariaDB [hellodb]&gt; select * from teachers where age &gt; (select avg(age) from students); 这是将两张表合并在一起，全部显示出来，并且合并相同的 MariaDB [hellodb]&gt; select * from students as s left outer join teachers t on s.teacherid=t.tid -&gt; union -&gt; select * from students as s right outer join teachers t on s.teacherid=t.tid; 最后这里是取两边的部分，去掉交集 select * from (select stuid,s.name as student_name,s.age as student_age,s.gender as student_gender,classid,teacherid,tid,t.name as teacher_name,t.age as teacher_age,t.gender as teacher_gender from students as s left outer join teachers t on s.teacherid=t.tid union select stuid,s.name,s.age,s.gender,classid,teacherid,tid,t.name,t.age,t.gender from students as s right outer join teachers t on s.teacherid=t.tid) as f where f.teacherid is null or f.tid is null; 自查询MariaDB [hellodb]&gt; select * from emp; +------+-----------+----------+ | id | name | leaderid | +------+-----------+----------+ | 1 | 马永亮 | NULL | | 2 | 张冠宇 | 1 | | 3 | wan | 2 | | 4 | yan | 3 | +------+-----------+----------+ ##只有这一张表，现在查看他们的名字和他们的上司名，这里用到的是交集-内连接。这里把它们当成了两个表来看。 MariaDB [hellodb]&gt; select a.name,b.name from emp as a inner join emp as b on a.leaderid=b.id; +-----------+-----------+ | name | name | +-----------+-----------+ | 张冠宇 | 马永亮 | | wan | 张冠宇 | | yan | wan | +-----------+-----------+ ##如果需要都保存，那就用到了左外连接 MariaDB [hellodb]&gt; select a.name,b.name from emp as a left join emp as b on a.leaderid=b.id; +-----------+-----------+ | name | name | +-----------+-----------+ | 张冠宇 | 马永亮 | | wan | 张冠宇 | | yan | wan | | 马永亮 | NULL | +-----------+-----------+ 需要查看学生姓名，考试科目，考试成绩 这里有三张表，效果在最后 courses scores | students MariaDB [hellodb]&gt; select * from courses; +----------+----------------+ | CourseID | Course | +----------+----------------+ | 1 | Hamo Gong | | 2 | Kuihua Baodian | | 3 | Jinshe Jianfa | | 4 | Taiji Quan | | 5 | Daiyu Zanghua | | 6 | Weituo Zhang | | 7 | Dagou Bangfa | +----------+----------------+ 7 rows in set (0.00 sec) MariaDB [hellodb]&gt; select * from scores; +----+-------+----------+-------+ | ID | StuID | CourseID | Score | +----+-------+----------+-------+ | 1 | 1 | 2 | 77 | | 2 | 1 | 6 | 93 | | 3 | 2 | 2 | 47 | | 4 | 2 | 5 | 97 | | 5 | 3 | 2 | 88 | | 6 | 3 | 6 | 75 | | 7 | 4 | 5 | 71 | | 8 | 4 | 2 | 89 | | 9 | 5 | 1 | 39 | | 10 | 5 | 7 | 63 | | 11 | 6 | 1 | 96 | | 12 | 7 | 1 | 86 | | 13 | 7 | 7 | 83 | | 14 | 8 | 4 | 57 | | 15 | 8 | 3 | 93 | +----+-------+----------+-------+ MariaDB [hellodb]&gt; select st.name,sc.courseid,sc.score from students as st inner join scores as sc on st.stuid=sc.id; 学生姓名 课程编号 考试成绩 +---------------+----------+-------+ | name | courseid | score | +---------------+----------+-------+ | Shi Zhongyu | 2 | 77 | | Shi Potian | 6 | 93 | | Xie Yanke | 2 | 47 | | Ding Dian | 5 | 97 | | Yu Yutong | 2 | 88 | | Shi Qing | 6 | 75 | | Xi Ren | 5 | 71 | | Lin Daiyu | 2 | 89 | | Ren Yingying | 1 | 39 | | Yue Lingshan | 7 | 63 | | Yuan Chengzhi | 1 | 96 | | Wen Qingqing | 1 | 86 | | Tian Boguang | 7 | 83 | | Lu Wushuang | 4 | 57 | | Duan Yu | 3 | 93 | +---------------+----------+-------+ MariaDB [hellodb]&gt; select st.name,co.Course,sc.score from students as st inner join scores as sc on st.stuid=sc.id inner join courses as co on sc.courseid=co.CourseID; +---------------+----------------+-------+ | name | Course | score | +---------------+----------------+-------+ | Shi Zhongyu | Kuihua Baodian | 77 | | Shi Potian | Weituo Zhang | 93 | | Xie Yanke | Kuihua Baodian | 47 | | Ding Dian | Daiyu Zanghua | 97 | | Yu Yutong | Kuihua Baodian | 88 | | Shi Qing | Weituo Zhang | 75 | | Xi Ren | Daiyu Zanghua | 71 | | Lin Daiyu | Kuihua Baodian | 89 | | Ren Yingying | Hamo Gong | 39 | | Yue Lingshan | Dagou Bangfa | 63 | | Yuan Chengzhi | Hamo Gong | 96 | | Wen Qingqing | Hamo Gong | 86 | | Tian Boguang | Dagou Bangfa | 83 | | Lu Wushuang | Taiji Quan | 57 | | Duan Yu | Jinshe Jianfa | 93 | +---------------+----------------+-------+ mysql的资源管理视图中的数据事实上存储于“基表”中，因此，其修改操作也会针对基表实现；其修改操作受基表限制视图:view,虚表。保存有实表的查询结果创建方法: MariaDB [hellodb]&gt; insert v_old_students values(27,&#39;li&#39;,20); ##创建视图 Query OK, 1 row affected (0.00 sec) MariaDB [hellodb]&gt; select * from v_old_students; ##查看视图 +-------+-------------+-----+ | stuid | name | age | +-------+-------------+-----+ | 3 | Xie Yanke | 53 | | 25 | Sun Dasheng | 100 | +-------+-------------+-----+ mysql 用户和权限管理mysql需要远程必须单独建立账号。 use mysql ##进入mysql库 create user test@&#39;192.168.175.%&#39; identified by &#39;centos&#39;; ##建立远程登录的账户。&#39;centos&#39;为密码 select user,host from user; ##查看建立的账号 mysql -utest -pcentos -h192.168.175.22(这里是mysql所在库的机器ip) MariaDB [mysql]&gt; select user,host from user; +------+---------------------+ | user | host | +------+---------------------+ | root | 127.0.0.1 | | test | 192.168.175.% | | root | ::1 | | root | centos7.localdomain | | | localhost | | root | localhost | +------+---------------------+ MariaDB [mysql]&gt; drop user &#39;&#39;@&#39;localhost&#39;； ##删除某个用户 set password for &#39;user&#39;@&#39;host&#39;=password(&#39;password字符串&#39;); ##修改密码 用户重命名：RENAME USER RENAME USER old_user_name TO new_user_name; mysql&gt;UPDATE mysql.user SET password=PASSWORD(&#39;password&#39;) WHERE clause; ##修改密码 此方法需要执行下面指令才能生效： mysql&gt; FLUSH PRIVILEGES; #mysqladmin -u root -poldpass password &#39;newpass&#39; update user set password=password(&#39;centos&#39;) where user=&#39;root&#39;; ##批量修改root账户密码 MariaDB [mysql]&gt; select user,host,password from user; +------+---------------------+-------------------------------------------+ | user | host | password | +------+---------------------+-------------------------------------------+ | root | localhost | *128977E278358FF80A246B5046F51043A2B1FCED | | root | centos7.localdomain | *128977E278358FF80A246B5046F51043A2B1FCED | | root | 127.0.0.1 | *128977E278358FF80A246B5046F51043A2B1FCED | | root | ::1 | *128977E278358FF80A246B5046F51043A2B1FCED | | test | 192.168.175.% | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | +------+---------------------+-------------------------------------------+ MariaDB [mysql]&gt; flush privileges; ##然后执行这句命令，密码生效 ##使用上面update报错解决方式: showvariables like &#39;sql_safe%&#39;; 执行SQL: set sql_safe_updates=0; 或 set sql_safe_updates=off; 忘记口令如何破解vim /etc/my.cnf skip-grant-tables ##在这个文件中添加这一行:取消授权操作 systemctl restart mariadb ##重启服务 mysql ##已经可以进入并且不用输口令 update mysql.user set password=password(&#39;123456&#39;) where user=&#39;root&#39;; ##再把密码改回来 再去/etc/my.cnf中，将刚刚添加的那一行注释掉。然后再次进入mysql -p123456 给用户加权限创建的用户，远程登录的用户，是没有太多的权限的。这里是先创建账号后加的权限 ##all:所有权限，hellodb:所有表 给test用户(此时test用户就可以show查看和use进入到这张表也可以增删改查) MariaDB [hellodb]&gt; grant all on hellodb.* to test@&#39;192.168.175.%&#39;; 授权和创建账号一起MariaDB [hellodb]&gt; grant select(name,age) on hellodb.students to test2@&#39;192.168.175.%&#39; identified by &#39;centos&#39;; ##创建账号test2,指定登录的网段192.168.175.0，账号密码:centos。只允许查询hellodb库的students表里面的name和age字段。 MariaDB [hellodb]&gt; show grants for test2@&#39;192.168.175.%&#39;; ##查看某个账号的权限 MariaDB [hellodb]&gt; grant all on *.* to test3@&#39;192.168.175.%&#39; identified by &#39;centos&#39;; ##给所有权限并创建test3 MariaDB [hellodb]&gt; revoke select on *.* from test3@&#39;192.168.175.%&#39;; ##删除他的select权限，也就是只能曾删改，不能查 MyISAM引擎特点不支持事务表级锁定读写相互阻塞，写入不能读，读时不能写只缓存索引不支持外键约束不支持聚簇索引读取数据较快，占用资源较少不支持MVCC（多版本并发控制机制）高并发崩溃恢复性较差MySQL5.5.5前默认的数据库引擎存储引擎MyISAM存储引擎适用场景只读（或者写较少）、表较小（可以接受长时间进行修复操作） MyISAM引擎文件tbl_name.frm 表格式定义tbl_name.MYD 数据文件tbl_name.MYI 索引文件 InnoDB引擎特点行级锁支持事务，适合处理大量短期事务读写阻塞与事务隔离级别相关可缓存数据和索引支持聚簇索引崩溃恢复性更好支持MVCC高并发从MySQL5.5后支持全文索引从MySQL5.5.5开始为默认的数据库引擎 查看库里所有表的存储引擎:show table status from hellodb\G default-storage-engine=innodb 在my.cnf中添加，之后再次建立表默认就会用innodb了 进入数据库后:show enginess 查看 InnoDB数据库文件所有InnoDB表的数据和索引放置于同一个表空间中表空间文件：datadir定义的目录下数据文件：ibddata1, ibddata2, …每个表单独使用一个表空间存储表的数据和索引启用：innodb_file_per_table=ON参看：https://mariadb.com/kb/en/library/xtradbinnodb-server-system-variables/#innodb_file_per_tableON (&gt;= MariaDB 5.5)两类文件放在数据库独立目录中数据文件(存储数据和索引)：tb_name.ibd表格式定义：tb_name.frm 查看mysql支持的存储引擎show engines; 查看当前默认的存储引擎 show variables like &#39;%storage_engine%&#39;; 设置默认的存储引擎 vim /etc/my.conf [mysqld] default_storage_engine= InnoDB 管理存储引擎查看库中所有表使用的存储引擎 show table status from db_name; 查看库中指定表的存储引擎show table status like &#39; tb_name &#39;; show create table tb_name; 设置表的存储引擎： CREATE TABLE tb_name(... ) ENGINE=InnoDB; ALTER TABLE tb_name ENGINE=InnoDB; MySQL中的系统数据库mysql数据库是mysql的核心数据库，类似于Sql Server中的master库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息performance_schema数据库MySQL 5.5开始新增的数据库，主要用于收集数据库服务器性能参数,库里表的存储引擎均为PERFORMANCE_SCHEMA，用户不能创建存储引擎为PERFORMANCE_SCHEMA的表information_schema数据库MySQL 5.0之后产生的，一个虚拟数据库，物理上并不存在information_schema数据库类似与“数据字典”，提供了访问数据库元数据的方式，即数据的数据。比如数据库名或表名，列类型，访问权限（更加细化的访问方式） 服务器配置mysqld选项，服务器系统变量和服务器状态变量https://dev.mysql.com/doc/refman/8.0/en/server-option-variable-reference.htmlhttps://mariadb.com/kb/en/library/full-list-of-mariadb-options-system-and-status-variables/注意：其中有些参数支持运行时修改，会立即生效；有些参数不支持，且只能通过修改配置文件，并重启服务器程序生效；有些参数作用域是全局的，且不可改变；有些可以为每个用户提供单独（会话）的设置 服务器配置获取mysqld的可用选项列表： mysqld –help –verbosemysqld –print-defaults 获取默认设置设置服务器选项方法：在命令行中设置shell&gt; ./mysqld_safe –skip-name-resolve=1在配置文件my.cnf中设置 skip_name_resolve=1 服务器系统变量：分全局和会话两种获取系统变量mysql&gt; SHOW GLOBAL VARIABLES;mysql&gt; SHOW [SESSION] VARIABLES;mysql&gt; SELECT @@VARIABLES;修改服务器变量的值： mysql&gt; help SET修改全局变量：仅对修改后新创建的会话有效；对已经建立的会话无效 mysql&gt; SET GLOBAL system_var_name=value;mysql&gt; SET @@global.system_var_name=value;修改会话变量：mysql&gt; SET [SESSION] system_var_name=value;mysql&gt; SET @@[session.]system_var_name=value; 服务器状态变量：分全局和会话两种状态变量（只读）：用于保存mysqld运行中的统计数据的变量，不可更改mysql&gt; SHOW GLOBAL STATUS;mysql&gt; SHOW [SESSION] STATUS; 服务器变量SQL_MODE常见MODE: NO_AUTO_CREATE_USER 禁止GRANT创建密码为空的用户 NO_ZERO_DATE 在严格模式，不允许使用‘0000-00-00’的时间 ONLY_FULL_GROUP_BY 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么将认为这个SQL是不合法的 NO_BACKSLASH_ESCAPES 反斜杠“\”作为普通字符而非转义字符 PIPES_AS_CONCAT 将&quot;||&quot;视为连接操作符而非“或运算符 索引索引：是特殊数据结构，定义在查找时作为查找条件的字段，在MySQL又称为键key，索引通过存储引擎实现优点：索引可以降低服务需要扫描的数据量，减少了IO次数索引可以帮助服务器避免排序和使用临时表索引可以帮助将随机I/O转为顺序I/O缺点：占用额外空间，影响插入速度 创建索引: 索引名 指定哪个表，指定表中的字段(前多少个字符) MariaDB [hellodb]&gt; create index idx_name on testlog(name(10)); 查看索引: show indexes from testlog\G 查询，使用了索引 MariaDB [hellodb]&gt; explain select * from testlog where name=&#39;wang10000&#39;; [16:11:20+------+-------------+---------+------+---------------+----------+---------+-------+------+-----------------------+ [16:11:20| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | [16:11:20+------+-------------+---------+------+---------------+----------+---------+-------+------+-----------------------+ [16:11:20| 1 | SIMPLE | testlog | ref | idx_name | idx_name | 31 | const | 4 | Using index condition | [16:11:20+------+-------------+---------+------+---------------+----------+---------+-------+------+-----------------------+ [16:11:201 row in set (0.00 sec) 删除索引 MariaDB [hellodb]&gt; drop index idx_name on testlog; 创建复合索引 create index idx_name_age on testlog(name,age); 查看 show indexes from testlog\G 查看索引的使用 set global userstat=1; show index_statistics; 如果之前索引使用过，这里可以查看到，用不到的可以删掉 show indexes studnets; 查看表的所有的索引 锁读锁:都不能改写锁:自己能读，可以写。别人不能读lock tables students read; 加读锁unlock talbes； 解锁 事务Transactions：一组原子性的SQL语句，或一个独立工作单元事务日志：记录事务信息，实现undo,redo等故障恢复功能ACID特性：A：atomicity原子性；整个事务中的所有操作要么全部成功执行，要么全部失败后回滚C：consistency一致性；数据库总是从一个一致性状态转换为另一个一致性状态I：Isolation隔离性；一个事务所做出的操作在提交之前，是不能为其它事务所见；隔离有多种隔离级别，实现并发D：durability持久性；一旦事务提交，其所做的修改会永久保存于数据库中 启动事务：BEGINBEGIN WORKSTART TRANSACTION结束事务：COMMIT：提交ROLLBACK: 回滚这里也就是说，在数据库里面begin;以后所做的操作都不会被写入，但是当前可以查看到所做的操作。当所做的操作没有问题以后，就可以commit提交写入。（适合增删改） 自动提交：set autocommit={1|0},默认为1，为0时设为非自动.就是修改数据库文件以后，如果设置的是非自动，数据不会自动提交。但是可以查看到撤销:rollback; 提交:commit; hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Six]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[自动化服务 自动安装操作系统自动安装手动指定安装源linux askmethod ip=192.168.152.150 netmask=255.255.255.0boot&gt; linux text 纯文本安装，以字符界面安装依据某模板修改并生成新配置以图形化方式配置可使用创建工具：system-config-kickstart检查ks文件的语法错误 ksvalidator ks.cfg 文件式安装---------------------------------centos6最后生成的ks.cfg文件--------------------------------- [root@centos6 ksdir6]# cat ks6_min.cfg #platform=x86, AMD64, or Intel EM64T #version=DEVEL # Firewall configuration firewall --disabled # Install OS instead of upgrade install # Use network installation url --url=&quot;http://192.168.152.131/centos/6/os/x86_64/&quot; # Root password rootpw --plaintext 123456 # System authorization information auth --useshadow --passalgo=sha512 # Use text mode install text # System keyboard keyboard us # System language lang en_US # SELinux configuration selinux --disabled # Do not configure the X Window System skipx # Installation logging level logging --level=info # Reboot after installation reboot # System timezone timezone Asia/Shanghai # Network information network --bootproto=dhcp --device=eth0 --onboot=on # System bootloader configuration bootloader --append=&quot;max_loop=100 selinux=0&quot; --location=mbr # Clear the Master Boot Record zerombr # Partition clearing information clearpart --all --initlabel # Disk partitioning information part /boot --fstype=&quot;ext4&quot; --size=500 part swap --fstype=&quot;swap&quot; --size=1024 part /home --fstype=&quot;ext4&quot; --size=2000 part / --fstype=&quot;ext4&quot; --size=5000 %post mkdir /etc/yum.repos.d/bak mv /etc/yum.repos.d/* /etc/yum.repos.d/bak cat &gt; /etc/yum.repos.d/base.repo &lt;&lt;EOF [base] baseurl=http://192.168.152.131/centos/6/os/x86_64 gpgcheck=0 EOF useradd pan echo centos | passwd --stdin 123456 mkdir /root/.ssh cat &gt; /root/.ssh/authorized_keys &lt;&lt;EOF ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDM0xVhClWXlM3OYiTCKpZ0pA//eDpA+OFdtjRhMVKtgc6N0YeAPn9exRIAj3vHjlhuoexwb8QnY3DxKTQGv2p9nGjKRXY1G8RzRGo5WRv0xW/sfnpsDoc2hbICS/rZ6ghAuiWXn33H1Hv7m7Q8myghg8m5RuAagKTKu2AX0bGYvYewk/08K9bZ5b2S24Y3SBIQtAOXrvUJml0WDo6Ay0zmyttMtvv0hVE0WnX21Wm0AKcH6gvvwIJ990QuElNunLni2M5cOJm9kMkU6krCf9xYHs4zgwfzXbsxdFBznrEJu5koiZHvT7WKiD7hMl06LMFDQT/GGFnJmkxvAcSLfZKF root@centos7.localdomain EOF chmod 700 /root/.ssh/ chmod 600 /root/.ssh/authorized_keys %end %packages @base %end 新建一个虚拟机磁盘选择目录以后，打开虚拟机按escboot&gt; linux ks=http://192.168.152.131/ksdir6/ks6_min.cfg ip=192.168.152.150 netmask=255.255.255.0 注意：centos7使用这条命令时在Package Selection选项里面安装包无法显示，需要去更改yum配置文件,将[base]更改为[development].再次运行此命令就可看到安装包了 安装图形化桌面:yum groupinstll &quot;desktop&quot; 制作光盘文件-----------------------------------------创建目录文件----------------------------------------------- mkdir /data/iso cp -r /misc/cd/isolinux/ /data/iso cp /var/www/html/ksdir6/ks6_min.cfg /data/iso ##拷贝应答文件到此目录 mv ks6_min.cfg ksdir/ [root@centos6 iso]# tree /data/iso/ /data/iso/ ├── isolinux │ ├── boot.cat │ ├── boot.msg │ ├── grub.conf │ ├── initrd.img │ ├── isolinux.bin │ ├── isolinux.cfg │ ├── memtest │ ├── splash.jpg │ ├── TRANS.TBL │ ├── vesamenu.c32 │ └── vmlinuz └── ksdir └── ks6_min.cfg 2 directories, 12 files -----------------------------------------修改启动菜单-------------------------------------------- [root@centos6 isolinux]# cat isolinux.cfg ##修改启动菜单 default vesamenu.c32 #prompt 1 timeout 600 display boot.msg menu background splash.jpg menu title Welcome to CentOS 6.10! menu color border 0 #ffffffff #00000000 menu color sel 7 #ffffffff #ff000000 menu color title 0 #ffffffff #00000000 menu color tabmsg 0 #ffffffff #00000000 menu color unsel 0 #ffffffff #00000000 menu color hotsel 0 #ff000000 #ffffffff menu color hotkey 7 #ffffffff #ff000000 menu color scrollbar 0 #ffffffff #00000000 label auto menu label ^Auto i nstall an system menu default kernel vmlinuz append initrd=initrd.img ks=cdrom:/ksdir/ks6_min.cfg ##应答文件 label manual menu label ^Manual install an system kernel vmlinuz append initrd=initrd.img repo=http://http://192.168.152.131/centos/6/os/x86_64/ label local menu label Boot from ^local drive localboot 0xffff ##将这个文件做成.iso文件 [root@centos6 ~]# mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V &quot;Centos 6.10 x86_64 boot&quot; -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/boot.iso /data/iso 然后将生成的boot.iso文件拷贝到windows电脑，新建虚拟机，选择这个iso文件，在bios调至第一启动项，然后进入开机启动项选择 同步分区表 dd数据以后分区表不同步的解决方法 partx -d --nr 1-3 /dev/sdb DHCP服务subnet 192.168.175.0 netmask 255.255.255.0 { range 192.168.175.10 192.168.175.200; option routers 192.168.175.1; ##自动获取网关 option domain-name-servers 8.8.8.8,1.1.1.1; ##自动获取DNS next-server 192.168.175.128; filename &quot;pxelinux.0&quot;; host dbserver { ##这里是注释 hardware ethernet 00:0C:29:89:50:C2; ##对方机器的mac地址 fixed-address 192.168.175.10; ##想要把这里ip固定的给定到对应的mac地址的机器上 filename: 指明引导文件名称.next-server：提供引导文件的服务器IP地址检查语法: service dhcpd configtest 查询服务配置目录[root@centos7 ~]# rpm -ql tftp-server PXE工作原理Client向PXE Server上的DHCP发送IP地址请求消息，DHCP检测Client是否合法（主要是检测Client的网卡MAC地址），如果合法则返回Client的IP地址，同时将启动文件pxelinux.0的位置信息一并传送给ClientClient向PXE Server上的TFTP发送获取pxelinux.0请求消息，TFTP接收到消息之后再向Client发送pxelinux.0大小信息，试探Client是否满意，当TFTP收到Client发回的同意大小信息之后，正式向Client发送pxelinux.0Client执行接收到的pxelinux.0文件Client向TFTP Server发送针对本机的配置信息文件（在TFTP 服务的pxelinux.cfg目录下），TFTP将配置文件发回Client，继而Client根据配置文件执行后续操作。Client向TFTP发送Linux内核请求信息，TFTP接收到消息之后将内核文件发送给ClientClient向TFTP发送根文件请求信息，TFTP接收到消息之后返回Linux根文件系统Client启动Linux内核Client下载安装源文件，读取自动化安装脚本 1.安装软件包 httpd(实现yum源仓库) tftp-server dhcp 2.搭建yum源 [root@centos7 html]# tree /var/www/html/ /var/www/html/ ├── centos │ ├── 6 │ │ └── os │ │ └── x86_64 │ └── 7 │ └── os │ └── x86_64 └── index.html mount /dev/sr0 /var/www/html/centos/7/os/x86_64 3.应答文件 [root@centos7 ~]# mkdir /var/www/html/ksdir/ [root@centos7 ~]# cp anaconda-ks.cfg /var/www/html/ksdir/ks7-desktop.cfg --------------------------修改后的应答文件-------------------------- 注意最后给文件加上访问权限 #version=DEVEL # System authorization information auth --enableshadow --passalgo=sha512 # Use CDROM installation media url --url=http://192.168.175.128/centos/7/os/x86_64/ # Use graphical install text # Run the Setup Agent on first boot firstboot --enable ignoredisk --only-use=sda # Keyboard layouts keyboard --vckeymap=us --xlayouts=&apos;us&apos; # System language lang en_US.UTF-8 # Network information network --bootproto=dhcp --device=ens33 --onboot=off --ipv6=auto --no-activate network --hostname=centos7.PXE # Root password rootpw --iscrypted $6$PprrT2YGti4K0Szn$AMuVoyb0l7Jr.7zVsUFNfyr87PH0K7xtJIKntFJHFGOzNjdOZiAkrIHTsfKok0YeggfpoJWwvIjOt3WUprpjN0 firewall --disabled selinux --disabled # System services services --disabled=&quot;chronyd&quot; # System timezone timezone Asia/Shanghai --isUtc --nontp user --name=pan --password=$6$bqRXYA2Vpw3p4BBx$Dnl62ZR6r/vJnYPE1g.AmMVnhDPhN0IHYjsSWdJdfnolY73W1WzkBlnSwwTyNTPtWGn3bQHcXNEVWp3vl5.A21 --iscrypted --gecos=&quot;pan&quot; # X Window System configuration information # System bootloader configuration bootloader --append=&quot; crashkernel=auto&quot; --location=mbr --boot-drive=sda # Partition clearing information clearpart --all --initlabel zerombr reboot # Disk partitoning information part /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=1024 part swap --fstype=&quot;swap&quot; --ondisk=sda --size=4096 part / --fstype=&quot;xfs&quot; --ondisk=sda --seze=51200 part /data --fstype=&quot;xfs&quot; --ondisk=sda --size=30720 %packages @core %end -------------------------------启动DHCP服务-------------------------- cp /usr/share/doc/dhcp-4.2.5/dhcp.conf.example /etc/dhcpd/dhcpd.conf 4.启动dhcp服务 [root@centos7 ~]# cat /etc/dhcp/dhcpd.conf # dhcpd.conf # # Sample configuration file for ISC dhcpd # # option definitions common to all supported networks... option domain-name &quot;example.org&quot;; option domain-name-servers ns1.example.org, ns2.example.org; default-lease-time 600; max-lease-time 7200; # Use this to enble / disable dynamic dns updates globally. #ddns-update-style none; # If this DHCP server is the official DHCP server for the local # network, the authoritative directive should be uncommented. #authoritative; # Use this to send dhcp log messages to a different log file (you also # have to hack syslog.conf to complete the redirection). log-facility local7; # No service will be given on this subnet, but declaring it helps the # DHCP server to understand the network topology. subnet 192.168.175.0 netmask 255.255.255.0 { range 192.168.175.10 192.168.175.200; option routers 192.168.175.1; ##自动获取网关 option domain-name-servers 8.8.8.8,1.1.1.1; ##自动获取DNS next-server 192.168.175.128; filename &quot;pxelinux.0&quot;; } # This is a very basic subnet declaration. subnet 10.254.239.0 netmask 255.255.255.224 { range 10.254.239.10 10.254.239.20; option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org; } # This declaration allows BOOTP clients to get dynamic addresses, # which we don&apos;t really recommend. subnet 10.254.239.32 netmask 255.255.255.224 { range dynamic-bootp 10.254.239.40 10.254.239.60; option broadcast-address 10.254.239.31; option routers rtr-239-32-1.example.org; } # A slightly different configuration for an internal subnet. subnet 10.5.5.0 netmask 255.255.255.224 { range 10.5.5.26 10.5.5.30; option domain-name-servers ns1.internal.example.org; option domain-name &quot;internal.example.org&quot;; option routers 10.5.5.1; option broadcast-address 10.5.5.31; default-lease-time 600; max-lease-time 7200; } # Hosts which require special configuration options can be listed in # host statements. If no address is specified, the address will be # allocated dynamically (if possible), but the host-specific information # will still come from the host declaration. host dbserver { ##这里是注释 hardware ethernet 00:0C:29:89:50:C2; ##对方机器的mac地址 fixed-address 192.168.175.10; ##想要把这里ip固定的给定到对应的mac地址的机器上 } # Fixed IP addresses can also be specified for hosts. These addresses # should not also be listed as being available for dynamic assignment. # Hosts for which fixed IP addresses have been specified can boot using # BOOTP or DHCP. Hosts for which no fixed address is specified can only # be booted with DHCP, unless there is an address range on the subnet # to which a BOOTP client is connected which has the dynamic-bootp flag # set. host fantasia { hardware ethernet 08:00:07:26:c0:a5; fixed-address fantasia.fugue.com; } # You can declare a class of clients and then do address allocation # based on that. The example below shows a case where all clients # in a certain class get addresses on the 10.17.224/24 subnet, and all # other clients get addresses on the 10.0.29/24 subnet. class &quot;foo&quot; { match if substring (option vendor-class-identifier, 0, 4) = &quot;SUNW&quot;; } shared-network 224-29 { subnet 10.17.224.0 netmask 255.255.255.0 { option routers rtr-224.example.org; } subnet 10.0.29.0 netmask 255.255.255.0 { option routers rtr-29.example.org; } pool { allow members of &quot;foo&quot;; range 10.17.224.10 10.17.224.250; } pool { deny members of &quot;foo&quot;; range 10.0.29.10 10.0.29.230; } } [root@centos7 ~]# 5.安装syslinux rpm -ql syslinux 查询到有一个文件名是pxelinux.0 [root@centos7 ~]# mkdir /var/lib/tftpboot/pxelinux.cfg/ [root@centos7 ~]# cp /usr/share/syslinux/{menu.c32,pxelinux.0} /var/lib/tftpboot/ ##拷贝启动文件到tftp工作目录 [root@centos7 ~]# cp /var/www/html/centos/7/os/x86_64/isolinux/{vmlinuz,initrd.img} /var/lib/tftpboot/ ##拷贝启动内核文件和initrd.img [root@centos7 tftpboot]# cp /var/www/html/centos/7/os/x86_64/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default ##拷贝启动菜单 [root@centos7 tftpboot]# tree /var/lib/tftpboot/ /var/lib/tftpboot/ ├── initrd.img ├── menu.c32 ├── pxelinux.0 ├── pxelinux.cfg │ └── default └── vmlinuz 6.修改菜单项 [root@centos7 pxelinux.cfg]# cat /var/lib/tftpboot/pxelinux.cfg/default default menu.c32 timeout 100 menu title PXE Install CentOS label linux menu label ^Auto Install Mini CentOS 7 kernel vmlinuz append initrd=initrd.img ks=http://192.168.175.128/ksdir/ks7-desktop.cfg ##应答文件的路径 menu title PXE Install CentOS ##菜单项模拟 label linux menu label ^Auto Install Desktop CentOS 7 kernel vmlinuz append initrd=initrd.img ks=http://192.168.175.128/ksdir/ks7-desktop.cfg label local menu default menu label Boot from ^local drive localboot 0xffff centos6 自动安装1.安装httpd,dhcp,tftp-server [root@centos6 x86_64]# mount /dev/cdrom /var/www/html/centos/6/os/x86_64/ ##配置yum源 [root@centos6 os]# service httpd restart ##启动httpd服务 [root@centos6 ksdir6]# ls ##准备ks文件，记得加上访问权限 ks6_min.cfg ks6_min.cfg.bak [root@centos6 ksdir6]# cp /usr/share/doc/dhcp*/dhcpd.conf.sample /etc/dhcp/dhcpd.conf ##配置DHCP服务 30 # This is a very basic subnet declaration. ##主要修改以下几行 31 32 subnet 192.168.175.0 netmask 255.255.255.0 { 33 range 192.168.175.20 192.168.175.200; 34 next-server 192.168.175.10; ##tftp服务器的ip 35 filename &quot;pxelinux.0&quot;; 36 } [root@centos6 ~]# cd /var/lib/tftpboot/ [root@centos6 tftpboot]# cp /var/www/html/centos/6/os/x86_64/isolinux/{boot.msg,vmlinuz,initrd.img,splash.jpg,vesamenu.c32} ./ [root@centos6 ~]# yum install -y syslinux-nonlinux 这个包里面有pxelinux.0这个文件 [root@centos6 tftpboot]# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/ cp /var/www/html/centos/6/os/x86_64/isolinux/isolinux.cfg pxelinux.cfg/default --------------------------centos自动安装default文件-------------------------- ##最后的default文件 [root@centos6 pxelinux.cfg]# cat default default vesamenu.c32 #prompt 1 timeout 100 display boot.msg menu background splash.jpg menu title PXE Install CentOS ! menu color border 0 #ffffffff #00000000 menu color sel 7 #ffffffff #ff000000 menu color title 0 #ffffffff #00000000 menu color tabmsg 0 #ffffffff #00000000 menu color unsel 0 #ffffffff #00000000 menu color hotsel 0 #ff000000 #ffffffff menu color hotkey 7 #ffffffff #ff000000 menu color scrollbar 0 #ffffffff #00000000 label linux menu label ^Install Mini centos 6 system kernel vmlinuz append initrd=initrd.img ks=http://192.168.175.10/ksdir6/ks6_min.cfg label local menu default menu label Boot from ^local drive localboot 0xffff --------------------------centos自动安装ks文件-------------------------- [root@centos6 ksdir6]# cat ks6_min.cfg # Kickstart file automatically generated by anaconda. #version=DEVEL install url --url=http://192.168.175.10/centos/6/os/x86_64/ lang en_US.UTF-8 keyboard us text reboot network --onboot no --device eth0 --bootproto dhcp --noipv6 rootpw --iscrypted $6$jg/ThvgCcDKSH2El$NBNMCj3vhrdaQ5LetJnmsBJ5EqnpJh32DtnlMSdxkZVh2bMC1qpBEpxZJtq4Mhtr99ENHcpu3/FnDru5z.kP4/ firewall --disabled selinux --disabled authconfig --enableshadow --passalgo=sha512 selinux --enforcing timezone Asia/Shanghai bootloader --location=mbr --driveorder=sda --append=&quot;crashkernel=auto rhgb quiet&quot; # The following is the partition information you requested # Note that any partitions you deleted are not expressed # here so unless you clear all partitions first, this is # not guaranteed to work #clearpart --none clearpart --all zerombr part /boot --fstype=ext4 --size=1024 part / --fstype=ext4 --size=50000 part /data --fstype=ext4 --size=30000 part swap --size=2048 %packages @core %end 自动安装6,7在一台机器上实现centos6和centos7的安装--------------------------centos自动安装6,7系统步骤-------------------------- [root@centos7 html]# ls ksdir/ ks6-min.cfg ks7-desktop.cfg [root@centos7 tftpboot]# tree /var/lib/tftpboot/ /var/lib/tftpboot/ ├── linux6 │ ├── initrd.img │ └── vmlinuz ├── linux7 │ ├── initrd.img │ └── vmlinuz ├── menu.c32 ├── pxelinux.0 └── pxelinux.cfg └── default 3 directories, 7 files [root@centos7 pxelinux.cfg]# cat default default menu.c32 timeout 100 menu title PXE Install CentOS label mini7 menu label ^Auto Install Mini CentOS 7 kernel linux7/vmlinuz append initrd=linux7/initrd.img ks=http://192.168.175.22/ksdir/ks7-desktop.cfg menu title PXE Install CentOS label mini6 menu label ^Auto Install Mini CentOS 6 kernel linux6/vmlinuz append initrd=linux6/initrd.img ks=http://192.168.175.22/ksdir/ks6-min.cfg label local menu default menu label Boot from ^local drive localboot 0xffff cobbler 自动化安装[root@centos7 yum.repos.d]# yum install -y cobbler [root@centos7 ~]# systemctl restart cobblerd [root@centos7 ~]# cobbler check [root@centos7 ~]# vim /etc/cobbler/settings 390 server: 192.168.175.22 ##本机IP 278 next_server: 192.168.175.22 ##dhcpip systemctl restart tftp default_password_crypted: &quot;$1$iJ6yb/Em$949E8mhRCKRZ49iqAl7Se/&quot; ##修改口令 openssl passwd -1命令然后输入口令加密后得到 manage_dhcp: 1 修改为1，后dhcp的配置文件会自动生成 cobbler get-loaders 下载必要的内核安装文件 cobbler sync vim /etc/cobbler/dhcp.template ##主要修改dhcp的模板配置文件 subnet 192.168.175.0 netmask 255.255.255.0 { option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.175.100 192.168.175.254; cobbler sync ##同步。这个时候dhcp已经自动配置完了。 [root@centos7 tftpboot]# cobbler import --path=/misc/cd/ --name=Centos-7.5-x86_64 --arch=x86_64 [root@centos7 tftpboot]# cobbler import --path=/mnt/cdrom/ --name=Centos-6.10-x86_64 --arch=x86_64 ##这里导入了两个操作系统镜像后，并且会自动生成default文件。就可以实现自动安装了。 cobbler sync ##default不显示就同步一下 ##以上用到的是默认的应答文件 自定义应答文件##这里设置应答文件 将两个应答文件拷贝到此目录 /var/lib/cobbler/kickstarts [root@centos7 kickstarts]# cobbler distro list ##查看系统目前的安装版本 Centos-6.10-x86_64 Centos-7.5-x86_64 [root@centos7 kickstarts]# cobbler profile add --name=centos-7.5-x86_64_mini --distro=Centos-7.5-x86_64 --kickstart=/var/lib/cobbler/kickstarts/ks7-min.cfg ##添加--name菜单名，--distro表示系统安装的版本号，----kickstart表示对应的ks文件。然后对用的default文件会多出一条菜单项 ##那么这个时候查看列表 [root@centos7 kickstarts]# cobbler distro list Centos-6.10-x86_64 Centos-7.5-x86_64 [root@centos7 kickstarts]# cobbler profile list Centos-6.10-x86_64 Centos-7.5-x86_64 centos-6.10-x86_64_mini centos-7.5-x86_64_mini ##如果不想要了，可以用这种方式进行删除 [root@centos7 kickstarts]# cobbler profile remove --name=centos-7.5-x86_64_mini ##改名 [root@centos7 kickstarts]# cobbler profile rename --name=centos-6.10-x86_64_mini --newnam=centos-6.10-desktop [root@centos7 kickstarts]# cobbler profile list Centos-7.5-x86_64 centos-6.10-desktop ##显示某个菜单项的具体信息 [root@centos7 kickstarts]# cobbler profile report --name=centos-6.10-desktop web管理##安装web页面来管理 [root@centos7 kickstarts]# yum install -y cobbler-web 验证用户和密码都是cobbler 更改验证方法:/etc/cobbler/users.digestl里面记载使用某种验证方式对应的文件路径 /etc/cobbler/users.digest [root@centos7 ~]# cat /etc/cobbler/users.digest cobbler:Cobbler:a2d6bae81669d707b72c0bd9806e01f3 用户:领域:加密口令 [root@centos7 ~]# htdigest /etc/cobbler/users.digest Cobbler cobbleradmin 建立新用户和口令 Adding user cobbleradmin in realm Cobbler New password: Re-type new password: [root@centos7 ~]# cat /etc/cobbler/users.digest ##再次查看这个文件就多了一个admin的用户 cobbler:Cobbler:a2d6bae81669d707b72c0bd9806e01f3 cobbleradmin:Cobbler:3025f52ddbf068deb13380f2fe00c7ff ##更改验证方式 module = authn_pam ##更改模块验证 [root@centos7 cobbler]# useradd -s /sbin/nologin cobbleradmin2 ##建立一个用户用来登录。这个模块是用系统用户来登录的 [root@centos7 cobbler]# passwd cobbleradmin2 /etc/cobbler/users.conf ##将用户名写到此文件中 systemctl restart cobblerd Ansibleon-Premises(本地部署)laas(基础设施即服务)Paas(平台即服务)SaaS(软件即服务) Ansible 配置文件/etc/ansible/ansible.cfg （一般保持默认）[defaults]#inventory = /etc/ansible/hosts # 主机列表配置文件#library = /usr/share/my_modules/ # 库文件存放目录#remote_tmp = $HOME/.ansible/tmp #临时py命令文件存放在远程主机目录#local_tmp = $HOME/.ansible/tmp # 本机的临时命令执行目录#forks = 5 # 默认并发数 #sudo_user = root # 默认sudo 用户#ask_sudo_pass = True #每次执行ansible命令是否询问ssh密码#ask_pass = True#remote_port = 22#host_key_checking = False#检查对应服务器的host_key，建议取消注释#log_path=/var/log/ansible.log #日志文件#module_name = command #默认模块 ansible通过ssh实现配置管理、应用部署、任务执行等功能，建议配置ansible端能基于密钥认证的方式联系各被管理节点ansible-doc：显示模块帮助-a 显示所有模块-l,–list 列出所有模块-s,–snippet 显示指定模块的playbook片段-k, –ask-pass 提示输入ssh连接密码，默认Key验证-K, –ask-become-pass 提示输入sudo时的口令-u, –user=REMOTE_USER 执行远程执行的用户-b, –become 代替旧版的sudo 切换[root@ansible ~]# ansible 192.168.175.10 -m ping -u pan -k -b -K对方机器也需要做好pan用户的sudo授权，-k是输入pan用户的密码，使用sudo是要重新输入口令的，所以还需要加上-K选项root ALL=(ALL) ALLpan ALL=(root) NOPASSWD:ALL 如果想要不输入sudo口令，可以在配置文件中visudo加入NOPASSWD–version 显示版本-m module 指定模块，默认为command-v 详细过程 –vv -vvv更详细 匹配模式ansible的Host-pattern 匹配主机的列表 All ：表示所有Inventory中的所有主机 ansible all –m ping * :通配符 ansible &quot;*&quot;&quot; -m ping ansible 192.168.1.* -m ping ansible &quot;*srvs&quot; -m ping 或关系 ansible &quot;websrvs:appsrvs&quot; -m ping ansible &quot;192.168.1.10:192.168.1.20&quot; -m ping 逻辑与 ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping 在websrvs组并且在dbsrvs组中的主机 逻辑非 ansible &#39;websrvs:!dbsrvs&#39; –m ping 在websrvs组，但不在dbsrvs组中的主机注意：此处为单引号 综合逻辑 ansible &#39;websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs&#39; –m ping 正则表达式 ~表示里面写的是正则表达式 ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping ansible &quot;~(web|db).*\.magedu\.com&quot; –m ping -------------------------------------------------------------------------------匹配模式例子如下 [root@ansible ~]# ansible all --list-hosts 分组查看，之前已在/etc/ansible/hosts定义过 hosts (3): 192.168.175.10 192.168.175.132 192.168.175.101 [root@ansible ~]# ansible appserver --list-hosts ##查看某个组的 hosts (2): 192.168.175.10 192.168.175.132 [root@ansible ~]# ansible &quot;webserver:appserver&quot; --list-hosts ##或的关系 hosts (3): 192.168.175.101 192.168.175.10 192.168.175.132 [root@ansible ~]# ansible &quot;webserver:&amp;appserver&quot; --list-hosts ##与的关系 hosts (1): 192.168.175.10 [root@ansible ~]# ansible &apos;webserver:!appserver&apos; --list-hosts ##逻辑非 hosts (1): 192.168.175.101 配置ansible四台机器做这个实验:ansible这里的笔记不计顺序 192.168.175.22(Ansible)-192.168.175.10-192.168.175.132-192.168.175.101 第一步:hostnamectl set-hostname ansible ##设置主机名 [root@ansible ~]# yum install -y ansible ##1.首先在服务器上安装ansible [root@ansible ~]# vim /etc/ansible/hosts 将所要管理的主机ip地址加入进去 [webserver] ##这个表示分组 192.168.175.101 192.168.175.10 ##可以同时存在多个组里面 [appserver] 192.168.175.10 192.168.175.132 ##192.168.34.[1:2]7 这种格式表示192.168.34.17和192.168.34.27 ansible 192.168.175.10 -m ping -k例子如下 [root@ansible ~]# vim /etc/ansible/ansible.cfg host_key_checking = False ##配置文件中里面的这样去掉注释表示不检查ssh的key验证 ##就是说这句下面这条命令执行后首先会进行yes|No的交互，现在取消了注释，就不会有了。 [root@ansible ~]# ansible 192.168.175.10 -m ping 192.168.175.10 | UNREACHABLE! =&gt; { ##这里表示不可达 &quot;changed&quot;: false, &quot;msg&quot;: &quot;Failed to connect to the host via ssh: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).&quot;, &quot;unreachable&quot;: true } ##这里的两台机器是可以ping通的，提示不可达的原因是ansible默认是基于进行key认证的，现在还没有做过key认证。 ##如果想要以口令连接，就要加-k参数 [root@ansible ~]# ansible 192.168.175.10 -m ping -k SSH password: 192.168.175.10 | SUCCESS =&gt; { ##现在显示成功了 &quot;ansible_facts&quot;: { &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot; }, &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot; } 第二步:ssh_key验证脚本如下。四台机器成功实现key连接 [root@ansible ~]# cat a.sh #!/bin/bash user=root ssh-keygen -t rsa -P &quot;&quot; -f /root/.ssh/id_rsa while read line ;do ip=`echo $line | awk &apos;{print $1}&apos;` password=`echo $line | awk &apos;{print $2}&apos;` expect &lt;&lt; EOF set timeout 10 spawn ssh-copy-id -i /root/.ssh/id_rsa.pub $user@$ip expect { &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue } &quot;password&quot; { send &quot;$password\n&quot;} } expect eof EOF done &lt; iptext.tx [root@ansible ~]# cat iptext.txt 192.168.175.10 123456 192.168.175.22 123456 192.168.175.132 123456 192.168.175.101 123456 ansible命令执行过程 加载自己的配置文件 默认/etc/ansible/ansible.cfg 加载自己对应的模块文件，如command 通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件 给文件+x执行 执行并返回结果 删除临时py文件，sleep 0退出执行状态： 文件/etc/ansible/ansible.cfg 有记载绿色：执行成功并且不需要做改变的操作黄色：执行成功并且对目标主机做变更红色：执行失败 ansible常用模块[root@ansible ~]# ansible-doc -s script 查询模块使用方法Command：在远程主机执行命令，默认模块，可忽略-m选项ansible srvs -m command -a ‘service vsftpd start’ansible srvs -m command -a ‘echo magedu |passwd –stdin wang’ 此命令不支持 $VARNAME &lt; &gt; | ; &amp; 等，用shell模块实现Shell：和command相似，用shell执行命令ansible srv -m shell -a ‘echo magedu |passwd –stdin wang’调用bash执行命令 类似 cat /tmp/stanley.md | awk -F‘|’ ‘{print $1,$2}’ &amp;&gt; /tmp/example.txt 这些复杂命令，即使使用shell也可能会失败，解决办法：写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器Script：在远程主机上运行ansible服务器上的脚本-a “/PATH/TO/SCRIPT_FILE“ansible websrvs -m script -a /data/f1.sh --------------------------------------------------------------常用模块例子 [root@ansible ~]# ansible 192.168.175.10 -m command -a &apos;rm -fr /root/fq&apos; ##删除远程主机上的文件 [root@ansible ~]# ansible all -m shell -a &apos;echo $HOSTNAME&apos; ##查看主机名 192.168.175.10 | CHANGED | rc=0 &gt;&gt; centos6.localdomain 192.168.175.132 | CHANGED | rc=0 &gt;&gt; Tiger 192.168.175.101 | CHANGED | rc=0 &gt;&gt; centos7 [root@ansible ~]# ansible all -m shell -a &apos;chdir=/data rm -fr *&apos; ##chdir的作用就是切换目录 想要修改默认模块可在/etc/ansible/ansible.cfg # default module name for /usr/bin/ansible module_name = shell [root@ansible ~]# ansible all -m script -a &quot;/root/ansible.sh&quot; ##远程机器执行本地脚本 [root@ansible ~]# cat ansible.sh 本地脚本 #!/bin/bash 远程脚本这一行记得加上 hostname sed -i &apos;s/^SELINUX=.*/SELINUX=permissive/&apos; /etc/selinux/config [root@ansible ~]# ansible all -a &quot;creates=/etc/fstab rm -fr /data/*&quot; ##creates表示远程主机上文件存在就不运行 192.168.175.132 | SUCCESS | rc=0 &gt;&gt; skipped, since /etc/fstab exists 192.168.175.10 | SUCCESS | rc=0 &gt;&gt; skipped, since /etc/fstab exists 192.168.175.101 | SUCCESS | rc=0 &gt;&gt; skipped, since /etc/fstab exists [root@ansible ~]# ansible all -a &quot;removes=/etc/fstab rm -fr /data/*&quot; ##remove表示远程主机上文件不存在就不执行，存在就执行 [WARNING]: Consider using the file module with state=absent rather than running &apos;rm&apos;. If you need to use command because file is insufficient you can add &apos;warn: false&apos; to this command task or set &apos;command_warnings=False&apos; in ansible.cfg to get rid of this message. 192.168.175.132 | CHANGED | rc=0 &gt;&gt; 192.168.175.10 | CHANGED | rc=0 &gt;&gt; 192.168.175.101 | CHANGED | rc=0 &gt;&gt; 常用模块Copy：从服务器复制文件到客户端ansible srv -m copy -a “src=/root/f1.sh dest=/tmp/f2.sh owner=wang mode=600 backup=yes”如目标存在，默认覆盖，此处指定先备份ansible srv -m copy -a “content=‘test content\n’ dest=/tmp/f1.txt”指定内容，直接生成目标文件Fetch：从客户端取文件至服务器端，copy相反，目录可先taransible srv -m fetch -a ‘src=/root/a.sh dest=/data/scripts’File：设置文件属性ansible srv -m file -a “path=/root/a.sh owner=wang mode=755“ansible web -m file -a ‘src=/app/testfile dest=/app/testfile-link state=link’ [root@ansible ~]# ansible all -m copy -a &quot;src=/etc/fstab dest=/root/data/ owner=pan mode=600&quot; ##将源文件/etc/fstab复制到目标主机/root/data目录下，拥有者修改为pan，权限修改为600 [root@ansible ~]# ansible all -m copy -a &quot;src=/etc/issue dest=/root/data/fstab owner=pan mode=600 backup=yes&quot; ##因为最后的文件名是fstab，默认覆盖，backup=yes指定备份，之前的文件会自动改名 [root@ansible ~]# ansible all -m copy -a &quot;src=/data dest=/home/&quot; ##将本机src指定的/data目录移动到对应的机器/home/目录下 [root@ansible ~]# ansible all -m copy -a &#39;content=&quot;[test]\nbaseurl=file:///mnt\ngpgcheck=0&quot; dest=/etc/yum.repos.d/test.repo&#39; ##直接写文件然后传到对应的机器上 [root@ansible ~]# ansible all -m fetch -a &#39;src=/etc/hosts dest=/data&#39; ##将远程主机上的文件抓取到本机上 [root@ansible data]# ansible all -a &#39;tar cf /root/data.tar /data&#39; ##他无法抓取文件夹，所以可以先打包然后再抓取 [root@ansible data]# ansible all -m fetch -a &#39;src=/root/data.tar dest=/data&#39; [root@ansible data]# ansible all -m file -a &#39;path=/data/file.txt state=touch&#39; ##在远程服务器上，path指定文件路径，fiel.txt指定创建的文件名，state=touch创建空白文件 [root@ansible data]# ansible all -m file -a &#39;path=/data/file.txt state=absent&#39; ##在远程服务器上，删除指定的file.txt文件 [root@ansible data]# ansible all -m file -a &#39;src=/etc/fstab path=/data/fstab.link state=link&#39; ##创建软链接文件 [root@ansible data]# ansible all -m file -a &#39;src=/etc/fstab path=/data/fstab.link state=hard&#39; ##创建硬链接文件 [root@ansible data]# ansible all -m file -a &#39;dest=/data/dir1 state=directory&#39; ##创建文件夹 [root@ansible data]# ansible all -m file -a &#39;dest=/data/dir1 state=absent&#39; ##删除文件夹 [root@ansible data]# ansible 192.168.175.101 -m hostname -a &#39;name=centos101&#39; ##更改某个主机名 ##计划任务 [root@ansible data]# ansible all -m cron -a &#39;minute=*/5 weekday=0,6 job=&quot;/usr/sbin/ntpdate 172.18.0.1 &amp;&gt; /dev/null&quot; name=synctime&#39; [root@ansible data]# ansible all -a &#39;crontab -l&#39; ##查看 [root@ansible data]# ansible all -m cron -a &#39;minute=*/5 weekday=0,6 job=&quot;/usr/sbin/ntpdate 172.18.0.1 &amp;&gt; /dev/null&quot; name=synctime disabled=true&#39; ##关闭crontab [root@ansible data]# ansible all -m cron -a &#39;minute=*/5 weekday=0,6 job=&quot;/usr/sbin/ntpdate 172.18.0.1 &amp;&gt; /dev/null&quot; name=synctime disabled=false&#39; ##打开crontab [root@ansible data]# ansible all -m cron -a &#39;name=synctime state=absent&#39; ##删除计划任务 [root@ansible ~]# ansible 192.168.175.132 -m yum -a &quot;name=dstat&quot; ##使用yum安装软件 ansible srv -m yum -a &#39;name=httpd state=present&#39; 安装 [root@ansible ~]# ansible 192.168.175.10 -m yum -a &#39;name=httpd,vsftpd state=absent&#39; ##卸载软件 [root@ansible ~]# ansible all -m yum -a &quot;name=dstat update_cache=yes&quot; ##更新yum缓存后安装软件 [root@ansible ~]# ansible 192.168.175.133 -m service -a &#39;name=httpd state=started&#39; ##启动服务 [root@ansible ~]# ansible all -m service -a &#39;name=httpd state=stopped&#39; ##停止服务 [root@ansible ~]# ansible all -m service -a &#39;name=httpd state=started enabled=yes&#39; ##设置为开机启动 这里不能同时对多个服务启动，只能一个一个的启动&quot;name=httpd,vsftpd state=started&quot;错误的用法 [root@ansible ~]# ansible all -m user -a &#39;name=test comment=&quot;test user&quot; uid=2000 home=/data/testhome group=root groups=bin,nobody shell=/sbin/nologin&#39; ##创建用户 name 名称，comment 描述， [root@ansible ~]# ansible all -m user -a &#39;name=test state=absent remove=yes&#39; ##删除用户，remove表示连目录下的文件也一起删除 ansible-galaxy连接 https://galaxy.ansible.com 下载相应的roles列出所有已安装的galaxyansible-galaxy list安装galaxy:ansible-galaxy install geerlingguy.redis删除galaxy:ansible-galaxy remove geerlingguy.redis ansible-playbook执行playbook示例：ansible-playbook hello.yml cat hello.yml #hello world yml file - hosts: webserver remote_user: root tasks: - name: hello world command: /usr/bin/wall hello world ansible-vault功能：管理加密解密yml文件ansible-vault [create|decrypt|edit|encrypt|rekey|view]ansible-vault encrypt hello.yml 加密ansible-vault decrypt hello.yml 解密nsible-vault view hello.ymlansible-vault edit hello.yml查看编辑加密文件ansible-vault rekeyhello.yml修改口令ansible-vault create new.yml创建新文件直接加密 Ansible-console 2.0+新增，可交互执行命令，支持tabplaybookplaybook是由一个或多个“play”组成的列表play的主要功能在于将预定义的一组主机，装扮成事先通过ansible中的task定义好的角色。Task实际是调用ansible的一个module，将多个play组织在一个playbook中，即可以让它们联合起来，按事先编排的机制执行预定义的动作Playbook采用YAML语言编写 [root@ansible playbook]# cat a.yml ##yml文件 --- - hosts: webserver ##主机 remote_user: root tasks: - name: first task ping: - name: second task shell: /bin/ls /data/ ansible-playbook -C a.yml ##检查语法 [root@ansible playbook]# ansible-playbook a.yml 执行 ansible-playbook a.yml --list-hosts ##查看操作的主机 ansible-playbook a.yml --list-tasks ##查看任务 ansible-playbook a.yml --limit 192.168.175.101 ##查看特定主机 ansible-playbook a.yml -v ##执行显示详细过程 在本机安装了httpd,并且将它的端口改为8080,然后配置文件复制到了/etc/playbook/httpd.conf,还创建了apache账户，系统组，gid为80，秘钥是123456加密。发布到管理的主机后，启动服务。 [root@ansible playbook]# cat httpd.yml --- - hosts: webserver remote_user: root tasks: - name: create group group: name=apache system=yes gid=80 - name: create user ##systemctl 系统组 user: name=apache group=apache uid=81 shell=/sbin/noloign home=/usr/share/httpd system=yes password=&#39;$1$vyYsCY3r$.bt4t6Uam7D3PJy6FgFSi0&#39; ##password= openssl passwd -1加密的秘钥 - name: install package yum: name=httpd - name: config file copy: src=/root/playbook/httpd.conf dest=/etc/httpd/conf/ backup=yes - name: service service: name=httpd state=started enabled=yes ansible-playbook httpd.yml ##执行 ansible webserver -a &quot;ss -ntl&quot; ##查看端口 sha512加密算法,生成加密算法工具:python -c &#39;import crypt,getpass;pw=&quot;123456&quot;;print(crypt.crypt(pw))&#39; handlers和notify结合使用触发条件Handlers是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作Notify此action可用于在每个play的最后被触发，这样可避免多次有改变发生时每次都执行指定的操作，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作 --- - hosts: webserver remote_user: root tasks: - name: create group group: name=apache system=yes gid=80 - name: create user user: name=apache group=apache uid=80 shell=/sbin/noloign home=/usr/share/httpd system=yes password=&#39;$1$vyYsCY3r$.bt4t6Uam7D3PJy6FgFSi0&#39; - name: install package yum: name=httpd - name: config file copy: src=/root/playbook/httpd.conf dest=/etc/httpd/conf/ backup=yes notify: restart service ##只有当文件和之前相比发生变化 - name: service service: name=httpd state=started enabled=yes handlers: - name: restart service service: name=httpd state=restarted ##就会执行重启httpd的命令 Playbook中tags使用[root@ansible playbook]# cat httpd.yml --- - hosts: webserver remote_user: root tasks: - name: create group group: name=apache system=yes gid=80 - name: create user user: name=apache group=apache uid=80 shell=/sbin/noloign home=/usr/share/httpd system=yes password=&#39;$1$vyYsCY3r$.bt4t6Uam7D3PJy6FgFSi0&#39; - name: install package yum: name=httpd - name: config file copy: src=/root/playbook/httpd.conf dest=/etc/httpd/conf/ backup=yes tags: c notify: - restart service - check httpd - name: service tags: service service: name=httpd state=started enabled=yes handlers: - name: restart service service: name=httpd state=restarted - name: check httpd shell: /usr/bin/killall -0 httpd &amp;&gt; /tmp/httpd.log ansible-playbook -t c httpd.yml ##指定某个标签只执行任务 Playbook中变量使用变量名：仅能由字母、数字和下划线组成，且只能以字母开头变量来源： ansible setup facts 远程主机的所有变量都可直接调用 在/etc/ansible/hosts中定义普通变量：主机组中主机单独定义，优先级高于公共变量公共（组）变量：针对主机组中所有主机定义统一变量 通过命令行指定变量，优先级最高ansible-playbook –e varname=value 在playbook中定义vars: var1: value1 var2: value2 在独立的变量YAML文件中定义 在role中定义示例: --- - hosts: webserver remote_user: root tasks: - name: install package yum: name={{ name1 }} ##变量 - name: service tags: c service: name={{ name2 }} state=started enabled=yes ansible-playbook -e &quot;name1=samba name2=smbd&quot; test.yml ##可以指定不同的变量 ##内置变量 --- - hosts: webserver remote_user: root vars: - name1: samba - name2: smb tasks: - name: install package yum: name={{ name1 }} ##变量 - name: service tags: c service: name={{ name2 }} state=started enabled=yes [root@ansible playbook]# cat variable.yml ##写入变量文件 name1: httpd name2: httpd [root@ansible playbook]# cat test.yml --- - hosts: webserver remote_user: root vars_files: ##引入变量文件 - variable.yml tasks: - name: install package yum: name={{ name1 }} ##变量 - name: service tags: c service: name={{ name2 }} state=started enabled=yes 在hosts中定义变量[webserver] 192.168.175.101 nodename=centos7_1 ##普通变量 192.168.175.10 nodename=centos7_2 [root@ansible playbook]# cat test3.yml --- - hosts: webserver remote_user: root tasks: - name: hostname hostname: name={{ nodename }} [root@ansible playbook]# ansible webserver -a &quot;hostname&quot; 192.168.175.10 | CHANGED | rc=0 &gt;&gt; centos7_2 192.168.175.101 | CHANGED | rc=0 &gt;&gt; centos7_1 ##分组变量 [root@ansible ansible]# cat /etc/ansible/hosts [webserver] 192.168.175.101 nodename=centos7_1 192.168.175.10 nodename=centos7_2 [webserver:vars] suffix=magedu.com [root@ansible playbook]# cat test3.yml --- - hosts: webserver remote_user: root tasks: - name: hostname hostname: name={{ nodename }}.{{ suffix }} [root@ansible playbook]# ansible webserver -a &quot;hostname&quot; ##执行效果 192.168.175.10 | CHANGED | rc=0 &gt;&gt; centos7_2.magedu.com 192.168.175.101 | CHANGED | rc=0 &gt;&gt; centos7_1.magedu.com 模板templatestemplates功能：根据模块文件动态生成对应的配置文件templates文件必须存放于templates目录下，且命名为 .j2 结尾yaml/yml 文件需和templates目录平级，目录结构如下： ./ ├── temnginx.yml └── templates └── nginx.conf.j2 cd /playbook [root@ansible playbook]# yum install -y nginx [root@ansible playbook]# cp /etc/nginx/nginx.conf . [root@ansible playbook]# mkdir templates [root@ansible playbook]# mv nginx.conf templates/nginx.conf.j2 [root@ansible playbook]# cat test_temp.yml --- - hosts: webserver remote_user: root tasks: - name: install yum: name=nginx - name: service service: name=nginx state=started enabled=yes ##在webserver分组里面的主机安装一个nginx，并且启动服务，将他设置为开机启动 [root@ansible playbook]# ansible webserver -m setup -a &quot;filter=ansible_processor_count&quot; ##查看他的CPU个数，对方机器有几个cpu，就会生成几个worker文件 [root@ansible playbook]# ansible webserver -a &quot;ps aux | grep nginx&quot; nginx 8351 0.0 0.7 123264 3548 ? S 05:28 0:00 nginx: worker process nginx 8352 0.0 0.7 123264 3548 ? S 05:28 0:00 nginx: worker process ##其中一台机器生成了两个worker进程 ##修改文件 [root@ansible playbook]# cat test_temp.yml --- - hosts: webserver remote_user: root tasks: - name: install yum: name=nginx - name: template template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: restart - name: service service: name=nginx state=started enabled=yes handlers: - name: restart service: name=nginx state=restarted [root@ansible playbook]# vim templates/nginx.conf.j2 user nginx; worker_processes {{ansible_processor_count*2}}; ##auto 表示cpu几个就生成几个worker.现在的意思是通过变量计算cpu的个数*2,让的worker他生成原有的2倍 [root@ansible playbook]# ansible webserver -a &quot;ps aux | grep nginx&quot; nginx 16715 0.0 0.7 123264 3552 ? S 20:07 0:00 nginx: worker process nginx 16716 0.0 0.7 123264 3552 ? S 20:07 0:00 nginx: worker process nginx 16717 0.0 0.7 123264 3552 ? S 20:07 0:00 nginx: worker process nginx 16718 0.0 0.7 123264 3552 ? S 20:07 0:00 nginx: worker process ##现在其中的一台测试机器已经实现了 [root@ansible playbook]# vim /etc/ansible/hosts ##在主机清单里面定义变量端口 [webserver] 192.168.175.101 nodename=centos7_1 port=81 192.168.175.10 nodename=centos6_2 port=82 [root@ansible playbook]# vim templates/nginx.conf.j2 ##在模板文件里面引用 server { listen {{port}} default_server; [root@ansible playbook]# ansible-playbook test_temp.yml ##执行生效 ##还可以在playbook文件也可以添加端口，和主机清单相比较，playbook的优先级更高 - hosts: webserver remote_user: root vars: port: 8080 ##但是下面这句话的优先级更高 [root@ansible playbook]# ansible-playbook -e &quot;port=9191&quot; test_temp.yml ##通过文件安装不同的系统软件，6,7上面的httpd [root@ansible playbook]# ls templates/ httpd6.conf.j2 httpd7.conf.j2 ##从各自系统复制过来的配置文件然后改名 [root@ansible playbook]# cat /etc/ansible/hosts [webserver] 192.168.175.136 http_port=86 192.168.175.10 http_port=87 [root@ansible playbook]# cat test2_temp.yml --- - hosts: webserver remote_user: root tasks: - name: install yum: name=httpd - name: template template: src=httpd6.conf.j2 dest=/etc/httpd/conf/httpd.conf when: ansible_distribution_major_version==&quot;6&quot; ##判断是否相等 notify: restart - name: template template: src=httpd7.conf.j2 dest=/etc/httpd/conf/httpd.cofn notify: restart when: ansible_distribution_major_version==&quot;7&quot; ##判断是否相等 - name: service service: name=httpd state=started enabled=yes handlers: - name: restart service: name=httpd state=restarted 最后执行生效 迭代：with_items迭代：当有需要重复性执行的任务时，可以使用迭代机制对迭代项的引用，固定变量名为”item”要在task中使用with_items给定要迭代的元素列表列表格式：字符串字典 例:自动拷贝文件 cd /root/playbook [root@ansible playbook]# cat file.yml --- - hosts: webserver remote_user: root tasks: - name: copy files copy: src={{item}} dest=/root/data/ mode=600 with_items: - file1 - file2 - file3 ##这里写几个，他就拷贝几遍 [root@ansible playbook]# ls files file1 file2 file3 批量创建用户和组[root@ansible playbook]# cat file.yml --- - hosts: webserver remote_user: root tasks: - name: create groups group: name={{item}} with_items: - g1 - g2 - g3 - name: create users user: name={{item.name}} group={{item.group}} with_items: ##字典 - {name: &#39;user1&#39;,group: &#39;g1&#39;} - {name: &#39;user2&#39;,group: &#39;g2&#39;} - {name: &#39;user3&#39;,group: &#39;g3&#39;} 批量安装软件[root@ansible playbook]# cat yum.yml --- - hosts: webserver remote_user: root tasks: - name: install yum: name={{item}} with_items: - httpd - vaftpd - memcached 批量生成文件[root@ansible playbook]# cat for.yml --- - hosts: webserver remote_user: root vars: ports: - 81 - 82 - 83 tasks: - name: template template: src=test_for.conf.j2 dest=/data/test_for.conf [root@ansible playbook]# cat templates/test_for.conf.j2 {% for p in ports %} service{ listen {{p}} } {% endfor %} ## 最终结果 [root@centos7 data]# cat test_for.conf service{ listen 81 } service{ listen 82 } service{ listen 83 } 另外一种写法[root@ansible playbook]# cat for.yml --- - hosts: webserver remote_user: root vars: ports: - listen_port: 81 - listen_port: 82 - listen_port: 83 tasks: - name: template template: src=test_for.conf.j2 dest=/data/test_for.conf [root@ansible playbook]# cat templates/test_for.conf.j2 {% for p in ports %} service{ listen {{p.listen_port}} } {% endfor %} 自动添加文件内容，减少重复性操作[root@ansible playbook]# cat templates/test_for.conf.j2 {% for p in vhosts %} service{ listen {{p.listen_port}} server_name {{p.host_name}} root {{p.dirname}} } {% endfor %} [root@ansible playbook]# cat for.yml --- - hosts: webserver remote_user: root vars: vhosts: - host1: listen_port: 81 host_name: www.a.com dirname: /data/www1 - host2: listen_port: 82 host_name: www.b.com dirname: /data/www2 - host3: listen_port: 83 host_name: www.c.com dirname: /data/www3 tasks: - name: template template: src=test_for.conf.j2 dest=/data/test_for.conf [root@centos7 data]# cat test_for.conf ##最终结果 service{ listen 81 server_name www.a.com root /data/www1 } service{ listen 82 server_name www.b.com root /data/www2 } service{ listen 83 server_name www.c.com root /data/www3 } if使用[root@ansible playbook]# cat for.yml --- - hosts: webserver remote_user: root vars: vhosts: - host1: listen_port: 81 host_name: www.a.com dirname: /data/www1 - host2: listen_port: 82 #host_name: www.b.com ##这里注释掉了 dirname: /data/www2 - host3: listen_port: 83 host_name: www.c.com dirname: /data/www3 tasks: - name: template template: src=test_for.conf.j2 dest=/data/test_for.conf [root@ansible playbook]# cat templates/test_for.conf.j2 {% for p in vhosts %} server{ listen {{p.listen_port}} {%if p.host_name is defined %} ##监控，当文件上面的文件没有定义是，就不会被执行 server_name {{p.host_name}} {%endif%} root {{p.dirname}} } {% endfor %} ##实际效果 [root@centos7 data]# cat test_for.conf server{ listen 81 server_name www.a.com root /data/www1 } server{ listen 82 ##这里空出来了，因为上面被注释掉。 root /data/www2 } server{ listen 83 server_name www.c.com root /data/www3 } roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中复杂场景：建议使用roles，代码复用度高变更指定主机或主机组如命名不规范维护和传承成本大某些功能需多个Playbook，通过includes即可实现 [root@ansible playbook]# tree roles/ ##这里以httpd为例，其他的服务参照这个来 roles/ ├── httpd │ ├── files │ │ └── httpd.conf ##存放的是http配置文件，从本机复制过来的 │ ├── handlers ##本次实验此文件夹加无文件 │ ├── tasks ##此文件夹存放的是步骤文件 │ │ ├── config.yml │ │ ├── group.yml │ │ ├── install.yml │ │ ├── main.yml │ │ ├── service.yml │ │ └── user.yml │ ├── templates ##本次实验此文件夹加无文件 │ └── vars ##本次实验此文件夹加无文件 ├── mysql │ ├── files │ ├── handlers │ ├── tasks │ ├── templates │ └── vars └── nginx ├── files ├── handlers ├── tasks ├── tempatles └── vars [root@ansible playbook]# cat httpd_role.yml - hosts: webserver remote_user: root roles: - role: httpd ---------------------------------------tasks目录下各文件详情----------------------------- [root@ansible tasks]# cat group.yml - name: create group group: name=apache system=yes gid=80 [root@ansible tasks]# cat user.yml - name: create user user: name=apache group=apache uid=80 shell=/sbin/nologin home=/usr/share/httpd system=yes [root@ansible tasks]# cat install.yml - name: install package yum: name=httpd [root@ansible tasks]# cat config.yml - name: config file copy: src=httpd.conf dest=/etc/httpd/conf/ backup=yes ##这里没有写绝对路径，他会自动从刚刚新建的httpd下的files文件夹里面寻找 [root@ansible tasks]# cat service.yml - name: service service: name=httpd state=started enabled=yes [root@ansible tasks]# cat main.yml ##执行顺序 - include: group.yml - include: user.yml - include: install.yml - include: config.yml - include: service.yml 给httpd再换一个测试页面[root@ansible playbook]# vim roles/httpd/files/index.html &lt;h1&gt;welcome to My index.html!&lt;/h1&gt; [root@ansible playbook]# cat roles/httpd/tasks/data.yml - name: data file ##src在files 文件夹默认在这里面寻找，不用写路径 copy: src=index.html dest=/var/www/html/ ##复制文件到指定的测试目录 [root@ansible playbook]# cat roles/httpd/tasks/main.yml - include: group.yml - include: user.yml - include: install.yml - include: config.yml - include: service.yml - include: data.yml ##加入刚刚创建的文件 ansible-playbook httpd_role.yml ##最后执行 Roles各目录作用/roles/project/ :项目名称,有以下子目录files/ ：存放由copy或script模块等调用的文件templates/：template模块查找所需要模板文件的目录tasks/：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含handlers/：至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含vars/：定义变量，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含meta/：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，其它文件需在此文件中通过include进行包含default/：设定默认变量时使用此目录中的main.yml文件 配置nginx[root@ansible playbook]# tree roles/ roles/ └── nginx ├── files ##本次实验此目录无文件 ├── handlers ##这里写了监控当文件发生变动，就会重启服务 │ └── main.yml ├── tasks │ ├── config.yml │ ├── data.yml │ ├── install.yml │ ├── main.yml │ └── service.yml ├── templates │ └── nginx.conf.j2 ##默认复制复制过来的配置文件改名 └── vars ##本次实验此目录无文件 [root@ansible roles]# cat nginx/handlers/main.yml - name: restart service: name=nginx state=restarted [root@ansible tasks]# cat config.yml - name: config file template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: restart ##监控文件，与上文对应 [root@ansible tasks]# cat data.yml - name: data ##这里是调用了刚刚配置httpd里面的测试文件，roles是总目录,所以这里可以这样写 copy: src=roles/httpd/files/index.html dest=/usr/share/nginx/html/ ##nginx测试文件存放路径 [root@ansible tasks]# cat install.yml - name: install package yum: name=nginx [root@ansible tasks]# cat main.yml - include: install.yml - include: config.yml - include: service.yml - include: data.yml [root@ansible tasks]# cat service.yml - name: service service: name=nginx state=started enabled=yes [root@ansible playbook]# cat nginx_role.yml - hosts: webserver remote_user: root roles: - role: nginx - role: httpd ##可以同时执行 增加变量配置完nginx后给其一个变量 [root@ansible nginx]# cat vars/main.yml username: daemon ##定义变量名 [root@ansible nginx]# vim templates/nginx.conf.j2 user {{username}}; ##在配置文件中引用 [root@ansible ~]# ansible 192.168.175.136 -a &quot;getent passwd daemon&quot; ##查看，已成功执行 192.168.175.136 | CHANGED | rc=0 &gt;&gt; daemon:x:2:2:daemon:/sbin:/sbin/nologin 不同的文件拷贝到不同的系统中[root@ansible playbook]# tree roles/httpd/ roles/httpd/ ├── files │ ├── httpd.conf │ └── index.html ├── handlers │ └── restart.yml ├── tasks │ ├── config.yml │ ├── data.yml │ ├── group.yml │ ├── install.yml │ ├── main.yml │ ├── service.yml │ └── user.yml ├── templates │ ├── httpd6.conf.j2 ##不同系统中的httpd配置文件改名后的结果 │ └── httpd7.conf.j2 └── vars 配置和上面的httpd配置一样，只是两个位置需要改动 [root@ansible httpd]# cat tasks/config.yml - name: config file1 template: src=httpd6.conf.j2 dest=/etc/httpd/conf/httpd.conf backup=yes when: ansible_distribution_major_version==&quot;6&quot; - name: config file2 template: src=httpd7.conf.j2 dest=/etc/httpd/conf/httpd.conf backup=yes when: ansible_distribution_major_version==&quot;7&quot; 使用标签其他的配置不变，只是最后的执行文件更改了 [root@ansible playbook]# cat all_role.yml - hosts: webserver remote_user: root roles: - {role: httpd,tags: [&quot;httpd&quot;,&quot;web&quot;]} ##表示两个标签 - {role: nginx,tags: [&quot;nginx&quot;,&quot;web&quot;]} [root@ansible playbook]# ansible-playbook -t nginx all_role.yml ##表示只装了一个nginx memcached 自动安装以及生成缓存范围数值[root@ansible roles]# tree memcached/ memcached/ ├── files ├── handlers │ └── restart.yml ├── tasks │ ├── config.yml │ ├── install.yml │ ├── main.yml │ └── service.yml ├── templates │ └── memcached.j2 └── vars [root@ansible memcached]# cat handlers/restart.yml - name: restart service: name=nginx state=restarted [root@ansible tasks]# cat * - name: config file1 template: src=memcached.j2 dest=/etc/sysconfig/memcached backup=yes - name: install packatge yum: name=memcached - include: install.yml - include: config.yml - include: service.yml - name: service service: name=memcached state=started enabled=yes [root@ansible memcached]# cat templates/memcached.j2 PORT=&quot;11211&quot; USER=&quot;memcached&quot; MAXCONN=&quot;1024&quot; CACHESIZE={{ansible_memtotal_mb//4}} ##内存大小整除 OPTIONS=&quot;&quot; hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nine]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[日志管理+FTP 日志：历史事件:时间，地点，人物，事件 日志级别：事件的关键性程度，Loglevel 系统日志服务： sysklogd :CentOS 5之前版本 syslogd: system application 记录应用日志 klogd: linux kernel 记录内核日志 事件记录格式： 日期时间 主机 进程[pid]: 事件内容 C/S架构：通过TCP或UDP协议的服务完成日志记录传送，将分布在不同主机的日志实现集中管理 rsyslog介绍术语，参见man logger facility：设施，从功能或程序上对日志进行归类 auth, authpriv, cron, daemon,ftp,kern, lpr, mail, news, security(auth), user, uucp, local0-local7, syslog Priority 优先级别，从低到高排序 debug, info, notice, warn(warning), err(error), crit(critical), alert, emerg(panic) 参看帮助： man 3 syslog rsyslog程序包：rsyslog 主程序：/usr/sbin/rsyslogd CentOS 7：/usr/lib/systemd/system/rsyslog.service 配置文件：/etc/rsyslog.conf，/etc/rsyslog.d/*.conf 库文件： /lib64/rsyslog/*.so 配置文件格式：由三部分组成 MODULES：相关模块配置 GLOBAL DIRECTIVES：全局配置 RULES：日志记录相关的规则配置 RULES配置格式： facility.priority; facility.priority… target facility： *: 所有的facility facility1,facility2,facility3,...：指定的facility列表 priority： *: 所有级别 none：没有级别，即不记录 PRIORITY：指定级别（含）以上的所有级别 =PRIORITY：仅记录指定级别的日志信息 target： 文件路径：通常在/var/log/，文件路径前的-表示异步写入 用户：将日志事件通知给指定的用户，* 表示登录的所有用户 日志服务器：@host，把日志送往至指定的远程服务器记录 管道： | COMMAND，转发给其它命令处理 logger -p local0.info &quot;ssh event start&quot; ##模拟日志的发生，查看是否记录到文件 将日志发送到远程主机 两台机器主机名不要一样 这里主机IP:192.168.67.142 vim /etc/rsyslog.conf $ModLoad imudp ##打开UDP网络协议模块 $UDPServerRun 514 ##监听端口514 systemctl restart rsyslog ss -nul ##查看UDP端口是否打开 tail -f /var/log/messages 192.168.67.141 vim /etc/rsyslog.conf *.info;mail.none;authpriv.none;cron.none /var/log/messages ##这一行是文件自带 *.info;mail.none;authpriv.none;cron.none @192.168.67.142 ##添加的这一行 然后重启服务systemctl restart rsyslog,可以看到142机器上监听日志已经有了141机器上的内容。 logger &quot;I am 192.168.67.142&quot; ##还可以在141机器上触发一个日志，142上也能看到 $ModLoad imtcp ##如果要走TCP协议就把这两行的注释取消 $InputTCPServerRun 514 重启服务（其余的操作一样） 在141机器上这一行要改动: *.info;mail.none;authpriv.none;cron.none @@192.168.67.142 重启服务 其它的日志文件/var/log/secure：系统安装日志，文本格式，应周期性分析 /var/log/btmp：当前系统上，用户的失败尝试登录相关的日志信息，二进制格式，lastb命令进行查看 /var/log/wtmp：当前系统上，用户正常登录系统的相关日志信息，二进制格式，last命令可以查看 /var/log/lastlog:每一个用户最近一次的登录信息，二进制格式，lastlog命令可以查看 /var/log/dmesg：系统引导过程中的日志信息，文本格式 文本查看工具查看 专用命令dmesg查看 /var/log/messages ：系统中大部分的信息 /var/log/anaconda : anaconda的日志 日志管理journalctlSystemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件/etc/systemd/journald.conf journalctl用法 查看所有日志（默认情况下 ，只保存本次启动的日志） journalctl 查看内核日志（不显示应用日志） journalctl -k 查看系统本次启动的日志 journalctl -b journalctl -b -0 查看上一次启动的日志（需更改设置） journalctl -b -1 查看指定时间的日志 journalctl --since=&quot;2017-10-30 18:10:30&quot; journalctl --since &quot;20 min ago&quot; journalctl --since yesterday journalctl --since &quot;2017-01-10&quot; --until &quot;2017-01-11 03:00&quot; journalctl --since 09:00 --until &quot;1 hour ago&quot; 显示尾部的最新10行日志 journalctl -n 显示尾部指定行数的日志 journalctl -n 20 实时滚动显示最新日志 journalctl -f 查看指定服务的日志 journalctl /usr/lib/systemd/systemd 查看指定进程的日志 journalctl _PID=1 查看某个路径的脚本的日志 journalctl /usr/bin/bash 查看指定用户的日志 journalctl _UID=33 --since today 查看某个 Unit 的日志 journalctl -u nginx.service journalctl -u nginx.service --since today 实时滚动显示某个 Unit 的最新日志 journalctl -u nginx.service -f 合并显示多个 Unit 的日志 journalctl -u nginx.service -u php-fpm.service --since today 查看指定优先级（及其以上级别）的日志，共有8级 0: emerg 1: alert 2: crit 3: err 4: warning 5: notice 6: info 7: debug journalctl -p err -b 日志默认分页输出，--no-pager 改为正常的标准输出 journalctl --no-pager 以 JSON 格式（单行）输出 journalctl -b -u nginx.service -o json 以 JSON 格式（多行）输出，可读性更好 journalctl -b -u nginx.serviceqq -o json-pretty 显示日志占据的硬盘空间 journalctl --disk-usage 指定日志文件占据的最大空间 journalctl --vacuum-size=1G 指定日志文件保存多久 journalctl --vacuum-time=1years rsyslog将日志记录于MySQL中192.168.67.142： yum install -y mariadb-server 安装数据库 192.168.67.141： 在rsyslog服务器上安装mysql模块相关的程序包 yum install rsyslog-mysql scp /usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql 192.168.67.142: 192.168.67.142： 为rsyslog创建数据库及表； mysql &lt; mysql-createDB.sql use Syslog grant all on Syslog.* to loguser@&#39;192.168.67.%&#39; identified by &#39;centos&#39;; ##新建用户 192.168.67.141： yum install -y mariadb mysql -uloguser -pcentos -h192.168.67.142 vim /etc/rsyslog.conf #### MODULES #### ##文件模块处 $ModLoad ommysql ##这是模块名，按照其他的格式，统一写在文件模块处(模块名来自:rpm -ql rsyslog-mysql) *.info;mail.none;authpriv.none;cron.none :ommysql:192.168.67.142,Syslog,loguser,centos ##数据库库主机，数据库名，数据库用户，密码 systemctl restart rsyslog ##重启服务 192.168.67.142： mysql use Syslog MariaDB [Syslog]&gt; select * from SystemEvents;(select * from SystemEvents\G;) ##可以看到已经有内容了 通过loganalyzer展示数据库中的日志 ##接上面的配置这里再拿一台主机来搭建php,实现浏览器访问日志 yum install -y httpd php php-mysql 下载软件包:loganalyzer-4.1.7.tar.gz cd loganalyzer-4.1.7 cp -r src/ /var/www/html/log systemctl restart httpd 然后浏览器访问本机ip 192.168.67.137，点击安装会报错权限不足，实际这里没有这个文件，文件在解压文件里(ls loganalyzer-4.1.7/contrib/有两个文件)， 可以看到按要求是跑脚本touch一个文件，修改权限，这里手动 touch /var/www/html/log/config.php chmod 666 /var/www/html/log/config.php (必须关闭selinux和防火墙) yum install -y php-gd(安装插件显示图片表格) 最后按照还要将文件修改权限:chmod 644 /var/www/html/log/config.php 存储基础知识—存储网络直接存储(Direct Attached Storage)。存储设备与主机的紧密相连 网络连接存储(Network Attached Storage)：通过局域网在多个文件服务器之间实现了互联，基于文件的协议（ FTP、NFS、SMB/CIFS等 ），实现文件共享 存储区域网络(Storage Area Networks，SAN)利用高速的光纤网络链接服务器与存储设备，基于SCSI，IP，ATM等多种高级协议，实现存储共享 文件传输协议FTPFile Transfer Protocol 早期的三个应用级协议之一基于C/S结构双通道协议：数据和命令连接数据传输格式：二进制（默认）和文本 两种模式：服务器角度 主动(PORT style)：服务器主动连接 命令（控制）：客户端：随机port ---&gt; 服务器：tcp21 数据：客户端：随机port &lt;---服务器：tcp20 被动(PASV style)：客户端主动连接 命令（控制）：客户端：随机port ---&gt; 服务器：tcp21 数据：客户端：随机port ---&gt;服务器：随机port 服务器被动模式数据端口示例： 227 Entering Passive Mode (172,16,0,1,224,59) 服务器数据端口为：224*256+59 vsftpd服务由vsftpd包提供 不再由xinetd管理 用户认证配置文件：/etc/pam.d/vsftpd 服务脚本： /usr/lib/systemd/system/vsftpd.service /etc/rc.d/init.d/vsftpd 配置文件：/etc/vsftpd/vsftpd.conf man 5 vsftpd.conf 格式：option=value 注意：= 前后不要有空格 匿名用户（映射为系统用户ftp ）共享文件位置：/var/ftp 系统用户共享文件位置：用户家目录 虚拟用户共享文件位置：为其映射的系统用户的家目录 vsftpd服务配置命令端口:listen_port=21（更改端口号连接时直接在ip后面加端口号） 主动模式端口: connect_from_port_20=YES 主动模式端口为20 ftp_data_port=20 （默认） 指定主动模式的端口 被动模式端口范围: linux 客户端默认使用被动模式 windows 客户端默认使用主动模式 pasv_min_port=6000 0为随机分配 pasv_max_port=6010 使用当地时间 use_localtime=YES 使用当地时间（默认为NO，使用GMT） 匿名用户anonymous_enable=YES 支持匿名用户 ##默认就支持匿名登录，所以只注释是没有用的。注释还是可以匿名登录。 no_anon_password=YES(默认NO) 匿名用户略过口令检查 anon_world_readable_only (默认YES)只能下载全部读的文件 anon_upload_enable=YES 匿名上传，注意:文件系统权限 anon_mkdir_write_enable=YES 匿名建目录 anon_umask=0333 指定匿名上传文件的umask，默认077 anon_other_write_enable=YES 可删除和修改上传的文件 指定上传文件的默认的所有者和权限 chown_uploads=YES(默认NO) chown_username=wang chown_upload_mode=0644 Linux系统用户 ##（ftp的根不能有写权限，不然无法登陆，这里系统用户登录默认文件夹都在用户的家目录，所以家目录不能拥有w权限 ） local_enable=YES 是否允许linux用户登录 write_enable=YES 允许linux用户上传文件 local_umask=022 指定系统用户上传文件的默认权限 guest_enable=YES 所有系统用户都映射成guest用户 guest_username=ftp 配合上面选项才生效，指定guest用户 local_root=/ftproot guest用户登录所在目录 ##禁锢所有系统用户在家目录中 chroot_local_user=YES（默认NO，不禁锢）禁锢系统用户 ##禁锢或不禁锢特定的系统用户在家目录中，与上面设置功能相反 chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list 当chroot_local_user=YES时，则chroot_list中用户不禁锢 当chroot_local_user=NO时，则chroot_list中用户禁锢 ##chroot_local_user=YES为yes时就是禁锢所有用户，则chroot_list_file=/etc/vsftpd/chroot_list相当于白名单不禁锢 ##chroot_local_user=YES为no时就是不禁锢所有用户，则chroot_list_file=/etc/vsftpd/chroot_list相当于黑名单禁锢 vsftpd服务配置wu-ftp日志：默认启用 xferlog_enable=YES （默认） 启用记录上传下载日志 xferlog_std_format=YES （默认） 使用wu-ftp日志格式 xferlog_file=/var/log/xferlog （默认）可自动生成 vsftpd日志：默认不启用 dual_log_enable=YES 使用vsftpd日志格式，默认不启用 vsftpd_log_file=/var/log/vsftpd.log（默认）可自动生成 登录提示信息 ftpd_banner=“welcome to mage ftp server&quot; banner_file=/etc/vsftpd/ftpbanner.txt 优先上面项生效 目录访问提示信息（进入文件夹后的提示信息，提示信息放在需要访问的文件夹下的隐藏.message下） dirmessage_enable=YES (默认) message_file=.message(默认) 信息存放在指定目录下.message 使用PAM认证1.使用pam(Pluggable Authentication Modules)完成用户认证 pam_service_name=vsftpd pam配置文件:/etc/pam.d/vsftpd /etc/vsftpd/ftpusers 默认文件中用户拒绝登录 vim /etc/pam.d/vsfptd auth required pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpuser 这里deny是拒绝，所以后面的文件是拒绝用户登录。如果是allow，那么就只允许这个文件里面的用户进行登录 ##1和2里面都有控制用户登录的文件，里面都有root用户，只有两个将两个文件都取消以后，root才能登录。 2.是否启用控制用户登录的列表文件 userlist_enable=YES 默认有此设置(在配置文件里面设置) userlist_deny=YES(默认值) 黑名单,不提示口令，NO为白名单 userlist_file=/etc/vsftpd/users_list 此为默认值(用户文件夹) 3.vsftpd服务指定用户身份运行 nopriv_user=nobody (默认值) 4.连接数限制 max_clients=0 最大并发连接数 max_per_ip=0 每个IP同时发起的最大连接数 vsftpd限速配置传输速率：字节/秒 anon_max_rate=0 匿名用户的最大传输速率 local_max_rate=0 本地用户的最大传输速率 连接时间：秒为单位 connect_timeout=60 主动模式数据连接超时时长 accept_timeout=60 被动模式数据连接超时时长 data_connection_timeout=300 数据连接无数据输超时时长 idle_session_timeout=60 无命令操作超时时长 优先以文本方式传输 ascii_upload_enable=YES ascii_download_enable=YES 配置FTP服务以非独立服务方运行-----------------centos6配置ftp非独立方式运行----------- 配置FTP服务以非独立服务方运行 vim /etc/vsftpd/vsftpd.conf/ listen=NO，默认为独立方式 vim /etc/xinetd.d/vsftpd service ftp { flags = REUSE socket_type = stream wait = no user = root server = /usr/sbin/vsftpd log_on_failure += USERID disable = no } 实现基于SSL的FTPS查看是否支持SSL ldd `which vsftpd` 查看到libssl.so 创建自签名证书 cd /etc/pki/tls/certs/ make vsftpd.pem openssl x509 -in vsftpd.pem -noout –text 配置vsftpd服务支持SSL：/etc/vsftpd/vsftpd.conf ssl_enable=YES启用SSL allow_anon_ssl=NO 匿名不支持SSL force_local_logins_ssl=YES 本地用户登录加密 force_local_data_ssl=YES 本地用户数据传输加密 rsa_cert_file=/etc/pki/tls/certs/vsftpd.pem 实验: cd /etc/pki/tls/certs make vsftpd.pem ##生成证书文件和私钥文件 实验接上: mv vsftpd.pem /etc/vsftpd/ssl/ vim /etc/vsftpd/vsftpd.conf ssl_enable=YES allow_anon_ssl=NO force_local_logins_ssl=YES force_local_data_ssl=YES rsa_cert_file=/etc/vsftpd/ssl/vsftpd.pem 然后可以用filezila测试，加密方式选择&quot;要求显示的FTP over TLS&quot; tcpdump -i ens33 -nn -X port 21 抓包，测试，如果不加密可以抓取到密码。现在已经抓不到了 vsftpd虚拟用户虚拟用户： 所有虚拟用户会统一映射为一个指定的系统帐号：访问共享位置，即为此系统帐号的家目录 各虚拟用户可被赋予不同的访问权限，通过匿名用户的权限控制参数进行指定 虚拟用户帐号的存储方式： 文件：编辑文本文件，此文件需要被编码为hash格式 奇数行为用户名，偶数行为密码 db_load -T -t hash -f vusers.txt vusers.db 关系型数据库中的表中： 实时查询数据库完成用户认证 mysql库：pam要依赖于pam-mysql /lib64/security/pam_mysql.so /usr/share/doc/pam_mysql-0.7/README 实现基于文件验证的vsftpd虚拟用户 [root@new vsftpd]# cat vusers.txt user1 centos user2 centos db_load -T -t hash -f vusers.txt vusers.db chmod 600 vusers.db ##给ftp建立一个给虚拟用户用的特有的账号: useradd -d /data/ftproot -s /sbin/nologin -r vuser chown vuser:vuser /data/ftproot/ chmod -w /data/ftproot/ ##记得这里的根目录的写权限要去掉 mkdir /data/ftproot/upload setfacl -m u:vuser:rwx /data/ftproot/upload mkdir /data/ftproot/download ##新建一个pam模块文件 vim /etc/pam.d/vsftpd.db auth required pam_userdb.so db=/etc/vsftpd/vusers ##这里是刚刚生成的vusers.db这个文件，但是这里不用写后缀名。 account required pam_userdb.so db=/etc/vsftpd/vusers ##还要更改vsftpd的配置文件，指定引用的pam文件 vim /etc/vsftpd/vsftpd.conf pam_service_name=vsftpd.db ##改成我们新建的 guest_enable=YES ##所有系统用户都映射成guest用户 ##这两行也要加 guest_username=vuser ##配合上面选项才生效，指定guest用户 虚拟用户建立独立的配置文件vim /etc/vsftpd/vsftpd.conf： user_config_dir=/etc/vsftpd/vusers.d/ ##配置文件的存放路径，写入文件中 cd /etc/vsftpd/vusers.d/ vim user1 ##给user1用户一个配置: anon_upload_enable=YES ##匿名上传 anon_mkdir_write_enable=YES ##匿名新建文件夹 anon_other_write_enable=YES ##匿名修改文件 cd /etc/vsftpd/vusers.d/ vim user2 ##给user2一个单独的文件夹 local_root=/data/ftproot2/ ##让其也拥有三个权限 anon_upload_enable=YES anon_mkdir_write_enable=YES anon_other_write_enable=YES mkdir /data/ftproot2/upload ##创建单独的文件夹 记住总目录都是不可写的 setfacl -m u:vuser:rwx /data/ftproot2/upload ##给其虚拟用户映射到系统用户的对文件夹的权限 实现基于MYSQL验证的vsftpd虚拟用户说明：本实验在两台CentOS主机上实现，一台做为FTP服务器，一台做数据库服务器一、安装所需要包和包组：在数据库服务器上安装包：Centos7：在数据库服务器上安装yum –y install mariadb-serversystemctl start mariadb.servicesystemctl enable mariadbCentos6：在数据库服务器上安装yum –y install mysql-servercentos7所需服务包: pam_mysql-0.7RC1.tar.gz ——Extraction Code:9qnc tar -xvf pam_mysql-0.7RC1.tar.gz yum groupinstall &quot;development tools&quot; -y 安装包组 yum install mariadb-devel pam-devel open-devel ./configure --with-pam-mods-dir=/lib64/security --with-mysql=/usr --with-pam=/usr make &amp;&amp; make install 进入 mysql create databases vsftpd; USE vsftpd; Mysql&gt; SHOW TABLES; mysql&gt; CREATE TABLE users ( id INT AUTO_INCREMENT NOT NULL PRIMARY KEY, name CHAR(50) BINARY NOT NULL, ##binary表示区分大小写 password CHAR(48) BINARY NOT NULL ); insert users (name,password values(&#39;ftp1&#39;,password(&#39;centos&#39;)),(&#39;ftp2&#39;,password(&#39;magedu&#39;)); select * from users; +----+------+-------------------------------------------+ | id | name | password | +----+------+-------------------------------------------+ | 1 | ftp1 | *128977E278358FF80A246B5046F51043A2B1FCED | | 2 | ftp2 | *6B8CCC83799A26CD19D7AD9AEEADBCD30D8A8664 | +----+------+-------------------------------------------+ 2 rows in set (0.00 sec) grant select on vsftpd.users to vsftpd@192.168.67.141 identified by &#39;centos&#39;; ##建立专门的账号来连接数据库 vim /etc/pam.d/vsftpd.mysql ##建立pam文件 auth required pam_mysql.so user=vsftpd passwd=centos host=192.168.67.141 db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2 account required pam_mysql.so user=vsftpd passwd=centos host=192.168.67.141 db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2 vim /etc/vsftpd/vsftpd.conf pam_service_name=vsftpd.mysql ##这里是接了上面的实验，虚拟用户映射的系统用户vuser。 cd /etc/vsftpd/vusers.d/ftp1 ##给虚拟用户单独配置 cat ftp1 anon_upload_enable=YES anon_mkdir_write_enable=YES anon_other_write_enable=YES FTP自动上传下载——shell文件-i:多文件传输过程中关闭交互提示-n:禁止自动登录 #!/bin/bash cd /data/ ##首先进入本机的data目录 ftp -n -i 192.168.67.141 &lt;&lt;! ##登录ftp user ftp1 centos ##用户名 密码 cd f1 ##到这个用户可上传下载的目录 mput *.log ##将本地data文件夹所有的.log结尾的文件传到ftp的f1目录 mget *.txt ##将f1目录上的所有.txt结尾的文件下载下来 bye ##可写可不写 ! ##结束，与上面对应 NFS192.168.67.141: mkdir /data1/nfsdir1 cat /etc/exports ##配置文件，默认是空的 /data1/nfsdir1 *(sync) ##这里只共享了两个目录，*表示所有人 /data1/nfsdir2 * ##sync是默认的，可不写，表示写文件是直接写入磁盘的。不走缓存 exportfs -r ##不用重启服务,即可生效配置文件(但服务必须是起来的) 192.168.67.142: 然后在另外一台机器上查询哪个目录被共享出来了 showmount -e 192.168.67.141 /data1/nfsdir1 * /data1/nfsdir2 * mount 192.168.67.141:/data1/nfsdir1 /nfs1 ##挂在到本机的/nfs1目录下 ##配置权限，上面文件只是挂载，只能访问无法写入。这里先在NFS服务器上配置权限。另外在142机器上进行访问他是以nfsnobody用户进行访问的。所以要给被访问的文件夹加上权限 vim /etc/exports /data1/nfsdir2 *(rw) setfacl -m u:nfsnobody:rwx nfsdir2 ##给文件夹加上允许被nfsnobody用户访问的权限 exportfs -v ##查看服务器端设置的权限配置 这个允许的权限叫root_squash ##现在在客客户端就可以创建文件了。 ##注意现在都是以root用户登录挂载进行创建文件的。只有root登录创建文件才会映射为nobody用户 如果是以普通用户登录创建文件只会映射到服务器ID相同的人。 192.168.67.142: [pan@pan nfs2]$ ll b.txt ##登录的pan用户，创建的b.txt文件 -rw-rw-r-- 1 pan pan 0 2月 13 17:20 b.txt [pan@pan nfs2]$ getent passwd pan ##id是1000 pan:x:1000:1000::/home/pan:/bin/bash 192.168.67.141: [root@new nfsdir2]# ll ##可以看到b.txt的id是1000，141没有id为1000的用户 总用量 0 -rw-r--r--. 1 nfsnobody nfsnobody 0 2月 13 16:52 a.txt -rw-rw-r--. 1 1000 1000 0 2月 13 17:20 b.txt [root@new nfsdir2]# vim /etc/exports /data1/nfsdir1 * /data1/nfsdir2 *(rw,no_root_squash) ##这个就表示远程的服务器上root创建的文件，服务器上显示的也是root用户 ##root用户不映射为其他的用户 [root@new nfsdir2]# exportfs -r ##重新读取配置文件 [root@new nfsdir2]# exportfs -v ##查看权限 /data1/nfsdir1 &lt;world&gt;(ro,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash) /data1/nfsdir2 &lt;world&gt;(rw,sync,wdelay,hide,no_subtree_check,sec=sys,secure,no_root_squash,no_all_squash) NFS配置文件每个条目指定目录导出到的哪些主机，及相关的权限和选项 •默认选项：(ro,sync,root_squash,no_all_squash) •ro,rw 只读和读写 •async 异步，数据变化后不立即写磁盘，性能高 •sync（1.0.0后为默认）同步，数据在请求时立即写入共享 •no_all_squash （默认）保留共享文件的UID和GID •all_squash 所有远程用户(包括root)都变成nfsnobody •root_squash （默认）远程root映射为nfsnobody,UID为65534，早期版本是4294967294 (nfsnobody) •no_root_squash 远程root映射成root用户 •anonuid和anongid 指明匿名用户映射为特定用户UID和组GID，而非nfsnobody,可配合all_squash使用 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Four]]></title>
    <url>%2F2019%2F07%2F26%2FLinux%E5%90%8E%E6%9C%9F%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[linux 理论知识点 修改开机自启ntsysv图形界面 可查看开机自启的服务。*号表示服务开机自动启动。例：查看当前运行模式runlevel 比如说是runlevel=5。 这里服务以atd为例进入这个文件夹:cd /etc/rc5.d查看当前文件夹下的服务可以看到开启自动启动的服务是以S开头的’S95atd’当我们使用netsysv这个工具将atd前面的*号去掉时，再回来查看这里的atd服务就是以K开头的’K05atd’而且这里的开机自启服务都是软链接，所以可以手工 rm -fr K05atd ln -s ../init.d/atd(原始路径) S95atd ntsysv 这个工具只能修改当前运行级别的自启服务。如果想要修改其他的运行级别的 cd /etc/rc3.d/ ntsysv --level 3 去掉*号以后，回到文件夹下查看 已经没有S05atd变成了K05atd chkconfigchkconfig --level 13 atd on 将1和3模式下的atd服务变为开机自启chkconfig --list atd 查看atd服务chkconfig atd on 默认开启2345模式下的atd服务编写服务脚本 #!/bin/bash #chkconfig: 35 96 03 #35那里如果是 - 那就表示默认所有模式都是off #服务脚本的特殊格式，35表示启动的模式 runlevel,96表示启动，96表示S开头的开机自启动，03表示K开头的不自启动.后启动，先关。 #descriptaion: test service . /etc/init.d/functions case $1 in start) touch /var/lock/subsys/testsrv action &quot;staring testsrv&quot; true ;; stop) rm -f /var/lock/subsys/testsrv action &quot;stoping testsrv&quot; true ;; restart) action &quot;staring testsrv&quot; true action &quot;stoping testsrv&quot; true ;; status) if [ -f /var/lock/subsys/testsrv ];then echo testsrv is running... else echo testsrv is stopped fi ;; *) echo Usage: /etc/init.d/testsrv {start|stop|restart|status} esac xinetd管理的服务安装:yum install -y telnet-serverservice 命令：手动管理服务service 服务 start|stop|restart service –status-all瞬态（Transient）服务被xinetd进程所管理进入的请求首先被xinetd代理配置文件：/etc/xinetd.conf、/etc/xinetd.d/&lt;service&gt;与libwrap.so文件链接用chkconfig控制的服务：示例：chkconfig tftp on安装服务以后，chkconfig –list 查看 xinetd based services: chargen-dgram: off # off 表示这个服务不能被xinetd唤醒 chargen-stream: off daytime-dgram: off daytime-stream: off discard-dgram: off discard-stream: off echo-dgram: off echo-stream: off rsync: off tcpmux-server: off telnet: off time-dgram: off time-stream: off [root@centos6 init.d]# vim /etc/xinetd.d/telnet 需要到配置文件下去修改 # default: on # description: The telnet server serves telnet sessions; it uses \ # unencrypted username/password pairs for authentication. service telnet { flags = REUSE socket_type = stream wait = no user = root server = /usr/sbin/in.telnetd log_on_failure += USERID disable = no 这里的yes改为no } 还可用命令更改chkconfig telnet on/off 注意：正常级别下，最后启动一个服务S99local没有链接至/etc/rc.d/init.d一个服务脚本，而是指向了/etc/rc.d/rc.local脚本不便或不需写为服务脚本放置于/etc/rc.d/init.d/目录，且又想开机时自动运行的命令，可直接放置于/etc/rc.d/rc.local文件中/etc/rc.d/rc.local在指定运行级别脚本后运行可以根据情况，进行自定义修改 centos6启动流程postmbr grub stagel stagel.5grub stage2 /boot/grub/grub.confvmlinuz root= iniramfs.img/sbin/init/etc/inittab/etc/rc.d/rc.sysinit/etc/rcN.d/K S/etc/rc.d/rc.locallogin CentOS 6启动流程：POST –&gt; Boot Sequence(BIOS) –&gt; Boot Loader –&gt; Kernel(ramdisk) –&gt; rootfs –&gt; switchroot –&gt; /sbin/init –&gt;(/etc/inittab, /etc/init/*.conf) –&gt; 设定默认运行级别 –&gt; 系统初始化脚本rc.sysinit –&gt; 关闭或启动对应级别的服务 –&gt; 启动终端参看：http://s4.51cto.com/wyfs02/M02/87/20/wKiom1fVBELjXsvaAAUkuL83t2Q304.jpg grub修复1hexdump -C /dev/sda -n 512dd if=/dev/zero of=/dev/sda bs=1 count=446 破坏前446个字节reboot进入光盘修复grub-install这个工具需要到/sbin/grub，ls /mnt/sysimage/sbin/grub所以要切根目录chroot /mnt/sysimage/grub-install /dev/sdahexdupm -C /dev/sda -n 512 查看已经修复成功sync 同步 grub修复2grub&gt; root (hd0,0) #第一个0表示第一个硬盘，第二个零表示第一个分区就代表/dev/sda,这里的表示方法不同。grub&gt; setup (hd0) #表示我要把446个字节写在那个硬盘上。现在修复完成，但是这个命令有依赖性，他依赖于/boot/grub下的若干文件。 ls /boot/grub下 默认只有grub.conf这一个文件是重要的，但是修复以后所产生的文件就都是必要的了。grub.conf这个是gurb的配置文件 vim /boot/grub/grub.conf default=1 #指第一个title timeout=5 password centos #这里是给进入单用户加一个密码centos，若是加了，想要进单用户，没有密码，就无法进入。 password --md5 加密口令 #还可以使用md5加密方式 grub-md5-crypt password --encrypted $6$GVDpx3mdjq27eWWy$lZubXA/VXZgyJhaQzH/rX.pfttIxObIIdBkxjHHm/nRA4H4Z/h3oD5Yo80wGwfpYMyjG6UL7R1W55oSXxzK dB. #这里用的是加密的密码还是centos.方法:r!grub-crypt splashimage=(hd0,0)/grub/splash.xpm.gz #这里就是启动的背景图片，更换见下方详解。最后一步在这里更改图片name hiddenmenu title CentOS 6 (2.6.32-754.el6.x86_64) root (hd0,0) kernel /vmlinuz-2.6.32-754.el6.x86_64 ro root=UUID=c9ab54fa-2650-4363-bc37-fca60e23e8d0 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /initramfs-2.6.32-754.el6.x86_64.img title CentOS 8 (4.6.32-754.el6.x86_64)#假设 #添加的启动菜单 root (hd0,0) kernel /vmlinuz-2.6.32-754.el6.x86_64 ro root=UUID=c9ab54fa-2650-4363-bc37-fca60e23e8d0 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /initramfs-2.6.32-754.el6.x86_64.img #grub 认为boot才是根目录，下面可以写成这种形式.就是对于vmlinux-这个文件来讲，这个文件在第一个硬盘第一个分区里面，对应boot这个目录 kernel (hd0,0)/vmlinuz-2.6.32-754.el6.x86_64 ro root=UUID=c9ab54fa-2650-4363-bc37-fca60e23e8d0 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd (hd0,0)/initramfs-2.6.32-754.el6.x86_64.img #此文件加载根分区，加载文件驱动，不能和内核文件对调 [root@centos6 grub]# 启动背景更换CentOS6.5安装rz和sz命令一条命令就行 yum install -y lrzsz用rz将图片传入linx，还需更改格式linux 图片png转xpm工具which convert 查看命令的路径rpm -qf /usr/bin/convert 查看命令来自哪一个包 yum install -y ImageMagick 包名 convert -resize 640x480 -colors 14 2019.png win.xpm gzip win.xpm 还要将图片压缩成gz，然后移动到/boot/grub然后去文件中更改图片名。 rm -fr /boot/grub/grub.conf临时修复:写入文件: [root@centos6 grub]# cat grub.conf default=0 timeout=3 title pan #:r!ls /boot/initramfs-2.6.32-754.el6.x86_64.img /boot/vmlinuz-2.6.32-754.el6.x86_64 kernel /vmlinuz-2.6.32-754.el6.x86_64 root=/dev/sda2 initrd /initramfs-2.6.32-754.el6.x86_64.img rm -fr /boot/* sync 写入文件 ls /mnt/sysimage/boot 查看没有grub chroot /mnt/sysimage grub-install /dev/sda 修复grub vim /boot/grub/grub.conf 修复grub目录后，grub.conf需要自己建立 defaule=0 timeout=3 title=linux vmlinuz-2.6.32-754.el6.x86_64 kernel /vmlinuz-2.6.32-754.el6.x86_64 ro root=/dev/sda2 initrd /initramfs-2.6.32-754.el6.x86_64.img vim /etc/selinux/config SELINUX=disable mv /etc/fstab和rm -fr /boot进入救援模式fdisk -l 查看当前的硬盘找到根目录，然后挂载 mount /dev/sda2 /mnt/rootfsvi /mnt/rootfs/etc/fstab 恢复这个文件重启后再次进去救援模式，可以找到了，后面还需修复grub等。 模块rmmod e1000modprobe e1000 自制linux系统[root@centos6 ~]# fdisk -l /dev/sdb 1.增加一块20G的硬盘分区 Disk /dev/sdb: 21.5 GB, 21474836480 bytes 255 heads, 63 sectors/track, 2610 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0xe03fcc2f Device Boot Start End Blocks Id System /dev/sdb1 1 132 1060258+ 83 Linux /dev/sdb2 133 1438 10490445 83 Linux /dev/sdb3 1439 1700 2104515 82 Linux swap / Solaris [root@centos6 ~]# mkfs.ext4 /dev/sdb1 2.创建文件系统 [root@centos6 ~]# mkfs.ext4 /dev/sdb2 [root@centos6 ~]# mkswap /dev/sdb3 [root@centos6 ~]# blkid /dev/sda1: UUID=&quot;018d560c-cf34-426f-9255-3644809c9cd1&quot; TYPE=&quot;ext4&quot; /dev/sda2: UUID=&quot;c9ab54fa-2650-4363-bc37-fca60e23e8d0&quot; TYPE=&quot;ext4&quot; /dev/sda3: UUID=&quot;c818ec58-ff08-4350-a41b-3016ec7caf4e&quot; TYPE=&quot;ext4&quot; /dev/sda5: UUID=&quot;6e3af40a-8892-474c-a76f-597954888c62&quot; TYPE=&quot;swap&quot; /dev/sdb2: UUID=&quot;e6089c91-2ce4-429e-bcbd-cbd407bdeb33&quot; TYPE=&quot;ext4&quot; 关注/dev/sdb /dev/sdb3: UUID=&quot;fcb6440e-d22f-4b96-947a-0b984705c5a6&quot; TYPE=&quot;swap&quot; /dev/sdb1: UUID=&quot;27501ae9-4d2b-4a36-ade5-659bc74e27b9&quot; TYPE=&quot;ext4&quot; [root@centos6 ~]# mkdir /mnt/boot 3.创建挂载点并挂载 [root@centos6 ~]# mount /dev/sdb1 /mnt/boot [root@centos6 ~]# ls /mnt/boot lost+found 4.安装grub,表示我要把grub的内容放到哪个/boot的grub,这里只需指定/mnt,他会自动寻找/mnt下的/boot [root@centos6 ~]# grub-install --root-directory=/mnt /dev/sdb 5.复制/boot下的文件 [root@centos6 ~]# cp /boot/initramfs-2.6.32-754.el6.x86_64.img /mnt/boot/initramfs.img [root@centos6 ~]# cp /boot/vmlinuz-2.6.32-754.el6.x86_64 /mnt/boot/vmliinux [root@centos6 ~]# ls /mnt/boot 拷贝两个文件，这两个文件也是必须有的 grub initramfs.img lost+found vmliinux [root@centos6 ~]# vim /mnt/boot/grub/grub.conf 6.编辑文件grub.conf default=0 timeout=3 title linux kernel /vmlinuz root=/dev/sda2 selinux=0 init=/bin/bash #启动的时候，这里默认就会寻找init=/sbin/init 这个程序，这个程序又会寻找各种配置文件，所以这里改成bash initrd /initramfs.img [root@centos6 ~]# mount /dev/sdb2 /media/ # 7./dev/sdb2 把根分区，临时挂到一个目录上 [root@centos6 ~]# mkdir /media/{etc,dev,proc,sys,usr,var,tmp,mnt,lib,lib64,sbin,bin} -p #创建根目录下应该有的文件 [root@centos6 ~]# vim copycmd.sh #8. 编辑复制代码程序，此文件的作用是拷贝命令和命令依赖的库到/mnt/sdb2/media/ #!/bin/bash ch_root=&quot;/media/&quot; #根目录 [ ! -d $ch_root ] &amp;&amp; mkdir $ch_root bincopy() { if which $1 &amp;&gt;/dev/null; then local cmd_path=`which --skip-alias $1` local bin_dir=`dirname $cmd_path` [ -d ${ch_root}${bin_dir} ] || mkdir -p ${ch_root}${bin_dir} [ -f ${ch_root}${cmd_path} ] || cp $cmd_path ${ch_root}${bin_dir} return 0 else echo &quot;Command not found.&quot; return 1 fi } libcopy() { local lib_list=$(ldd `which --skip-alias $1` | grep -Eo &#39;/[^[:space:]]+&#39;) for loop in $lib_list;do local lib_dir=`dirname $loop` [ -d ${ch_root}${lib_dir} ] || mkdir -p ${ch_root}${lib_dir} [ -f ${ch_root}${loop} ] || cp $loop ${ch_root}${lib_dir} done } read -p &quot;Please input a command: &quot; command while [ &quot;$command&quot; != &quot;quit&quot; ];do if bincopy $command ;then libcopy $command fi read -p &quot;Please input a command or quit: &quot; command done [root@centos6 ~]# bash copycmd.sh Please input a command: bash please input a command or quit: modprobe please input a command or quit: insmod please input a command or quit: ifconfig please input a command or quit: ls please input a command or quit: mount please input a command or quit: cp please input a command or quit: ping please input a command or quit: cat please input a command or quit: vim please input a command or quit: df please input a command or quit: blkid please input a command or quit: cp please input a command or quit: mv please input a command or quit: rm please input a command or quit: quit ...... [root@centos6 ~]# tree /media/ locate e1000 查看网卡驱动 [root@centos6 ~]# cp /lib/modules/2.6.32-754.el6.x86_64/kernel/drivers/net/e1000/e1000.ko /media/lib/ 拷贝 [root@centos6 ~]# chroot /media/ proc 目录cat /proc/sys/net/ipv4/ip_forward 这个文件里面的配置参数都可以放在sysctl.con 里面sysctl命令：默认配置文件：/etc/sysctl.conf(1)设置某参数 sysctl -w parameter=VALUE(2)通过读取配置文件设置参数 sysctl -p [/path/to/conf_file](3)查看所有生效参数 sysctl -a [root@centos6 ~]# cat /proc/sys/vm/drop_caches 0 #0代表保留缓存数据 [root@centos6 ~]# echo 1 &gt;/proc/sys/vm/drop_caches #会立即清理缓存 [root@centos6 ~]# free -h #可以清晰的看到cached对比之前没有清理过的下降了很多 [root@centos6 ~]# echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all [root@centos6 ~]# cat /proc/sys/net/ipv4/icmp_echo_ignore_all 1 #这里改成1会禁ping 想要保存需要写到文件/etc/sysctl.conf [root@centos6 ~]# vim /etc/sysctl.conf 1 # Kernel sysctl configuration file for Red Hat Linux 2 # 3 # For binary values, 0 is disabled, 1 is enabled. See sysctl(8) and 4 # sysctl.conf(5) for more details. 5 # 6 # Use &#39;/sbin/sysctl -a&#39; to list all possible parameters. 7 8 # Controls IP packet forwarding 9 net.ipv4.ip_forward = 0 10 net.ipv4.icmp_echo_ignore_all = 1 #这里是我添加的一行，这里的格式要用点区分开.他和文件目录是对应的关系，sysctl管理的就是/proc/sys/目录下的文件，所以前面就不用写了。 保存退出以后还没有生效使用sysctl -p 这里注意: -p的作用是读取这个文件到内存中，如果读取到内存中发现是冲突的，那就拿文件覆盖到内存中，如果没有就保留原状态。 所以这里如果禁止了ping，之后只是删除了文件加上sysctl -p这样是无法产生效果的，之前ping不通现在还是ping不通。 这里重启可以。 sysctl -a 查看所有生效的参数 /sys目录：sysfs：为用户使用的伪文件系统，输出内核识别出的各硬件设备的相关属性信息，也有内核对硬件特性的设定信息；有些参数是可以修改的，用于调整硬件工作特性udev通过此路径下输出的信息动态为各设备创建所需要设备文件，udev是运行用户空间程序专用工具：udevadmin, hotplugudev为设备创建设备文件时，会读取其事先定义好的规则文件，一般在/etc/udev/rules.d及/usr/lib/udev/rules.d目录下 内核编译单内核体系设计、但充分借鉴了微内核设计体系的优点，为内核引入模块化机制内核组成部分：kernel：内核核心，一般为bzImage，通常在/boot目录下名称为 vmlinuz-VERSION-RELEASE kernel object：内核对象，一般放置于/lib/modules/VERSION-RELEASE/[ ]: N #不启用[M]: M #放到/lib/modules 以模块方式存放[*]: Y #放到核心里面 启用辅助文件：ramdiskinitrdinitramfs lsmod命令：显示由核心已经装载的内核模块显示的内容来自于: /proc/modules文件modinfo命令：显示模块的详细描述信息modinfo [ -k kernel ] [ modulename|filename… ]-n：只显示模块文件路径-p：显示模块参数-a：作者-d：描述示例：lsmod |grep xfs modinfo -n xfs 内核模块管理modprobe命令：装载或卸载内核模块modprobe [ -C config-file ] [ modulename ] [ module parame-ters… ]modprobe [ -r ] modulename… 卸载模块配置文件：/etc/modprobe.conf 存放硬件加载的各种模块, /etc/modprobe.d/*.conf 内核模块管理depmod命令：内核模块依赖关系文件及系统信息映射文件的生成工具装载或卸载内核模块：insmod命令：指定模块文件，不自动解决依赖模块 insmod [ filename ] [ module options… ]insmod modinfo –n exportfslnsmod modinfo –n xfsrmmod命令：卸载模块rmmod [ modulename ]rmmod xfsrmmod exportfs 内核编译rz tar -xvf linux-4.18.13.tar.xz cp /boot/config-3.10.0-862.el7.x86_64 linux-5.2.7/.config [root@centos7 \~]# cd linux-5.2.7/ [root@centos7 \~]# make menuconfig:配置内核选项 这里还需要装一些软件包，不然无法使用。 yum groupinstall &quot;development tools&quot; [root@centos7 \~]# yum install -y ncurses-devel 根据提示装所缺少的包 [root@centos7 \~]# make menuconfig:软件包装完后再配置内核选项 [root@centos7 linux-4.18.13]# make -j 4 &amp;&amp; { echo -e &#39;\a&#39; ;sleep 0.5;echo -e &#39;\a&#39;;} yum install -y openssl-devel 继续安装缺少的包 [root@centos7 linux-4.18.13]# make -j 4 &amp;&amp; { echo -e &#39;\a&#39; ;sleep 0.5;echo -e &#39;\a&#39;;} jobs=4，同时最多跑4个作业 make自己会协调，如果CPU等资源不够可能小于4个。不过一般瓶颈都在硬盘，所以一般能看到4个进程一起跑。 centos7systemdPOST –&gt; Boot Sequence –&gt; Bootloader –&gt; kernel + initramfs(initrd) – &gt; rootfs –&gt; /sbin/initinit:CentOS 5 SysV initCentOS 6 UpstartCentOS 7 SystemdSystemd：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其它进程Systemd新特性系统引导时实现服务并行启动按需启动守护进程自动化的服务依赖关系管理同时采用socket式与D-Bus总线式激活服务系统状态快照 管理服务管理系统服务：CentOS 7: service unit注意：能兼容早期的服务脚本命令：systemctl COMMAND name.service启动：service name start ==&gt; systemctl start name.service停止：service name stop ==&gt; systemctl stop name.service重启：service name restart ==&gt; systemctl restart name.service状态：service name status ==&gt; systemctl status name.service 管理服务条件式重启：已启动才重启，否则不做操作service name condrestart ==&gt; systemctl try-restart name.service重载或重启服务：先加载，再启动systemctl reload-or-restart name.service重载或条件式重启服务：systemctl reload-or-try-restart name.service禁止自动和手动启动：systemctl mask name.service 他的作用就是创建了一个软链接，也可以手动创建，用法相同。ln -s /dev/null /etc/systemd/system/httpd.service取消禁止：systemctl unmask name.service systemctl is-enabled httpd 查看httpd是否开机启动 systemctl is-active 查看httpd现在的状态 服务查看查看某服务当前激活与否的状态： systemctl is-active name.service查看所有已经激活的服务：systemctl list-units --type|-t service查看所有服务：systemctl list-units --type service --all|-achkconfig命令的对应关系：设定某服务开机自启：chkconfig name on ==&gt; systemctl enable name.service设定某服务开机禁止启动：chkconfig name off ==&gt; systemctl disable name.service 服务查看查看所有服务的开机自启状态： chkconfig --list ==&gt; systemctl list-unit-files --type service用来列出该服务在哪些运行级别下启用和禁用 chkconfig sshd –list ==&gt; ls /etc/systemd/system/\*.wants/sshd.service查看服务是否开机自启：systemctl is-enabled name.service其它命令：查看服务的依赖关系：systemctl list-dependencies name.service杀掉进程：systemctl kill unitname 服务状态loaded Unit配置文件已处理active(running) 一次或多次持续处理的运行active(exited) 成功完成一次性的配置active(waiting) 运行中，等待一个事件inactive 不运行enabled 开机启动disabled 开机不启动static开机不启动，但可被另一个启用的服务激活 systemctl 命令示例显示所有单元状态 systemctl 或 systemctl list-units 只显示服务单元的状态 systemctl --type=service 显示sshd服务单元 systemctl –l status sshd.service 验证sshd服务当前是否活动 systemctl is-active sshd 启动，停止和重启sshd服务 systemctl start sshd.service systemctl stop sshd.service systemctl restart sshd.service 示例1重新加载配置 systemctl reload sshd.service 列出活动状态的所有服务单元 systemctl list-units --type=service 列出所有服务单元 systemctl list-units --type=service --all 查看服务单元的启用和禁用状态 systemctl list-unit-files --type=service 列出失败的服务 systemctl --failed --type=service 示例2列出依赖的单元 systemctl list-dependencies sshd 验证sshd服务是否开机启动 systemctl is-enabled sshd 禁用network，使之不能自动启动,但手动可以 systemctl disable network 启用network systemctl enable network 禁用network，使之不能手动或自动启动 systemctl mask network 启用network systemctl unmask network service unit文件格式/etc/systemd/system：系统管理员和用户使用/usr/lib/systemd/system：发行版打包者使用以 “#” 开头的行后面的内容会被认为是注释相关布尔值，1、yes、on、true 都是开启，0、no、off、false 都是关闭时间单位默认是秒，所以要用毫秒（ms）分钟（m）等须显式说明service unit file文件通常由三部分组成：[Unit]：定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等[Service]：与特定类型相关的专用选项；此处为Service类型[Install]：定义由“systemctl enable”以及”systemctl disable“命令在实现服务启用或禁用时用到的一些选项 service unit文件格式Unit段的常用选项：Description：描述信息After：定义unit的启动次序，表示当前unit应该晚于哪些unit启动，其功能与Before相反Requires：依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit也无法激活Wants：依赖到的其它units，弱依赖Conflicts：定义units间的冲突关系 service unit文件格式Service段的常用选项：Type：定义影响ExecStart及相关参数的功能的unit进程启动类型simple：默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务。原生父程序在启动结束后就会终止oneshot：与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中dbus：与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作.因此通常也要同时设定BusNname= 才行notify：在启动完成后会发送一个通知消息。还需要配合 NotifyAccess 来让Systemd 接收消息idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务 EnvironmentFile：环境配置文件ExecStart：指明启动unit要运行命令或脚本的绝对路径ExecStartPre： ExecStart前运行ExecStartPost： ExecStart后运行ExecStop：指明停止unit要运行的命令或脚本Restart：当设定Restart=1 时，则当次daemon服务意外终止后，会再次自动启动此服务 service unit文件格式Install段的常用选项：Alias：别名，可使用systemctl command Alias.serviceRequiredBy：被哪些units所依赖，强依赖WantedBy：被哪些units所依赖，弱依赖Also：安装本服务的时候还要安装别的相关服务注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载此配置文件,而后可以选择重启systemctl daemon-reload 服务Unit文件示例：[root@centos7 system]# cat /lib/systemd/system/bak.service [Unit] Description=backup /etc Requires=atd.service [Service] Type=simple ExecStart=/bin/bash -c &quot;echo /data/bak.sh|at now&quot; [Install] WantedBy=multi-user.target [root@centos7 system]# cat /data/bak.sh tar cvf /data/etc-`date + %F`.tar /etc/ &amp;&gt; /dev/null [root@centos7 system]# chmod +x !$ [root@centos7 system]# systemctl daemon-reload [root@centos7 system]# systemctl list-units -t service -a|grep bak [root@centos7 system]# systemctl list-unit-files [root@centos7 system]#systemctl start bak 运行级别target units：unit配置文件：.targetls /usr/lib/systemd/system/*.target systemctl list-unit-files –type target –all运行级别：0 ==&gt; runlevel0.target, poweroff.target1 ==&gt; runlevel1.target, rescue.target2 ==&gt; runlevel2.target, multi-user.target3 ==&gt; runlevel3.target, multi-user.target4 ==&gt; runlevel4.target, multi-user.target5 ==&gt; runlevel5.target, graphical.target6 ==&gt; runlevel6.target, reboot.target查看依赖性：systemctl list-dependencies graphical.target 运行级别级别切换：init N ==&gt; systemctl isolate name.targetsystemctl isolate multi-user.target注：只有/lib/systemd/system/*.target文件中AllowIsolate=yes 才能切换(修改文件需执行systemctl daemon-reload才能生效)查看target： runlevel ;who -rsystemctl list-units –type target获取默认运行级别：/etc/inittab ==&gt; systemctl get-default修改默认级别：/etc/inittab ==&gt; systemctl set-default name.target systemctl set-default multi-user.targetls –l /etc/systemd/system/default.target ln -s /usr/lib/systemd/system/graphical.target /etc/systemd/system/default.target 就是修改了一个软链接 其它命令切换至紧急救援模式： systemctl rescue切换至emergency模式： systemctl emergency其它常用命令：传统命令init，poweroff，halt，reboot都成为systemctl的软链接关机：systemctl halt、systemctl poweroff重启：systemctl reboot挂起：systemctl suspend休眠：systemctl hibernate休眠并挂起：systemctl hybrid-sleep CentOS7引导顺序UEFi或BIOS初始化，运行POST开机自检选择启动设备引导装载程序, centos7是grub2加载装载程序的配置文件：/etc/grub.d//etc/default/grub/boot/grub2/grub.cfg加载initramfs驱动模块加载内核选项内核初始化，centos7使用systemd代替init执行initrd.target所有单元，包括挂载/etc/fstab从initramfs根文件系统切换到磁盘根目录systemd执行默认target配置，配置文件/etc/systemd/system/default.target CentOS7引导顺序systemd执行sysinit.target初始化系统及basic.target准备操作系统systemd启动multi-user.target下的本机与服务器服务systemd执行multi-user.target下的/etc/rc.d/rc.localSystemd执行multi-user.target下的getty.target及登录服务systemd执行graphical需要的服务 无限重启 systemctl set-default reboot.target在Linux16后面添加 systemd.unit=multi-user.target查看 systemctl get-default修改 systemctl ser-default graphical.targer 破解CentOS7的root口令方法一启动时任意键暂停启动按e键进入编辑模式将光标移动linux16开始的行，添加内核参数rd.break按ctrl-x启动mount –o remount,rw /sysrootchroot /sysrootpasswd roottouch /.autorelabel 针对SELINUXexitreboot 破解CentOS7的root口令方法二启动时任意键暂停启动按e键进入编辑模式将光标移动linux16开始的行，改为rw init=/sysroot/bin/sh按ctrl-x启动chroot /sysrootpasswd roottouch /.autorelabelexitreboot 修复修复/boot: chroot /mnt/sysimagemount /dev/sr0 /mntrpm -ivh /mnt/Packages/Kernel-3.10.0-862.e17.x86_64.rpm –force修复/grub:grub2-mkconfig -o /boot/grub2/grub.cfg SElinuxDAC：Discretionary Access Control自由访问控制MAC：Mandatory Access Control 强制访问控制DAC环境下进程是无束缚的MAC环境下策略的规则决定控制的严格程度MAC环境下进程可以被限制的策略被用来定义被限制的进程能够使用那些资源（文件和端口）默认情况下，没有被明确允许的行为将被拒绝 SELinux策略对象(object)：所有可以读取的对象，包括文件、目录和进程，端口等主体：进程称为主体(subject)SELinux中对所有的文件都赋予一个type的文件类型标签，对于所有的进程也赋予各自的一个domain的标签。domain标签能够执行的操作由安全策略里定义当一个subject试图访问一个object，Kernel中的策略执行服务器将检查AVC (访问矢量缓存Access Vector Cache), 在AVC中，subject和object的权限被缓存(cached)，查找“应用+文件”的安全环境。然后根据查询结果允许或拒绝访问安全策略：定义主体读取对象的规则数据库，规则中记录了哪个类型的主体使用哪个方法读取哪一个对象是允许还是拒绝的，并且定义了哪种行为是充许或拒绝 SELinux工作类型SELinux有四种工作类型：Strict：CentOS 5,每个进程都受到selinux的控制targeted：用来保护常见的网络服务,仅有限进程受到selinux控制，只监控容易被入侵的进程，CentOS 4只保护13个服务，CentOS 5保护88个服务minimum：CentOS 7,修改的 targeted，只对选择的网络服务mls：提供MLS（多级安全）机制的安全性targeted为默认类型，minimum和mls稳定性不足，未加以应用，strict已不再使用 SELinux安全上下文传统Linux，一切皆文件，由用户，组，权限控制访问在SELinux中，一切皆对象（object），由存放在inode的扩展属性域的安全元素所控制其访问所有文件和端口资源和进程都具备安全标签：安全上下文（security context）安全上下文有五个元素组成：user:role:type:sensitivity:categoryuser_u:object_r:tmp_t:s0:c0实际上下文：存放在文件系统中，ls –Z;ps –Z期望(默认)上下文：存放在二进制的SELinux策略库（映射目录和期望安全上下文）中semanage fcontext –l 五个安全元素User：指示登录系统的用户类型,进程：如system_u为系统服务进程，是受到管制的，unconfined_u为不管制的进程，用户自己开启的，如 bash，文件：system_u系统进程创建的文件， unconfined_u为用户自已创建的文件 Role：定义文件，进程和用户的用途：进程：system_r为系统服务进程，受到管制。unconfined_r 为不管制进程，通常都是用户自己开启的，如 bash，文件:object_r Type：指定数据类型，规则中定义何种进程类型访问何种文件Target策略基于type实现,多服务共用：public_content_t Sensitivity：限制访问的需要，由组织定义的分层安全级别，如 unclassified,secret,top,secret, 一个对象有且只有一个sensitivity,分0-15级，s0最低,Target策略默认使用s0 Category：对于特定组织划分不分层的分类，如FBI Secret，NSA secret, 一个对象可以有多个categroy， c0-c1023共1024个分类， Target 策略不使用 category [root@centos7 ~]# setenforce 0 [root@centos7 ~]# getenforce selinux Permissive [root@centos7 ~]# setenforce 1 [root@centos7 ~]# getenforce selinux Enforcing 禁用可以在/boot/grub2/grub.cfg linux16末尾加上: selinux=0查看selinux的状态还可以用sestatus 配置SELinux相关命令：getenforce: 获取selinux当前状态sestatus :查看selinux状态setenforce 0|10: 设置为permissive1: 设置为enforcing配置文件:/boot/grub/grub.conf 在kernel行使用selinux=0禁用SELinux/boot/grub2/grub.cfg 在linux16行使用selinux=0禁用SELinux/etc/selinux/config/etc/sysconfig/selinuxSELINUX={disabled|enforcing|permissive} [root@centos7 ~]# ll -Z /var/log/messages 源文件 -rw-------. root root system_u:object_r:var_log_t:s0 /var/log/messages [root@centos7 ~]# cp /var/log/messages /root 复制以后的文件 [root@centos7 ~]# ll -Z /root/messages 查看属性，可以看到已经有了变化 -rw-------. root root unconfined_u:object_r:admin_home_t:s0 /root/messages [root@centos7 ~]# mv /root/messages /var/log/messages 即便移动回去属性也已经被破坏了，而且日志也无法记录了 mv: overwrite ‘/var/log/messages’? y [root@centos7 ~]# ll -Z /var/log/messages -rw-------. root root unconfined_u:object_r:admin_home_t:s0 /var/log/messages [root@centos7 ~]# semanage fcontext -l | grep &quot;/var/log/messages&quot; 查找数据库里面的文件原有类型 /var/log/messages[^/]* all files system_u:object_r:var_log_t:s0 [root@centos7 ~]# chcon -t var_log_t /var/log/messages [root@centos7 ~]# ll /var/log/messages -Z -rw-------. root root unconfined_u:object_r:var_log_t:s0 /var/log/messages systemctl restart rsyslog 重启日志服务 [root@centos7 ~]# chcon -t default_t /var/log/messages [root@centos7 ~]# ll -Z /var/log/messages -rw-------. root root unconfined_u:object_r:default_t:s0 /var/log/messages [root@centos7 ~]# restorecon /var/log/messages 这样也可以还原 [root@centos7 ~]# ll !$ -Z ll /var/log/messages -Z -rw-------. root root unconfined_u:object_r:var_log_t:s0 /var/log/messages 现在重启日志服务后可以记录了 [root@centos7 ~]# ll -d /var/www/html/index.html -Z -rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 /var/www/html/index.html [root@centos7 ~]# chcon -t var_log_t /var/www/html/index.html -rw-r--r--. root root unconfined_u:object_r:var_log_t:s0 /var/www/html/index.html [root@centos7 ~]# semanage fcontext -a -t httpd_sys_content_t &quot;/data/www(/.*)?&quot; 将没有的加入数据库 [root@centos7 ~]# semanage fcontext -l | grep &quot;/data/www&quot; 现在查看有了 /data/www(/.*)? all files system_u:object_r:httpd_sys_content_t:s0 [root@centos7 ~]# restorecon -R /data/www [root@centos7 ~]# ll -dZ /data/www/index.html -rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 /data/www/index.html [root@centos7 ~]# semanage fcontext -d -t httpd_sys_content_t &quot;/data/www(/.*)?&quot; 服务更改端口后报错，是因为服务的端口没有加入查询服务所能用的端口semanage port -l | grep httpsemanage port -a -t httpd_port_t -p tcp 9527 添加一个tcp端口9527，现在使用semanage就可以查看到了 默认安全上下文查询与修改semanage：来自policycoreutils-python包查看默认的安全上下文semanage fcontext –l添加安全上下文semanage fcontext -a –t httpd_sys_content_t ‘/testdir(/.*)?’ restorecon –Rv /testdir删除安全上下文semanage fcontext -d –t httpd_sys_content_t ‘/testdir(/.*)?’ SElinux端口标签查看端口标签 semanage port –l添加端口semanage port -a -t port_label -p tcp|udp PORTsemanage port -a -t http_port_t -p tcp 9527删除端口semanage port -d -t port_label -p tcp|udp PORTsemanage port -d -t http_port_t -p tcp 9527修改现有端口为新标签semanage port -m -t port_label -p tcp|udp PORTsemanage port -m -t http_port_t -p tcp 9527 SELinux布尔值getsebool -a 查看所有布尔值布尔型规则： getsebool setsebool查看bool命令：getsebool [-a] [boolean]semanage boolean –lsemanage boolean -l –C 查看修改过的布尔值设置bool值命令：setsebool [-P] boolean value（on,off）setsebool [-P] Boolean=value（1，0） [root@centos7 ~]# setsebool ftpd_anon_write on ftpd_anon_write (on , off) Allow ftpd to anon write 表示临时生效，机器重启后还是off setsebool ftpd_anon_write 0 改成off [root@centos7 ~]# semanage boolean -l | grep ftp -p永久保存 [root@centos7 ~]# sestsebool -P ftpd_anon_write 1 ftpd_anon_write (on , on) Allow ftpd to anon write SELinux日志管理yum install setroubleshoot（重启生效）将错误的信息写入/var/log/messagegrep setroubleshoot /var/log/messages查看安全事件日志说明 sealert -l UUID扫描并分析日志sealert -a /var/log/audit/audit.log SELinux帮助yum –y install selinux-policy-devel ( centos7.2)yum –y install selinux-policy-docmandb | makewhatisman -k _selinux awkawk-F:分隔符，指定输入时用到的字段分隔符 指定输出分割符 [root@centos7 ~]# awk -F &quot;:&quot; &#39;{print $1&quot;**&quot;$3}&#39; /etc/passwd [root@centos7 ~]# awk &#39;{print $0}&#39; /etc/passwd 将整个文件全部打印一遍 [root@centos7 ~]# awk &#39;{print &quot;abc&quot;$0}&#39; /etc/passwd 将整个文件全部打印一遍每行首都加入abc [root@centos7 ~]# awk &#39;{print 1+2}&#39; /etc/fstab 还可以做数据运算，依然是文件多少行，就会显示多少行出来 [root@centos7 ~]# awk &#39;BEGIN{print &quot;1+2&quot;}&#39; BEGIN表示读入文件前处理一次，也就是只显示一次。注意双引号的区别 1+2 [root@centos7 ~]# awk &#39;BEGIN{print &quot;1+2&quot;}{print $0}END{print &quot;end&quot;}&#39; /etc/fstab 1+2 #这里三段分别表示开始处理前；逐行处理文件；最后处理一次 # # /etc/fstab # Created by anaconda on Fri Mar 29 05:07:40 2019 # # Accessible filesystems, by reference, are maintained under &#39;/dev/disk&#39; # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # UUID=deb83589-98fa-4bf0-a3fc-5e5448892ca9 / xfs defaults 0 0 UUID=fc8fc457-8851-43d6-9485-37b256d9e972 /boot xfs defaults 0 0 UUID=3aa10d04-b9e4-4b0f-84cf-8c59e7e77ad0 /data xfs defaults 0 0 UUID=f647ed48-10d0-4358-9ef5-3fa77d36bc23 swap swap defaults 0 0 end awk变量变量：内置和自定义变量 FS：输入字段分隔符，默认为空白字符 awk -v FS=&#39;:&#39; &#39;{print $1,FS,$3}’ /etc/passwd awk –F: &#39;{print $1,$3,$7}’ /etc/passwd OFS：输出字段分隔符，默认为空白字符 awk -v FS=: -v OFS=: &#39;{print $1,$3}&#39; /etc/passwd fs=:;awk -v FS=$fs -v OFS=$fs &#39;{print $1,$3}&#39; /etc/passwd RS：输入记录分隔符，指定输入时的换行符 这里的意思是当awk &#39;{print $0} /etc/passwd&#39; 他会将整个文件都打印出来，他的分隔符也就是换行符。 [root@centos7 ~]# cat f1.txt aa:bb:cc dd:eex:xxx zzz:xxaa [root@centos7 ~]# awk -v RS=&#39;:&#39; &#39;{print $0}&#39; f1.txt 更改换行符 aa bb cc dd eex xxx zzz xxaa [root@centos7 ~]# awk -v RS=: &#39;{print $1}&#39; f1.txt aa bb cc eex xxx xxaa [root@centos7 ~]# cat f1.txt aa;xxx:bb;bzaa:cc dd:eex;zccc:xxx zzz:xxaa;adfad #这里;输入分隔 :换行符 aa;xxx:这个也就是一条记录，打印$2，没有第二列就用空格表示 [root@centos7 ~]# awk -v FS=&quot;;&quot; -v RS=&quot;:&quot; &#39;{print $2}&#39; f1.txt xxx bzaa zccc adfad ORS：输出记录分隔符，输出时用指定符号代替换行符 [root@centos7 ~]#cat f1.txt aa;xxx:bb;bzaa:cc dd:eex;zccc:xxx zzz:xxaa;adfad [root@centos7 ~]#awk -v FS=&quot;;&quot; -v RS=&quot;:&quot; -v ORS=&quot;===&quot; &#39;{print $0}&#39; f1.txt aa;xxx===bb;bzaa===cc dd===eex;zccc===xxx zzz===xxaa;adfad ===[root@centos7 ~]# NF：字段数量 awk -F：&#39;{print NF}&#39; /etc/fstab 引用变量时，变量前不需加$ awk -F : &#39;{print NF}&#39; /etc/passwd 查看每行有多少个： awk -F : &#39;{print $NF}&#39; /etc/passwd 被：分割的最后一列 awk -F : &#39;{print $(NF-1)}&#39; /etc/passwd 倒数第二列 NR：记录号(显示记录编号) awk &#39;{print NR}&#39;&#39; /etc/fstab ; awk END‘{print NR}’ /etc/fstab awk -v RS=&quot;:&quot; &#39;{print NR,$0}&#39; f1.txt 因为这里是以：为分割，ccdd就表示一条记录。所以会有没有计数的 1 aa;xxx 2 bb;bzaa 3 cc dd 4 eex;zccc 5 xxx zzz 6 xxaa;adfad [root@centos7 ~]# awk END&#39;{print NR}&#39; /etc/fstab 打印总行号 12 FNR：各文件分别计数,记录号(如果只用NR,两个文件就会合并在一起排序) awk &#39;{print FNR}&#39; /etc/fstab /etc/inittab awk -F : &#39;{print FNR,$1}&#39; /etc/passwd /etc/group FILENAME：显示当前文件名 awk &#39;{print FILENAME}’ /etc/fstab awk -F : &#39;{print FNR,FILENAME$1}&#39; /etc/passwd /etc/group 1 /etc/passwdroot 2 /etc/passwdbin 3 /etc/passwddaemon 4 /etc/passwdadm 5 /etc/passwdlp ...... ARGC：查看命令行参数的个数 awk -F : &#39;{print ARGC}&#39; /etc/passwd /etc/group 显示这条命令的参数个数 ARGV：数组，保存的是命令行所给定的各参数 awk -F : &#39;{print ARGV[0]}&#39; /etc/passwd /etc/group 查看第0个参数 awk -F : &#39;{print ARGV[1]}&#39; /etc/passwd /etc/group 查看第1个参数 默认分隔符是空格-F 指定分隔符 awk -F : &#39;{print $1,$3}&#39; /etc/passwd这里逗号是默认的，输出会变成空格，如果想要加指定的间隔符可以awk -F : &#39;{print $1&quot;:&quot;$3}&#39; /etc/passwd-v 变量赋值 awk -v FS=&quot;:&quot; &#39;{print $1,$3}&#39; /etc/passwdawk -v FS=&quot;:&quot; &#39;{print $1FS$3}&#39; /etc/passwddf | awk -F &quot;[[:space:]]+&quot; &#39;{print $5}&#39; 还可以用正则表达式 调用shell中的变量 fs=: awk -v FS=$fs &#39;{print $1FS$3}&#39; /etc/passwd awk -F $fs &#39;{print $1,$3}&#39; /etc/passwd 自定义变量 [root@centos7 ~]# awk -F &quot;:&quot; &#39;{name=&quot;magedu&quot;;print $1,name}&#39; /etc/passwd pan magedu 可以写在文件中 [root@centos7 ~]# cat awk.txt {print $1} [root@centos7 ~]# awk -F: -f awk.txt /etc/passwd printf他不会自动换行，需要显示给出换行符\n格式符: %c：显示字符的ASCII码 %d, %i：显示十进制整数 %e, %E：显示科学计数法数值 %f：显示为浮点数 %g, %G：以科学计数法或浮点形式显示数值 %s：显示字符串 %u：无符号整数 %%：显示%自身 修饰符#[.#] 第一个数字控制显示的宽度；第二个#表示小数点后精度，%3.1f- 左对齐（默认右对齐）%-15s+ 显示数值的正负符号 %+d [root@centos7 ~]# awk -F : &#39;{printf &quot;%20s %5d\n&quot;, $1,$3}&#39; /etc/passwd %20s 表示$1这第一个字段预留20个宽度，默认右对齐，%5d 表示$3这个字段预留5个宽度 操作符比较操作符：==, !=, &gt;, &gt;=, &lt;, &lt;=模式匹配符：~：左边是否和右边匹配，包含!~：是否不匹配示例：awk -F: ‘$0 ~ /root/{print $1}‘ /etc/passwdawk ‘$0~“^root”‘ /etc/passwdawk ‘$0 !~ /root/‘ /etc/passwdawk -F: ‘$3==0’ /etc/passwd 操作符算术操作符：x+y, x-y, x*y, x/y, x^y, x%y-x：转换为负数+x：将字符串转换为数值字符串操作符：没有符号的操作符，字符串连接赋值操作符：=, +=, -=, *=, /=, %=, ^=，++, --下面两语句有何不同awk ‘BEGIN{i=0;print ++i,i}’ 先加后打印awk ‘BEGIN{i=0;print i++,i}’ 先打印后加 [root@centos7 ~]# awk -v i=100 &#39;BEGIN{print i++,i}&#39; 100 101 操作符逻辑操作符：与&amp;&amp;，或||，非!示例：awk -F: ‘$3&gt;=0 &amp;&amp; $3&lt;=1000 {print $1}’ /etc/passwdawk -F: ‘$3==0 || $3&gt;=1000 {print $1}’ /etc/passwdawk -F: ‘!($3==0) {print $1}’ /etc/passwdawk -F: ‘!($3&gt;=500) {print $3}’ /etc/passwd条件表达式（三目表达式）selector?if-true-expression:if-false-expression示例：awk -F: ‘{$3&gt;=1000?usertype=”Common User”:usertype=” SysUser”;printf “%15s:%-s\n”,$1,usertype}’ /etc/passwd [root@centos7 ~]# awk -F : &#39;{$3&gt;=1000?name=&quot;common user&quot;:name=&quot;system user&quot;;print name,$1,$3}&#39; /etc/passwd 这里表示$3&gt;1000 就怎样 ，否则就怎样；然后打印出来 system user root 0 例 system user bin 1 system user daemon 2 system user adm 3 system user lp 4 system user sync 5 system user shutdown 6 [root@centos7 ~]# ss -nt | awk -F &quot;[[:space:]]+|:&quot; &#39;/ESTAB/{print $7}&#39;这里表示空格和:作为分隔符，后面的是正则表达式锁定/ESTSB/这行 relational expression: 关系表达式，结果为“真”才会被处理真：结果为非0值，非空字符串假：结果为空字符串或0值awk -v abc=&quot; &quot; &#39;abc{print $0}&#39; /etc/passwd 行范围startline,endline：/pat1/,/pat2/ 不支持直接给出数字格式awk -F: ‘/^root>/,/^nobody>/{print $1}’ /etc/passwdawk -F: ‘(NR&gt;=10&amp;&amp;NR&lt;=20){print NR,$1}’ /etc/passwd 打印 ftp 到 rpc 的行 [root@centos7 ~]#awk &#39;/^ftp/,/^rpc/{print $0}&#39; /etc/passwd ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin nobody:x:99:99:Nobody:/:/sbin/nologin systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin dbus:x:81:81:System message bus:/:/sbin/nologin polkitd:x:999:998:User for polkitd:/:/sbin/nologin libstoragemgmt:x:998:996:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin [root@centos7 ~]#awk &#39;NR&gt;=10 &amp;&amp; NR&lt;=20{print NR,$0}&#39; /etc/passwd 打印10-20行的内容 seq 10 | awk &#39;i=!i&#39; 这里表示一开始i没有赋值所以就为假，然后!i就为真，就会打印出第一行， 为真后第二行又!2所以是空值，不打印。以此类推 1 3 5 7 9 seq 10 | awk &#39;!(i=!i)&#39; 根据上面所以这里会打印出偶数行 也就是说如果首先i有值为真，那么就可以直接打印出来偶数行 seq 10 | awk -v i=&quot;1&quot; &#39;i=!i&#39; [root@centos7 ~]# seq 10 | awk &#39;{i=!i;print i}&#39; 1 0 1 0 1 0 1 0 1 0 awk控制语句if-else[root@centos7 ~]# awk -v score=66 &#39;BEGIN{if(score&lt;60){print &quot;no pass&quot;}else if(score &lt;=80){print &quot;score&quot;}else {print &quot;good&quot;}}&#39; score awk控制语句while循环语法：while(条件){处理语句;…}条件“真”，进入循环；条件“假”，退出循环使用场景：对一行内的多个字段逐一类似处理时使用对数组中的各元素逐一处理时使用awk -F : &#39;NR==1{i=1;while(i&lt;=NF){print $i,length($i);i++}}&#39; /etc/passwd打印/etc/passwd文件第一行的字段并逐行显示NR 行号，NF字段awk &#39;/^[[:space:]]*linux16/{i=1;while(i&lt;=NF) {print $i,length($i); i++}}&#39; /etc/grub2.cfg加了条件: awk &#39;/^[[:space:]]*linux16/{i=1;while(i&lt;=NF){if(length($i)&gt;=10){print $i,length($i)}; i++}}&#39; /etc/grub2.cfg 练习[root@centos7 ~]# for i in {1..1000};do if [ $i -eq 1 ];then echo -e &quot;$RANDOM\c&quot; &gt;&gt;f1.txt;else echo -e &quot;,$RANDOM\c&quot; &gt;&gt; f1.txt;fi;done 随机1-1000的数字存在这个文件中 awk -F &#39;,&#39; &#39;{i=2;max=$1;min=$1;while(i&lt;=NF){if($i &gt; max){max=$i}else if($i &lt; min){min=$i};i++}}END{print &quot;max=&quot;max,&quot;min=&quot;min}&#39; f1.txt 取最大值，最小值 awk控制语句do-while循环语法：do {statement;…}while(condition)意义：无论真假，至少执行一次循环体示例： [root@centos7 ~]# awk &#39;BEGIN{ total=0;i=0;do{ total+=i;i++;}while(i&lt;=100);print total}&#39; 5050 awk控制语句for循环语法：for(expr1;expr2;expr3) {statement;…}常见用法for(variable assignment;condition;iteration process){for-body}特殊用法：能够遍历数组中的元素语法：for(var in array) {for-body}示例： awk &#39;/^[[:space:]]*linux16/{for(i=1;i&lt;=NF;i++) {print $i,length($i)}}&#39; /etc/grub2.cfg awk &#39;BEGIN{for(i=0;i&lt;=100;i++)total+=i;print total}&#39; awk &#39;BEGIN{total=0;for(i=0;i&lt;=100;i++)total+=i;print total}&#39; 用shell写法for ((i=0,total=0;i&lt;=100;i++));do let total+=i;done; echo $total查看时间：time “awk ‘BEGIN{total=0;for(i=1;i&lt;=100000;i++)total+=i;print total}’” awk控制语句switch语句语法：switch(expression) {case VALUE1 or /REGEXP/: statement1; case VALUE2 or /REGEXP2/: statement2; …; default: statementn}break和continueawk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++) {if(i%2==0)continue;sum+=i}print sum}’awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++) {if(i==66)break;sum+=i}print sum}’ [root@centos7 ~]# awk &#39;BEGIN{total=0;for(i=0;i&lt;=100;i++){if(i==50)continue;total+=i};print total}&#39; 5000 [root@centos7 ~]# awk &#39;BEGIN{total=0;for(i=0;i&lt;=100;i++){if(i==50)break;total+=i};print total}&#39; 1225 next:提前结束对本行处理而直接进入下一行处理（awk自身循环）awk -F: ‘{if($3%2!=0) next; print $1,$3}’ /etc/passwd [root@centos7 ~]# awk -F : &#39;{if(NR%2==0)next;print NR,$0}&#39; /etc/passwd 对2取模，显然NR必须都是偶数才满足。next跳过本行处理也就是跳过偶数行 1 root:x:0:0:root:/root:/bin/bash 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin ...... awk -F : &#39;NR%2==1{print NR,$0}&#39; /etc/passwd 写法不同 awk数组关联数组：array[index-expression]index-expression:(1) 可使用任意字符串；字符串要使用双引号括起来(2) 如果某数组元素事先不存在，在引用时，awk会自动创建此元素，并将其值初始化为“空串”(3) 若要判断数组中是否存在某元素，要使用“index in array”格式进行遍历示例：weekdays[“mon”]=”Monday”awk ‘BEGIN{weekdays[“mon”]=”Monday”;weekdays[“tue”]=”Tuesday”; print weekdays[“mon”]}‘awk ‘!line[$0]++’ dupfileawk ‘{!line[$0]++;print $0, line[$0]}’ dupfile [root@centos7 ~]# awk &#39;BEGIN{title[&quot;ceo&quot;]=&quot;mage&quot;;title[&quot;coo&quot;]=&quot;zhnagsir&quot;;title[3]=&quot;wnag&quot;;print title[3]}&#39; wnag [root@centos7 ~]# cat f1.txt abc abc ddd ccc ccc aaaa aaa abc [root@centos7 ~]# awk &#39;{!line[$0]++;print $0,line[$0]}&#39; f1.txt abc 1 abc 2 ddd 1 ccc 1 ccc 2 aaaa 1 aaa 1 abc 3 [root@centos7 ~]# awk &#39;!line[$0]++;&#39; f1.txt 表现为去除重复 abc ddd ccc aaaa aaa awk数组若要遍历数组中的每个元素，要使用for循环for(var in array) {for-body}注意：var会遍历array的每个索引示例：awk‘BEGIN{weekdays[“mon”]=”Monday”;weekdays[“tue”]=”Tuesday”; for(i in weekdays) {print weekdays[i]}}’netstat -tan | awk ‘/^tcp/{state[$NF]++} END{for(i in state) { print i,state[i]}}’awk &#39;{ip[$1]++}END{for(i in ip){print i,ip[i]}}&#39; /var/log/httpd/access_log-20190824 统计文件中的ipss -nt | awk -F &quot;[[:space:]]+|:&quot; &#39;/ESTAB/{ip[$(NF-2)]++}END{for (i in ip){print i;ip[i]}}&#39; [root@centos7 ~]# awk &#39;/UUID/{filesystem[$3]++}END{for (i in filesystem){print i,filesystem[i]}}&#39; /etc/fstab swap 1 xfs 3 awk函数数值处理：rand()：返回0和1之间一个随机数awk &#39;BEGIN{srand(); for (i=1;i&lt;=10;i++)print int(rand()*100) }&#39;awk &#39;BEGIN{srand();print rand()}&#39; 字符串处理：length([s])：返回指定字符串的长度 sub(r,s,[t])：对t字符串搜索r表示模式匹配的内容，并将第一个匹配内容替换为s echo &quot;2008:08:08 08:08:08&quot; | awk &#39;sub(/:/,&quot;-&quot;,$1)&#39; 2008-08:08 08:08:08 gsub(r,s,[t])：对t字符串进行搜索r表示的模式匹配的内容，并全部替换为s所表示的内容[root@centos7 ~]# echo &quot;2008:08:08 08:08:08&quot; | awk &#39;gsub(&quot;:&quot;,&quot;-&quot;,$1)&#39; 2008-08-08 08:08:08 [root@centos7 ~]# echo &quot;2008:08:08 08:08:08&quot; | awk &#39;{split($0,str,&quot;:&quot;)}END{for (i in str){print i,str[i]}}&#39; 4 08 5 08 1 2008 2 08 3 08 08 split(s,array,[r])：以r为分隔符，切割字符串s，并将切割后的结果保存至array所表示的数组中，第一个索引值为1,第二个索引值为2,… [root@centos7 ~]# netstat -tn Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 96 192.168.152.136:22 192.168.152.1:51449 ESTABLISHED tcp 0 0 192.168.152.136:22 192.168.152.1:51450 ESTABLISHED [root@centos7 ~]# netstat -tn | awk &#39;/^tcp/{split($5,ip,&quot;:&quot;);count[ip[1]]++}END{for (i in count){print i,count[i]}}&#39; 192.168.152.1 2 统计每一个IP的连接次数 [root@centos7 ~]# netstat -tn | awk &#39;/^tcp/{split($5,ip,&quot;:&quot;);count[ip[2]]++}END{for (i in count){print i,count[i]}}&#39; 51449 1 51450 1 awk函数[root@centos7 ~]# cat func.awk 比较最大值 function max(x,y){ x&gt;y?var=x:var=y return var } BEGIN{print max(i,j)} [root@centos7 ~]# awk -v i=22 -v j=23 -f func.awk 23 awk中调用shell命令system命令空格是awk中的字符串连接符，如果system中需要使用awk中的变量可以使用空格分隔，或者说除了awk的变量外其他一律用””引用起来 awk &#39;BEGIN{system(&quot;hostname&quot;) }&#39; awk &#39;BEGIN{score=100; system(&quot;echo your score is &quot; score) }&#39; [root@centos7 ~]# awk &#39;BEGIN{dir=&quot;/boot&quot;;system(&quot;ls &quot;dir)}&#39; 调用变量 awk脚本将awk程序写成脚本，直接调用或执行示例： [root@centos7 ~]# cat f1.awk #!/bin/awk -f #this is a awk script {if($3&gt;=1000)print $1,$3} [root@centos7 ~]# ./f1.awk -F : /etc/passwd nfsnobody 65534 pan 1000 向awk脚本传递参数格式：awkfile var=value var2=value2… Inputfile注意：在BEGIN过程中不可用。直到首行输入完成以后，变量才可用。可以通过-v 参数，让awk在执行BEGIN之前得到变量的值。命令行中每一个指定的变量都需要一个-v参数示例 [root@centos7 ~]# cat b.awk #!/bin/awk -f {if($3&gt;=min &amp;&amp; $3&lt;=max)print $1,$3} [root@centos7 ~]# ./b.awk -F : min=50 max=80 /etc/passwd tss 59 radvd 75 sshd 74 avahi 70 tcpdump 72 将以下文件内容中FQDN取出并根据其进行计数从高到低排序[root@centos7 ~]# cat ff.txt http://mail.magedu.com/index.html http://www.magedu.com/test.html http://study.magedu.com/index.html http://blog.magedu.com/index.html http://www.magedu.com/images/logo.jpg http://blog.magedu.com/20080102.html [root@centos7 ~]# awk -F &quot;/&quot; &#39;{fqdn[$3]++}END{for(i in fqdn){print i,fqdn[i]}}&#39; ff.txt | sort -k 2 -nr www.magedu.com 2 blog.magedu.com 2 study.magedu.com 1 mail.magedu.com 1 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Five]]></title>
    <url>%2F2019%2F07%2F26%2FLinux%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[linux 安全 对称加密算法对称加密：加密和解密使用同一个密钥DES：Data Encryption Standard，56bits 3DES：AES：Advanced (128, 192, 256bits)Blowfish，TwofishIDEA，RC6，CAST5特性：1、加密、解密使用同一个密钥，效率高2、将原始数据分割成固定大小的块，逐个进行加密缺陷：1、密钥过多2、密钥分发3、数据来源无法确认 非对称加密算法公钥加密：密钥是成对出现公钥：公开给所有人；public key私钥：自己留存，必须保证其私密性；secret key特点：用公钥加密数据，只能使用与之配对的私钥解密；反之亦然功能：数字签名：主要在于让接收方确认发送方身份对称密钥交换：发送方用对方的公钥加密一个对称密钥后发送给对方数据加密：适合加密较小数据缺点：密钥长，加密解密效率低下算法：RSA（加密，数字签名）DSA（数字签名）ELGamal 非对称加密基于一对公钥/密钥对用密钥对中的一个加密，另一个解密实现加密：接收者生成公钥/密钥对：P和S公开公钥P，保密密钥S发送者使用接收者的公钥来加密消息M将P(M)发送给接收者接收者使用密钥S来解密：M=S(P(M)) 非对称加密实现数字签名：发送者生成公钥/密钥对：P和S公开公钥P，保密密钥S使用密钥S来加密消息M发送给接收者S(M)接收者使用发送者的公钥来解密M=P(S(M))结合签名和加密分离签名 单向散列固定长度输出若修改数据，指纹也会改变（“不会产生冲突”）无法从指纹中重新生成数据（“单向”）功能：数据完整性常见算法md5: 128bits、sha1: 160bits、sha224 、sha256、sha384、sha512常用工具md5sum | sha1sum [ –check ] fileopenssl、gpgrpm -V 下载文件后与网络上的sha256值进行比对，是否属于同一文件 [root@centos7 ssh]# sha256sum /dev/sr0 506e4e06abf778c3435b4e5745df13e79ebfc86565d7ea1e128067ef6b5a6345 /dev/sr0 [root@centos7 dir]# md5sum a &gt; md5.log 使用MD5计算a的值保存在md5.log [root@centos7 dir]# md5sum -c md5.log 检查 a: OK [root@centos7 dir]# md5sum -c md5.log 当我更改a之后，再次检查，就会报错 a: FAILED md5sum: WARNING: 1 computed checksum did NOT match [root@centos7 ~]# md5sum a.txt f1.txt &gt; md5.log 文件批量检查 [root@centos7 ~]# md5sum -c md5.log a.txt: OK f1.txt: OK 应用程序：RPM文件完整性的两种实施方式被安装的文件MD5单向散列rpm –verify package_name (or -V)发行的软件包文件GPG公钥签名rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat*rpm –checksig pakage_file_name (or -K) 导入公钥签名(磁盘里面也有) [root@centos7 data]# rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 [root@centos7 data]# rpm -K tree-1.6.0-10.el7.x86_64.rpm 检查tree包 tree-1.6.0-10.el7.x86_64.rpm: rsa sha1 (md5) pgp md5 OK [root@centos7 data]# echo &gt;&gt; tree-1.6.0-10.el7.x86_64.rpm tree包增加一个回车 [root@centos7 data]# rpm -K tree-1.6.0-10.el7.x86_64.rpm tree-1.6.0-10.el7.x86_64.rpm: rsa sha1 (MD5) PGP MD5 NOT OK 检查出错 密钥交换密钥交换：IKE（ Internet Key Exchange ）公钥加密：DH (Deffie-Hellman)：生成会话密钥，由惠特菲尔德·迪菲（Bailey Whitfield Diffie）和马丁·赫尔曼（Martin Edward Hellman）在1976年发表参看：https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchangeDH：A: g,p 协商生成公开的整数g, 大素数pB: g,pA:生成隐私数据 :a (a &lt; p)，计算得出 g^a%p，发送给BB:生成隐私数据 :b,计算得出 g^b%p，发送给AA:计算得出 [(g^b%p)^a] %p = g^ab%p，生成为密钥B:计算得出 [(g^a%p)^b] %p = g^ab%p，生成为密钥 使用gpg实现对称加密对称加密file文件 gpg -c file ls file.gpg在另一台主机上解密file gpg -o file -d file.gpg [root@centos7 data]# gpg -c passwd 比如加密passwd然后输入密码 [root@centos7 data]# ls 可以查看到有一个这样多出来的以.gpg的文件 passwd.gpg 这个文件现在查看已经是乱码了 [root@centos7 data]# scp passwd.gpg 192.168.152.131: 将文件传入另外一台机器 -d解密，然后按提示输入同样的口令，加密解密用的是一把钥匙，但是这样只会把文件打印到屏幕上， [root@centos6 ~]# gpg -d passwd.gpg 如果要形成新的文件需要 gpg -o passwd.log -d passwd.gpg 实验:两台主机加密文件并解密centos6建立公钥和私钥，传给centos7公钥并加密文件后，再传回centos6解密 [root@centos6 ~]# gpg --list-keys 查看公钥 [root@centos6 ~]# gpg --gen-key 生成公钥 gpg (GnuPG) 2.0.14; Copyright (C) 2009 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Please select what kind of key you want: ##提示你用什么算法来实现 (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) ##这里是实现签名 (4) RSA (sign only) Your selection? ##这里回车表示默认第一条 RSA keys may be between 1024 and 4096 bits long. What keysize do you want? (2048) 1024 ##指定加密位数 Requested keysize is 1024 bits Please specify how long the key should be valid. ##这里表示你生成的秘钥是否要给他指定一个有效期 0 = key does not expire ##0表示一直有效 &lt;n&gt; = key expires in n days &lt;n&gt;w = key expires in n weeks &lt;n&gt;m = key expires in n months &lt;n&gt;y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y ##你确定刚才的操作吗 GnuPG needs to construct a user ID to identify your key. ##需要你构建一个key的用户，表示这个key是谁的 Real name: xiaohu Email address: ##回车忽略 Comment: You selected this USER-ID: &quot;xiaohu&quot; ##更改用户名 更改描述 更改邮箱 或者 确定 退出 Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o can&#39;t connect to `/root/.gnupg/S.gpg-agent&#39;: No such file or directory ##这句话表示没有这个目录(应该是默认不做加密操作就没有这个目录)，但是现在其实已经有了 ┌─────────────────────────────────────────────────────┐ │ Enter passphrase │ │ │ │ │ │ Passphrase ________________________________________ │ │ │ │ &lt;OK&gt; &lt;Cancel&gt; │ └─────────────────────────────────────────────────────┘ ##这里提示你输入一个口令，他表示你需要对私钥加一个口令。(担心私钥泄露)也可以不加后面选择&quot;&lt;Take this one anyway&gt;&quot; ##然后提示你一大堆文字，是要你在主机上随意点击鼠标位置，根据这个来生成大量随机数。最后生成的: gpg: checking the trustdb gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model gpg: depth: 0 valid: 1 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 1u pub 2048R/DD213C96 2019-06-29 Key fingerprint = F035 585E 9E43 D3AA 69E2 FE43 77C4 B0A8 DD21 3C96 uid xiaohu sub 2048R/9817AA4F 2019-06-29 [root@centos6 ~]# cd /root/.gnupg/ [root@centos6 .gnupg]# ll total 32 -rw-------. 1 root root 7856 May 22 07:46 gpg.conf drwx------. 2 root root 4096 Jun 29 17:02 private-keys-v1.d -rw-------. 1 root root 1165 Jun 29 17:24 pubring.gpg ##公钥 -rw-------. 1 root root 1165 Jun 29 17:24 pubring.gpg~ -rw-------. 1 root root 600 Jun 29 17:24 random_seed -rw-------. 1 root root 2466 Jun 29 17:24 secring.gpg ##私钥 -rw-------. 1 root root 1280 Jun 29 17:24 trustdb.gpg [root@centos6 .gnupg]# gpg -a --export -o /data/xiaohupubkey ##倒出文件 -a，--armor：创建ascii输出 --export：导出keys -o：输出文件至where name --gen-key：生成一对儿密钥 -e，--encrypt：加密数据 -r：使用哪个密钥对加密encrypt for USER-ID -d：解密文件 ##现在/data目录下已经有了这个文件，因为-a所以能看到内容不再是乱码 再把公钥拷贝的对应的机器上去scp xiaohupubkey 192.168.152.136:/data ##在centos7新建一个公钥 [root@centos7 .gnupg]# gpg --import /data/xiaohupubkey ##导入刚刚centos6传入的公钥 ##然后/root/.gnupg/pubring.gpg文件会变大 [root@centos7 data]# gpg -e -r xiaohu passwd ##使用centos6传入过来的秘钥进行加密，文件名passwd [root@centos7 data]# scp passwd.gpg 192.168.152.131:/data ##将加密好的文件传入centos6 [root@centos6 data]# gpg -o passwd.log -d passwd.gpg ##-d解密文件passwd.gpg,-o输出到passwd.log gpg: encrypted with 2048-bit RSA key, ID 9817AA4F, created 2019-06-29 &quot;xiaohu&quot; 实验结束 删除密钥呢 (如果要删除公钥前要删除私钥) （1）删除私钥 [root@centos6~]#gpg --delete-secret-keys centos6 （2）删除公钥 [root@centos6~]#gpg --delete-keys centos6 CA和证书PKI: Public Key Infrastructure签证机构：CA（Certificate Authority）注册机构：RA证书吊销列表：CRL证书存取库： X.509：定义了证书的结构以及认证协议标准版本号 主体公钥序列号 CRL分发点签名算法 扩展信息颁发者 发行者签名有效期限主体名称 openssl命令对称加密：工具：openssl enc, gpg算法：3des, aes, blowfish, twofish enc命令：帮助：man enc enc:表示加密编码 -e:进行加密操作，默认操作。 -des3:加密算法 -in:指定输入的密钥文件 -out:指定提取生成公钥的文件(PEM公钥格式) -d:允许解密文件 [root@centos7 data]# openssl enc -e -des3 -in passwd -out passwd.enc ##加密 [root@centos7 data]# openssl enc -d -des3 -in passwd.enc -out passwd.jie ##解密 openssl命令单向加密：工具：md5sum, sha1sum, sha224sum,sha256sum…openssl dgstdgst命令：帮助：man dgstopenssl dgst -md5 [-hex默认] /PATH/SOMEFILEopenssl dgst -md5 testfilemd5sum /PATH/TO/SOMEFILE MAC: Message Authentication Code，单向加密的一种延伸应用，用于实现网络通信中保证所传输数据的完整性机制CBC-MACHMAC：使用md5或sha1算法 [root@centos6 data]# openssl dgst -sha512 passwd SHA512(passwd)= d9a43b2f911b81b10530a6bc25342d18a9df22a2cd2d69a3b93f10253302244f33dbaa7c336ba7cf5e4acf92c2ff44311ec1f4b2c7dd9081cf78909b7fb08a42 [root@centos6 data]# openssl dgst -md5 passwd MD5(passwd)= 30dda824d8888aa640e1af6ba32c5c83 [root@centos6 data]# md5sum passwd 虽然工具不一样，但是算法是一样的，所以结果也是一样的 30dda824d8888aa640e1af6ba32c5c83 passwd openssl命令生成用户密码：passwd命令:帮助：man sslpasswdopenssl passwd -1 -salt SALT(最多8位) -1表示使用md5加密openssl passwd -1 –salt centos 生成随机数：帮助：man sslrandopenssl rand -base64|-hex NUMNUM: 表示字节数，使用-hex，每个字符为十六进制，相当于4位二进制，出现的字符数为NUM*2 ##这里password:都是123456，但是来两次生成的密码都不一样，是因为他们本身使用了salt的功能； slat的作用就是虽然使用的密码一样的，但是最后生成的加密数是不一样的。但是我们可以指定salt，然后 使用的密码是一样的，那么最后生成的密码文件也就是一样的了。 [root@centos7 ~]# openssl passwd -1 Password: Verifying - Password: $1$ZKfj9UF6$ObtWhvipf.ihRCt9bEXjl/ [root@centos7 ~]# openssl passwd -1 Password: Verifying - Password: $1$HS7Kkw4e$kyDAv.6jFtFIDesOAs4Ts/ [root@centos7 ~]# openssl passwd -1 -salt &quot;ZKfj9UF6&quot; ##指定salt Password: $1$ZKfj9UF6$ObtWhvipf.ihRCt9bEXjl/ [root@centos7 ~]# openssl rand -base64 3 ehix [root@centos7 ~]# openssl rand -base64 4 9eMocw== ##rand 生成随机数，使用base64编码，3表示3个字节，一个字节8位，24能被6整除，所以不会有等号 [root@centos7 ~]# openssl rand -hex 6 91b2b352a083 ##6个字节，8个二进制是一个字节，48个二进制。一个16进制是4个二进制，48/4=12个 openssl命令生成密钥对儿：man genrsa 生成私钥openssl genrsa -out /PATH/TO/PRIVATEKEY.FILE NUM_BITS(umask 077; openssl genrsa –out test.key –des 2048)openssl rsa -in test.key –out test2.key 将加密key解密 从私钥中提取出公钥openssl rsa -in PRIVATEKEYFILE –pubout –out PUBLICKEYFILEopenssl rsa –in test.key –pubout –out test.key.pub 随机数生成器：伪随机数字键盘和鼠标，块设备中断/dev/random：仅从熵池返回随机数；随机数用尽，阻塞/dev/urandom：从熵池返回随机数；随机数用尽，会利用软件生成伪随机数,非阻塞tr -dc &#39;a-zA-Z0-9&#39; /dev/random-d:删除指定字符-c:取反点击查看代码 [root@centos7 ssl]# (umask 066;openssl genrsa -out test.key 1024) ##生成一个测试文件未加密 Generating RSA private key, 1024 bit long modulus .......................++++++ ...................++++++ e is 65537 (0x10001) [root@centos7 ssl]# ls test.key [root@centos7 ssl]# cat test.key -----BEGIN RSA PRIVATE KEY----- MIICXAIBAAKBgQDGOXck947r8qCj/QDJgSYTqiE1v4R35ZhomqnmUObG40ZblUIB 5wNJ+CjvdQkLlgl2pzzV15juUB8B/pQ1x5GLWvX57risicZ6osb0VeMGYYRt5BN+ 2RWPDbweMTQOfrd+wyBiuV436C3q5N81uosrLuqaT+5MdU70fS5t7lauZQIDAQAB AoGBAIzJddDgrzbvzZ6LbIqx2qxu0kWNb/WEMXpiFzfI0BAEjg0v9oDJZfGcet6Q PktnVfNbFn8/MJRafZt6CCQmSTzyHhu713xWB3MgqMfM4NnCSqmCtQd4S9iinCEy bflxO1hZvRHvHKVP4qYCqwNiDCbJVylYBXIP5CSHvaub5F5BAkEA+qEiKn/ZSMXe NusmmXXHppIHIlGEa1+jOEugWL3c+AWEfcBeRm+gltl5TH4D+2AdawzGnE462irv MdFM53im8QJBAMp420DvQ6D8g0aK+GZmiCFKaRpvDnfVhJ8lghU0y7wBkVm7qwr8 3cR2l7lGISMQXTOmjM7Zu+DmNh9WLkoPBrUCQHrEDx5OPbrd4Xl5OhEVllRLV19C GuEVmbfro4GUjvaWjU2juwo5h6ocoMQNPhoV/JMBURAjacSQH1aBtW/0s6ECQD7y ef/jIxxuxQVueTGk2Ne4wZplQpNA/51W1O1w35JQznaeYNvmp6/Hyv3f7rdvA/rl 4csBaGbQS61MZtHBgC0CQDavpFNYXIIJYvA2eZrgX93OlaBUp09+rTpfotTNy1Mv aWTd8RNaKXCNRW2rCYf1rqIss0nN6CHN+iN7p7K8jxM= -----END RSA PRIVATE KEY----- [root@centos7 ssl]# ll test.key -rw------- 1 root root 887 Sep 9 20:00 test.key [root@centos7 ssl]# (umask 066;openssl genrsa -out ceshi.key -des3 1024) ##生成测试文件并加密 Generating RSA private key, 1024 bit long modulus .....................................++++++ ................................................++++++ e is 65537 (0x10001) Enter pass phrase for ceshi.key: Verifying - Enter pass phrase for ceshi.key: [root@centos7 ssl]# cat ceshi.key -----BEGIN RSA PRIVATE KEY----- Proc-Type: 4,ENCRYPTED DEK-Info: DES-EDE3-CBC,160DA8EF125E7456 xAaXoC6o7yoa3lPPd4YjvRgt0xygDJtHjjMZ4L/XLuW5V9eh/tX+Geju9pL2HHz6 DRhhzpdaR60nfEIMEIdhWKe6Vmba5nID1tZluicJiZsnnlWj4wA9v1nau3jtOPJH cbdRRAr1bSR1tgfhixdoWxZ76kO+3vSqBy1onYwjamBuaVuqsvbSx2BiXS3+kVbw ohxzfBaBo9rXz+eq7sflDFA76n+oN/0dyFsIlVlMwQukahFI4trEpT3tpcbPq4PC ggCWRP9qtuyO399/9m2DIorjnPmTD+2V2m6X5hvbDWxzbauMI+oIaaUMhRlVso/h ytqNBp+Y16k00vl5HDAqN47zidhOYSAJuCdJc5v8nRo20odMk5a57cbhIMW46yGl wjUsmdN6U3v0ylQPk7YT568Vdzr9WP289Z36frhzj49EGRJ+D9+bDrgvbmheygwo xlqochRx3+qvYpwy/6Wq/8t3mPhX+I242oqVtXW3gpkUFD+NyeQ8SH/Xs9JfdXj2 58Kf8flX8+Cu6r4RzerClphfOCr/KhbRemJbzgCUD6eHaaCGfjsHUsS/zmWK4V4N lFfQv/yCAJtRzQv92FTv3gLWeLji+iEyeMk6tCEAdIhl77LDpFxDlSVdfG36PW8M nVK3jL8wDz8xVYmmMef4kEJwLb4T4qlsEjdbZVHBWN8yNZaagiEDDfi9qhZjXUQU SLLuC/ES1Q5bY8mG/eBknK3LXiRC1RjMl+EsRfDrhIOCio+XZWU4++L1KszXYcNI tn70FsBKL6KzINCK9aCuM7AW7hgMEsOZEmqXiwV5VV+g+atLk3CZwg== -----END RSA PRIVATE KEY----- [root@centos7 ssl]# openssl rsa -in ceshi.key -out ceshi2.key ##解密 Enter pass phrase for ceshi.key: writing RSA key [root@centos7 ssl]# cat ceshi2.key -----BEGIN RSA PRIVATE KEY----- MIICXQIBAAKBgQC3M6yoLiFfU8wdJSKxE2eVxY9lRlT7Gk0TdYlHMxE34ihAxMUo wB0wNvbffidKfGCQucd0ThmzlsYHEIiV69Fo/FLgwJ4QfpF2n/u+XiX9LI/WmLfZ cb4gJZvqC1pGf8GtWjDJ9hO70D530LWYoX417dV/pfwpIsbAzcTbCVNwOQIDAQAB AoGAJwvMcMvkMP0bM9sGWddY7IL+3QbwddRVOSCD8bjgopiBG8zUeKr5jZ0pYNjy Zt27dx0hdZhvwecQrdDIS6vHJcy72Bw9YZ7EZ/ZLkl5+yrgZ7eI8+V8gieNjgFsA yWZgsCGUtgg8OVUgDMnAyHp5rt2ulKBIH9YLMvjypv8pKEECQQDh9GFwmQul7PVw AR1hjLuMJx8BER1/IH0nNDDsAz76LSh3ZqMqzKwn1Rn+tbyO6zaR3AvwEK2dLSrT 54oFhTs7AkEAz4/3ZL02xJd6ijuR2M1I1NBqPy/CLWAvF2Do8r8MqzkzncoDExSY SKSQ9Tuj22e4QoJagz+kBdZqNP8KT3WDGwJAJpcvYSSyaZdL3+JA211G1swDrpH2 wLSSy3RNerGfOuklhScBbRjhujfaJbdySdKAUm8LlueyTyrcqq5b00+K6wJBAIBk 8ggi86oQegDgcIvIEPF0KwUDKf6frQGtNOxUOiYAsGk++T/oUXs+MV1Bk065jkW2 FP9zcqcZx4EY8uvMKVkCQQCPCy7Z5bopAoBmi57YmEGkwJVGSZbzeKhmvpeOYsWL 5BWZzFRx0w9myQeFUnFQtDQ+12mb896fA8qYXym/7pMr -----END RSA PRIVATE KEY----- ##刚才生成的都是私钥，现在从私钥中提取公钥 [root@centos7 ssl]# openssl rsa -in ceshi2.key -pubout -out cehshijie.key writing RSA key [root@centos7 ssl]# cat cehshijie.key -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC3M6yoLiFfU8wdJSKxE2eVxY9l RlT7Gk0TdYlHMxE34ihAxMUowB0wNvbffidKfGCQucd0ThmzlsYHEIiV69Fo/FLg wJ4QfpF2n/u+XiX9LI/WmLfZcb4gJZvqC1pGf8GtWjDJ9hO70D530LWYoX417dV/ pfwpIsbAzcTbCVNwOQIDAQAB -----END PUBLIC KEY----- 实验两台主机创建CA和申请证书1.建立私钥私钥文件必须是这个文件名cakey.pema。详细可查看此文件vim /etc/pki/tls/openssl.cnf [root@centos7 CA]# (umask 077;openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048) Generating RSA private key, 2048 bit long modulus ........+++ ...........................................................................................................................................................................+++ e is 65537 (0x10001) [root@centos7 CA]# tree . ├── certs ├── crl ├── newcerts └── private └── cakey.pem 4 directories, 1 file [root@centos7 private]# ll cakey.pem -rw------- 1 root root 1675 Sep 11 12:14 cakey.pem ##上面umask值是077，现在文件的权限时600，文件夹的权限是700 2.生成自签名证书创建CA和申请证书生成自签名证书openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 3650 -out /etc/pki/CA/cacert.pem选项说明：req：申请-new：生成新证书签署请求-x509：专用于CA生成自签证书-key：生成请求时用到的私钥文件-days n：证书的有效期限-out /PATH/TO/SOMECERTFILE: 证书的保存路径 [root@centos7 private]# openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 3650 -out /etc/pki/CA/cacert.pem You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter &#39;.&#39;, the field will be left blank. ----- Country Name (2 letter code) [XX]:CN ##这里是要输入必要的信息。国家 这里等会要匹配 State or Province Name (full name) []:beijing ##省(州) 这里等会要匹配 Locality Name (eg, city) [Default City]:beijing ##(城市) Organization Name (eg, company) [Default Company Ltd]:pan ##公司名 这里等会要匹配 Organizational Unit Name (eg, section) []:devops ##组织 Common Name (eg, your name or your server&#39;s hostname) []:ca.magedu.com ##表示证书是给那个域名颁发的 Email Address []: [root@centos7 private]# ls ##现在这个文件已经建立好了，可以穿到windows上，后缀名改为crt，就可以看到证书 cakey.pem 颁发证书在需要使用证书的主机生成证书请求现在是centos6的机器生成以下文件 给web服务器生成私钥(umask 066; openssl genrsa –out /data/test.key 2048) 生成证书申请文件openssl req -new -key /data/test.key -out /data/test.csr 将证书请求文件传输给CA CA签署证书，并将证书颁发给请求者openssl ca -in /tmp/test.csr –out /etc/pki/CA/certs/test.crt -days 100注意：默认要求 国家，省，公司名称三项必须和CA一致 点击查看代码 [root@centos6 ssl]# (umask 066;openssl genrsa -out /data/ssl/app.key 1024) ##首先新建私钥 Generating RSA private key, 1024 bit long modulus ..........++++++ .++++++ e is 65537 (0x10001) [root@centos6 ssl]# ll total 4 -rw-------. 1 root root 891 Jul 6 10:05 app.key ##生成证书申请文件，注意：默认要求 国家，省，公司名称三项必须和CA一致，详情看上文 [root@centos6 ssl]# openssl req -new -key app.key -out app.csr You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter &apos;.&apos;, the field will be left blank. ----- Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:beijing Locality Name (eg, city) [Default City]:beijing Organization Name (eg, company) [Default Company Ltd]:pan Organizational Unit Name (eg, section) []:devops Common Name (eg, your name or your server&apos;s hostname) []:*.magedu.com Email Address []: Please enter the following &apos;extra&apos; attributes to be sent with your certificate request A challenge password []: An optional company name []: [root@centos6 ssl]# ll total 8 -rw-r--r--. 1 root root 651 Jul 6 10:42 app.csr -rw-------. 1 root root 891 Jul 6 10:05 app.key ##将证书请求文件传输给CA. ##现将文件传给centos7 [root@centos6 ssl]# scp app.csr 192.168.152.136:/etc/pki/CA root@192.168.152.136&apos;s password: app.csr 100% 651 0.6KB/s 00:00 ##CA签署证书，并将证书颁发给请求者 [root@centos7 CA]# openssl ca -in app.csr -out /etc/pki/CA/certs/app.crt -days 1000 Using configuration from /etc/pki/tls/openssl.cnf /etc/pki/CA/index.txt: No such file or directory unable to open &apos;/etc/pki/CA/index.txt&apos; 140161312225168:error:02001002:system library:fopen:No such file or directory:bss_file.c:402:fopen(&apos;/etc/pki/CA/index.txt&apos;,&apos;r&apos;) 140161312225168:error:20074002:BIO routines:FILE_CTRL:system lib:bss_file.c:404: [root@centos7 CA]# touch index.txt [root@centos7 CA]# openssl ca -in app.csr -out /etc/pki/CA/certs/app.crt -days 1000 Using configuration from /etc/pki/tls/openssl.cnf /etc/pki/CA/serial: No such file or directory error while loading serial number 140378285651856:error:02001002:system library:fopen:No such file or directory:bss_file.c:402:fopen(&apos;/etc/pki/CA/serial&apos;,&apos;r&apos;) 140378285651856:error:20074002:BIO routines:FILE_CTRL:system lib:bss_file.c:404: [root@centos7 CA]# [root@centos7 CA]# echo 0f &gt; serial ##这里例是0f，实际用00开始 [root@centos7 CA]# cat serial 0f [root@centos7 CA]# openssl ca -in app.csr -out /etc/pki/CA/certs/app.crt -days 1000 Using configuration from /etc/pki/tls/openssl.cnf Check that the request matches the signature Signature ok Certificate Details: Serial Number: 15 (0xf) Validity Not Before: Sep 12 19:29:53 2019 GMT Not After : Jun 8 19:29:53 2022 GMT Subject: countryName = CN stateOrProvinceName = beijing organizationName = pan organizationalUnitName = devops commonName = *.magedu.com X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: FC:32:AE:BF:AA:E2:A6:20:CD:2D:7C:99:81:F4:49:70:22:47:F0:B0 X509v3 Authority Key Identifier: keyid:51:A7:DF:E0:DE:4E:95:4C:A6:54:45:E4:7A:FF:17:30:04:59:CD:E8 Certificate is to be certified until Jun 8 19:29:53 2022 GMT (1000 days) Sign the certificate? [y/n]:y 1 out of 1 certificate requests certified, commit? [y/n]y Write out database with 1 new entries Data Base Updated [root@centos7 CA]# ll certs/app.crt -rw-r--r-- 1 root root 3702 Sep 13 03:31 certs/app.crt [root@centos7 CA]# tree . ├── app.csr ├── cacert.pem ├── certs │ └── app.crt ├── crl ├── index.txt ├── index.txt.attr ├── index.txt.old ├── newcerts │ └── 0F.pem ├── private │ └── cakey.pem ├── serial └── serial.old 4 directories, 10 files ##现在可以将文证书文件传给客户机使用 [root@centos7 CA]# scp certs/app.crt 192.168.152.131:/data/ssl root@192.168.152.131&apos;s password: app.crt 创建CA和证书管理查看证书中的信息： openssl x509 -in /PATH/FROM/CERT_FILE -noout -text|issuer|subject|serial|datesopenssl ca -status SERIAL 查看指定编号的证书状态 openssl x509 -in app.crt -noout -text ##查看证书状态 [root@centos7 CA]# cat index.txt ##存放证书信息的数据库。这里的V表示此证书现在是有效的，吊销是R V 220608192953Z 0F unknown /C=CN/ST=beijing/O=pan/OU=devops/CN=*.magedu.com [root@centos7 CA]# cat serial ##下一个证书的编号 10 [root@centos7 CA]# cat serial.old ##之前证书版本的备份 0f ##如果刚才那三项也就是生成新的证书签署的时候那三项设置的不通，发送到centos7后进项的颁发证书就会报错 ，如果不想重新申请可以更改这个文件: vim /etc/pki/tls/openssl.cnf policy = policy_match ##如果这里改成anything那么就是填啥都行，下面的就不用更改了‘ 82 83 # For the CA policy 84 [ policy_match ] 85 countryName = match 86 stateOrProvinceName = optional ##optional表示设置的可以不一样(可选的，随意的) 87 organizationName = match 88 organizationalUnitName = optional 89 commonName = supplied 90 emailAddress = optional 91 ##吊销证书(此前我又建立了一个证书) [root@centos7 CA]# openssl ca -revoke /etc/pki/CA/certs/app2.crt Using configuration from /etc/pki/tls/openssl.cnf Revoking Certificate 10. Data Base Updated [root@centos7 CA]# cat index.txt V 220608192953Z 0F unknown /C=CN/ST=beijing/O=pan/OU=devops/CN=*.magedu.com R 220608223259Z 190912223838Z 10 unknown /C=CN/ST=henan/L=zhengzhou/O=magedu/OU=ops/CN=www.magedu.org ##更新证书吊销列表 [root@centos7 CA]# openssl ca -gencrl -out /etc/pki/CA/crl.pem ##验证某个用户的证书，用上级证书来验证他颁发证书的有效性 openssl verify -CAfile cacert.pem certs/app.crt SSH SSH协议版本v1: 基于CRC-32做MAC，不安全；man-in-middlev2：双方主机协议选择安全的MAC方式 具体的软件实现：OpenSSH: ssh协议的开源实现，CentOS默认安装dropbear：另一个开源实现基于DH算法做密钥交换，基于RSA或DSA实现身份认证两种方式的用户登录认证：基于password；基于key* Openssh软件组成OpenSSH介绍相关包： openssh openssh-clients openssh-server工具：基于C/S结构Client: ssh, scp, sftp，sloginWindows客户端：xshell, putty, securecrt, sshsecureshellclient Server: sshd [root@centos6 data]# vim /etc/ssh/ssh_host_key.pub ##删除他的前面的，和末尾的回车换行 base64 -d ssh_host_rsa_key.pub &gt; pubkey ##得到原始公钥文件 [root@centos6 data]# md5sum pubkey ##然后将它做哈希运算 1280b0eef28fba5de9f63aa933afb6da pubkey ##得到的加密代码 [root@centos7 ~]# rm -fr .ssh ##重新建立ssh连接，通过MD5加密得到的与之进行匹配 [root@centos7 ~]# ssh 192.168.152.131 The authenticity of host &#39;192.168.152.131 (192.168.152.131)&#39; can&#39;t be established. RSA key fingerprint is SHA256:xFjNGR2DgxSIn5nh9YBemaOxXJyrlztd316Ry0b8+WY. RSA key fingerprint is MD5:12:80:b0:ee:f2:8f:ba:5d:e9:f6:3a:a9:33:af:b6:da. Are you sure you want to continue connecting (yes/no)? yes ssh客户端客户端组件：ssh, 配置文件：/etc/ssh/ssh_config Host PATTERNStrictHostKeyChecking no 首次登录不显示检查提示格式：ssh [user@]host [COMMAND]ssh [-l user] host [COMMAND]常见选项-p port：远程服务器监听的端口-b：指定连接的源IP-v：调试模式-C：压缩方式-X：支持x11转发(图形界面)-t：强制伪tty分配ssh -t remoteserver1 ssh -t remoteserver2 ssh remoteserver3ssh -t 192.168.152.131 ssh 192.168.152.130 ssh客户端允许实现对远程系统经验证地加密安全访问当用户远程连接ssh服务器时，会复制ssh服务器/etc/ssh/ssh_host*key.pub（CentOS7默认是ssh_host_ecdsa_key.pub）文件中的公钥到客户机的~./ssh/know_hosts中。下次连接时，会自动匹配相应私钥，不能匹配，将拒绝连接 基于用户和口令登录验证1 客户端发起ssh请求，服务器会把自己的公钥发送给用户2 用户会根据服务器发来的公钥对密码进行加密3 加密后的信息回传给服务器，服务器用自己的私钥解密，如果密码正确，则用户登录成功. 基于key认证基于密钥的登录方式1 首先在客户端生成一对密钥（ssh-keygen）2 并将客户端的公钥ssh-copy-id 拷贝到服务端3 当客户端再次发送一个连接请求，包括ip、用户名4 服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：magedu5 服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端6 得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串发送给服务端7 服务端接受到客户端发来的字符串后，跟之前的字符串进行对比，如果一致，就允许免密码登录.ssh服务登录验证ssh-keygen 生成私钥ssh-copy-id -i /root/.ssh/id_rsa 192.168.152.130 将key文件发送到对应的文件上,这样就已经可以使用了上面建立的私钥并没有设置口令。基于key认证重设私钥口令： ssh-keygen –p但是这样每次连接时都必须输入口令。为了方便我们可以设置一个代理程序known_host保存曾经连过的对方主机的公钥 [root@centos7 ~]# ssh-agent bash [root@centos7 ~]# ssh-add ##钥匙通过命令添加给代理 Enter passphrase for /root/.ssh/id_rsa: ##刚刚设置私钥的口令 Identity added: /root/.ssh/id_rsa (/root/.ssh/id_rsa) ##这样每次连接时就可以直接连接了。但是只能连接一次，退出后就会失效 使用crt生成公钥私钥连接主机crt-tool-Key Generation Wizard 依次默认点击生成公钥和私钥文件(如果最后选择OpenSSH Key format就不需要下面的转换格式)将公钥传到需要连接的主机上,将文件放置~/.ssh目录下ssh-keygen -i -f Identity.pub &gt;&gt; authorized_keys 转换Identity.pub文件的格式，然后追加到文件在crt上连接主机在验证方式这里——Authentication——PublicKey——Propreies选择对应的私钥文件，就可以连上了. 三个机器共用一套公钥私钥——实现互相连接不需要输入密码 ssh-keygen -t rsa -P &quot;&quot; -f ./id_rsa ssh-copy-id 192.168.152.136 scp -rp /root/.ssh/ 192.168.152.131:/root/ scp -rp /root/.ssh/ 192.168.152.140:/root/ scpscp命令：scp [options] SRC… DEST/两种方式： [root@centos7 ~]# scp /etc/fstab/ 192.168.152.131:/data fstab 100% 595 65.5KB/s 00:00 [root@centos7 ~]# scp 192.168.152.131:/root/a.txt ./ a.txt 100% 329 30.4KB/s 00:00 常用选项：-C 压缩数据流-r 递归复制-p 保持原文件的属性信息-q 静默模式-P PORT 指明remote host的监听的端口 ##从远程机器拷贝到远程机器上 scp 192.168.152.136:/etc/centos-release 192.168.152.140:/data rsync命令基于ssh和rsh服务实现高效率的远程系统之间复制文件使用安全的shell连接做为传输方式rsync -av /etc server1:/tmp 复制目录和目录下文件rsync -av /etc/ server1:/tmp 只复制目录下文件比scp更快，只复制不同的文件常用选项：-n 模拟复制过程-v 显示详细过程-r 递归复制目录树-p 保留权限-t 保留时间戳-g 保留组信息-o 保留所有者信息-l 将软链接文件本身进行复制（默认）-L 将软链接文件指向的文件复制-a 存档，相当于–rlptgoD，但不保留ACL（-A）和SELinux属性（-X） [root@centos7 ces]# rsync -r /root/ces 192.168.152.131:/root/ces ##只复制/ces/这个目录到对应目录下 [root@centos7 ces]# rsync -r /root/ces/ 192.168.152.131:/root/ces ##只复制/root/ces/目录下的文件到对应的机器上 ##当对应的机器上已经有我复制过的文件，现在对f1文件追加，再次进行复制rsync就会只复制改动过的文件。 [root@centos7 ces]# echo &gt;&gt; f1 [root@centos7 ces]# rsync -av /root/ces/ 192.168.152.131:/root/ces sending incremental file list f1 sent 41,082 bytes received 71,782 bytes 8,360.30 bytes/sec total size is 314,572,801 speedup is 2,787.18 pssh工具pssh是一个python编写可以在多台服务器上执行命令的工具，也可实现文件复制选项如下：–version：查看版本-h：主机文件列表，内容格式”[user@]host[:port]”-H：主机字符串，内容格式”[user@]host[:port]”-A：手动输入密码模式(当不支持ssh的key认证时，通过 -A选项，使用密码认证批量执行指令)-i：每个服务器内部处理信息输出-l：登录使用的用户名-p：并发的线程数【可选】-o：输出的文件目录【可选】-e：错误输入文件【可选】-t：TIMEOUT 超时时间设置，0无限制【可选】-O：SSH的选项-P：打印出服务器返回信息-v：详细模式点击查看代码 [root@centos7 .ssh]# pssh -H 192.168.152.131 -A -i ifconfig eth0 Warning: do not enter your password if anyone else has superuser privileges or access to your account. Password: [1] 22:36:39 [SUCCESS] 192.168.152.131 ##如果不加-i就会只显示这一行 eth0 Link encap:Ethernet HWaddr 00:0C:29:89:50:C2 inet addr:192.168.152.131 Bcast:192.168.152.255 Mask:255.255.255.0 inet6 addr: fe80::20c:29ff:fe89:50c2/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:1407783 errors:0 dropped:0 overruns:0 frame:0 TX packets:134024 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:1989950231 (1.8 GiB) TX bytes:28218948 (26.9 MiB) ##也可以这样两台主机一起使用，单用的是同一个密码 [root@centos7 .ssh]# pssh -H 192.168.152.131 -H 192.168.152.141 -i -A ifconfig eth0 ##写法不同 [root@centos7 .ssh]# pssh -H &quot;192.168.152.131 192.168.152.141&quot; -i -A ifconfig eth0 ##使用文件列表 [root@centos7 ~]# cat iplist.txt 192.168.152.136 192.168.152.131 192.168.152.141 [root@centos7 ~]# pssh -h iplist.txt -i -A ifconfig eth0 ##查到的信息，文件保存至文件夹下 [root@centos7 pssh]# pssh -h iplist.txt -o /data/pssh -i getent passwd pan [root@centos7 pssh]# ls ##最后自动生成的文件 192.168.152.131 192.168.152.136 192.168.152.141 ##有些命令没有执行需要加&apos;&apos;才会执行 [root@centos7 ~]# pssh -h iplist.txt -i &apos;rm -fr /data/*&apos; ##通过pssh批量关闭seLinux [root@centos7 ~]# pssh -h iplist.txt -i &apos;sed -i &quot;s/^SELINUX=.*/SELINUX=disabled/&quot; /etc/selinux/config&apos; pscp.pssh命令pscp.pssh功能是将本地文件批量复制到远程主机-v 显示复制过程-r 递归复制目录将本地多个文件批量复制到/app/目录pscp.pssh -H 192.168.1.10 /root/f1.sh /root/f2.sh /app/将本地目录批量复制到/app/目录pscp.pssh -H 192.168.1.10 -r /root/test/ /app/点击查看代码 ##将本地的f1.sh复制到远程主机/data的目录下。iplist.txt是远程主机的iP [root@centos7 ~]# pscp.pssh -h /root/iplist.txt /root/f1.sh /data ##也就是先把文件传送过去，再执行 [root@centos7 ~]# pssh -h iplist.txt -i &apos;/data/f1.sh&apos; pslurp命令pslurp功能是将远程主机的文件批量复制到本地-L 指定从远程主机下载到本机的存储的目录-r 递归复制目录点击查看代码 ##从远程主机上拷贝文件/etc/passwd/到本机/data目录上重命名为passwd.bak [root@centos7 ~]# pslurp -h /root/iplist.txt -L /data /etc/passwd passwd.bak [root@centos7 ~]# tree /data ##拷贝后的路径 /data ├── 192.168.152.131 │ └── passwd.bak ├── 192.168.152.136 │ └── passwd.bak └── 192.168.152.142 └── passwd.bak 3 directories, 3 files SSH端口转发本地转发：-L localport:remotehost:remotehostport sshserver-f 后台启用-N 不打开远程shell，处于等待状态-g 启用网关功能点击查看代码 192.168.152.136([root@centos7 ~]# )——192.168.152.131([root@centos6 data]# )这台机器模拟ssh server ——192.168.152.142([root@Tiger data]# ) ##首先拒绝centso7的连接 [root@Tiger data]# iptables -A INPUT -s 192.168.152.136 -j REJECT ##确定已经不能连接，那就需要将中间的那台机器作为跳板去先连接.142的机器 [root@centos7 ~]# telnet 192.168.152.142 Trying 192.168.152.142... telnet: connect to address 192.168.152.142: Connection refused ##查看连接的机器 [root@Tiger data]# ss -nt State Recv-Q Send-Q Local Address:Port Peer Address:Port ESTAB 0 96 ##本地转发，本机端口，要登录的主机ip:端口,桥梁ip 但是这条命令有个缺点就是会自动登录到桥梁主机上(因为我之前做过ssh key验证登录， 所以他会自动登录上)-N表示以前台方式运行就无法敲其他命令，-f后台执行， [root@centos7 ~]# ssh -L 9527:192.168.152.142:23 -Nf 192.168.152.131 [root@centos6 data]# telnet 192.168.152.142 SSH端口转发远程转发:-R sshserverport:remotehost:remotehostport sshserver示例： [root@centos7 ~]# (ssh server)——[root@centos6 data]#(ssh client)——[root@Tiger data]# 发起连接，注意顺序 [root@centos6 ~]# ssh -R 9527:192.168.152.142:23 192.168.152.136 [root@centos7 ~]# telnet 127.0.0.1 9527 ##现在实现了[root@centos7 ~]#和[root@Tiger data]的通讯 动态端口转发 [root@centos6 ~]# ssh -R 9527:192.168.152.142:23 -gfN 192.168.152.136 gateway [root@centos7 ~]# telnet 192.168.152.136 9527 这里可以理解为最左边有多台电脑，然后可以这里连接最右边的那台机器 动态端口转发：-g表示另外一台机器也可以通过端口访问当用firefox访问internet时，本机的1080端口做为代理服务器，firefox的访问请求被转发到sshserver上，由sshserver替之访问internetssh -D 1080 root@sshserver -fNg在本机firefox设置代理socket proxy:127.0.0.1:1080 curl –socks5 127.0.0.1:1080 http://www.qq.com点击查看代码 192.168.152.136([root@centos7 ~]# )——192.168.152.142([root@Tiger data]# )—— 192.168.152.131([root@centos6 data]# )这台机器模拟internet [root@centos6 ~]# echo www.google.com &gt; /var/www/html/index.html [root@centos6 ~]# iptables -A INPUT -s 192.168.152.136 -j REJECT [root@centos7 ~]# curl 192.168.152.131 curl: (7) Failed connect to 192.168.152.131:80; Connection refused [root@centos7 ~]# ssh -D 1080 192.168.152.142 -fN ##现在可以访问了，或者在图形化界面中配置代理以后也可以访问 [root@centos7 ~]# curl --socks5 127.0.0.1:1080 192.168.152.131 现在将本机的Windows电脑ip禁止访问，然后通过136访问到.131 [root@centos6 ~]# iptables -A INPUT -s 192.168.152.1 -j REJECT [root@centos7 ~]# ssh -D 1080 192.168.152.142 -fNg [root@centos7 ~]# curl --socks5 192.168.152.136:1080 192.168.152.131 ##自己指向自己也可以 [root@centos7 ~]# ssh -D 1080 192.168.152.136 -fNg 然后在浏览器里设置代理就可以访问了 ssh服务器服务器端：sshd, 配置文件: /etc/ssh/sshd_config日志文件: cat /var/log/secure限制可登录用户的办法：AllowGroups 允许的组DenyGroups 不允许的组点击查看配置文件信息 #LoginGraceTime 2m ##等待输入用户名时间2分钟 #PermitRootLogin yes ##允许root用户登录 #StrictModes yes ##检查.ssh/文件的所有者，权限等 #MaxAuthTries 6 ##输入口令允许最大的错误次数(其实是一半) #MaxSessions 2 ##表示一个连接里面的最大会话数，就是说连上机器以后，crt有Clone Session的功能，最大允许克隆的次数。 ##这个更改以后，重启sshd服务，crt也要重新连接才会生效。 #PubkeyAuthentication yes ##这里表示支持公钥验证 #PasswordAuthentication yes ##这里表示支持口令验证 #PermitEmptyPasswords no ##禁止空口令登录 GSSAPIAuthentication no ##连接慢 #ClientAliveInterval 2 ##检查客户端是否活跃，2秒检查一次， #ClientAliveCountMax 3 ##连续检查3次，如果没有活动就断开 UseDNS no ##连接慢 banner /etc/ssh/h.txt ##登录提示信息 可以引用下面那个佛的文件 allowusers pan ##只允许用户pan连接 denyusers pan ##黑名单，不允许连接的用户 点击查看代码:拜佛 //////////////////////////////////////////////////////////////////// // _ooOoo_ // // o8888888o // // 88&quot; . &quot;88 // // (| ^_^ |) // // O\ = /O // // ____/`---&apos;\____ // // .&apos; \\| |// `. // // / \\||| : |||// \ // // / _||||| -:- |||||- \ // // | | \\\ - /// | | // // | \_| &apos;&apos;\---/&apos;&apos; | | // // \ .-\__ `-` ___/-. / // // ___`. .&apos; /--.--\ `. . ___ // // .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. // // | | : `- \`.;`\ _ /`;.`/ - ` : | | // // \ \ `-. \_ __\ /__ _/ .-` / / // // ========`-.____`-.___\_____/___.-`____.-&apos;======== // // `=---=&apos; // // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ // // 佛祖保佑 永无BUG 永不修改 // //////////////////////////////////////////////////////////////////// dropbear源码编译安装 1、安装开发包组:yum groupinstall “Development tools”2、下载dropbear-2017.75.tar.bz23、tar xf dropbear-2017.75.tar.bz24、less INSTALL README5、./configure6、make PROGRAMS=”dropbear dbclient dropbearkey dropbearconvert scp”7、make PROGRAMS=”dropbear dbclient dropbearkey dropbearconvert scp” installdropbear -p :2222 -F –E #前台运行.点击查看代码 ##下载(缺少解压) wget https://matt.ucc.asn.au/dropbear/dropbear-2019.78.tar.bz2 [root@centos7 dropbear-2019.78]# ./configure --prefix=/app/dropbear --sysconfdir=/etc/dropbear /app/dropbear 安装目录 /etc/dropbear 配置文件目录 [root@centos7 dropbear-2019.78]# make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot; install [root@centos7 dropbear-2019.78]# cd /app/dropbear/ [root@centos7 dropbear]# mkdir /etc/dropbear [root@centos7 dropbear]# cd /app/dropbear/bin/ [root@centos7 bin]# ./dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key ##生成私钥 [root@centos7 bin]# cd /etc/dropbear/ [root@centos7 dropbear]# ls dropbear_rsa_host_key [root@centos7 dropbear]# cd /app/dropbear/sbin/ ##服务器程序所在目录 [root@centos7 sbin]# ls dropbear [root@centos7 sbin]# ./dropbear -FE -p 22222 ##启动服务，注意这是以前台方式连接的，不能敲别的命令 [root@centos6 ~]# ssh 192.168.152.136 -p 22222 ##用另外一台机器连接，可以进入 [root@centos7 dropbear]# cd /app/dropbear/bin/ ##作为客户端 [root@centos7 bin]# ./dbclient 192.168.152.131 ##连接其他机器 [root@centos7 bin]# ./scp /etc/fstab 192.168.152.131:/data ##这里使用scp报错,应该是scp间接 ##调用了dbclient,但是dbclient要求必须放在/usr/bin/dbclient,但是这里是放到了自定义的目录 /usr/bin/dbclient: No such file or directory lost connection [root@centos7 bin]# ln -s /app/dropbear/bin/dbclient /usr/bin/dbclient ##所以创造一个软链接就行了 [root@centos7 bin]# ./scp /etc/fstab 192.168.152.131:/data ##成功执行 ##将他写入变量，PATH在最后表示默认就是用的我新编译的服务，不用自带的命令 [root@centos7 bin]# echo &apos;PATH=/app/dropbear/bin:/app/dropbear/sbin:$PATH&apos; &gt; /etc/profile.d/dropbear.sh [root@centos7 bin]# . /etc/profile.d/dropbear.sh ##要是不要了，就删除所有的目录 [root@centos7 ~]# rm -fr /app/dropbear/ [root@centos7 data]# rm -fr /data/dropbear-2019.78* [root@centos7 data]# rm -fr /etc/profile.d/dropbear.sh aide当一个入侵者进入了你的系统并且种植了木马，通常会想办法来隐蔽这个木马（除了木马自身的一些隐蔽特性外，他会尽量给你检查系统的过程设置障碍），通常入侵者会修改一些文件，比如管理员通常用ps -aux来查看系统进程，那么入侵者很可能用自己经过修改的ps程序来替换掉你系统上的ps程序，以使用ps命令查不到正在运行的木马程序。如果入侵者发现管理员正在运行crontab作业，也有可能替换掉crontab程序等等。所以由此可以看出对于系统文件或是关键文件的检查是很必要的。目前就系统完整性检查的工具用的比较多的有两款：Tripwire和AIDE，前者是一款商业软件，后者是一款免费的但功能也很强大的工具•AIDE(Advanced Intrusion Detection Environment)•高级入侵检测环境)是一个入侵检测工具，主要用途是检查文件的完整性，审计计算机上的那些文件被更改过了•AIDE能够构造一个指定文件的数据库，它使用aide.conf作为其配置文件。AIDE数据库能够保存文件的各种属性，包括：权限(permission)、索引节点序号(inode number)、所属用户(user)、所属用户组(group)、文件大小、最后修改时间(mtime)、创建时间(ctime)、最后访问时间(atime)、增加的大小以及连接数。AIDE还能够使用下列算法：sha1、md5、rmd160、tiger，以密文形式建立每个文件的校验码或散列号•这个数据库不应该保存那些经常变动的文件信息，例如：日志文件、邮件、/proc文件系统、用户起始目录以及临时目录. 配置文件aide.conf定义规则 vim /etc/aide.conf 定义监控文件的各项规则 @@define DBDIR /var/lib/aide ##存放的数据库路径 @@define LOGDIR /var/log/aide ##日志 database=file:@@{DBDIR}/aide.db.gz ##文件名，这个文件不会生成，这个最后生成的文件名，需要自己改 database_out=file:@@{DBDIR}/aide.db.new.gz ##数据库生成的是这个文件名，改成上面的那个，再做比较。 gzip_dbout=yes ##是否支持压缩 TEST = p+u+g+s+md5 ##这里表示需要检测的属性规则。我自定义监控属性 例子看下面 /data/ TEST ##只有这两行是我自定义的，其他为解释说明。 !/data/f2 ##表示忽略这个文件的检查。我自定义的，例子看下面 ## R=p+i+n+u+g+s+m+c+md5 权限+索引节点+链接数+用户+组+大小+最后一次修改时间+创建时间+md5校验值 *************************点击查看aide例:************************* cp /etc/fstab f1 cp /etc/fstab f2 cp /etc/fstab f3 到/data/目录 [root@centos7 data]# aide --init AIDE, version 0.15.1 ### AIDE database at /var/lib/aide/aide.db.new.gz initialized. [root@centos7 data]# cd /var/lib/aide/ [root@centos7 aide]# mv aide.db.new.gz aide.db.gz [root@centos7 aide]# aide -C AIDE, version 0.15.1 ### All files match AIDE database. Looks okay! [root@centos7 aide]# vim /data/f1 ##给f1增加一个空格后，再次检测 [root@centos7 aide]# aide -C ##检测除了问题 AIDE 0.15.1 found differences between database and filesystem!! Start timestamp: 2019-09-20 10:41:15 Summary: Total number of files: 4 Added files: 0 Removed files: 0 Changed files: 1 --------------------------------------------------- Changed files: --------------------------------------------------- changed: /data/f1 --------------------------------------------------- Detailed information about changes: --------------------------------------------------- File: /data/f1 Size : 595 , 596 MD5 : KrUGK6VGLvJlNn96phO7Ww== , /TMig1B375fmyYvSnIojSw== ##如果说现在就想要更改后的文件，可以直接更新数据库，以现在的文件为标准 [root@centos7 aide]# aide --update ##更新数据库 ##然后他还会在目录中生成新的文件，更改文件名后查询 [root@centos7 aide]# mv /var/lib/aide/aide.db.new.gz aide.db.gz [root@centos7 aide]# aide -C ##aide --help 查看帮助 sudo命令ls -l /usr/bin/sudosudo –i –u wang 切换身份sudo [-u user] COMMAND-V 显示版本信息等配置信息-u user 默认为root-l,ll 列出用户在主机上可用的和被禁止的命令-v 再延长密码有效期限5分钟,更新时间戳-k 清除时间戳（1970-01-01），下次需要重新输密码-K 与-k类似，还要删除时间戳文件-b 在后台执行指令-p 改变询问密码的提示符号示例：-p &quot;password on %h for user %p:&quot; 表示主机，p表示用户[pan@centos6 sudo]$ sudo -p &quot;password on %h for user %p:&quot; cat /etc/messages时间戳文件：/var/db/sudo日志文件：/var/log/securevisudo 可以检查文件的语法，但是他没有高亮，我们可以声明一下变量export EDITOR=vim 再次打开就有了visudo -c 也可以检查语法，后面不用接文件。 ***********************sudo例子*********************** [root@centos7 pan]# vim /etc/sudoers 92 root ALL=(ALL) ALL 93 pan ALL=(root) /usr/bin/mount /dev/cdrom /data,/usr/bin/umount 94 ##第一个ALL代表用户能从那个主机上登录进来 95 ##root代表pan能代替谁的权限来操作 96 ##最后表示他能执行什么命令 [root@centos7 pan]# su pan [pan@centos7 ~]$ sudo mount /dev/cdrom /data ##注意这里的命令要和上面写的一样，一个字符都不能错 ##上面默认是root用户，如果定义了别的用户需要用-u username 指定 ##配置文件中的 %wheel ALL=(ALL) ALL ##很危险 [root@centos7 pan]# gpasswd -a pan wheel ##文件中的这行表示加入了wheel组的人,拥有root权限。 sudo -i: 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。 提示输入密码时该密码为当前账户的密码。没有时间限制。执行该命令后提示符变为“#”而不是“$”。想退回普通账户时可以执行“exit”或“logout” 。 [root@centos6 ~]# vim /etc/sudoers.d/test pan ALL= sudoedit ##这里表示pan用户能够使用sudoedit这个命令来更改sudo配置文件 sudo 别名授权sudoers授权规则格式：用户 登入主机=(代表用户) 命令示例：root ALL=(ALL) ALL格式说明：user: 运行命令者的身份host: 通过哪些主机(runas)：以哪个用户的身份command: 运行哪些命令-----------------------------------------sudo别名例----------------------------------------- 别名 Users和runas: username #uid %group_name %#gid user_alias|runas_alias host: ip或hostname network(/netmask) host_alias command: command name directory sudoedit Cmnd_Alias sudo别名和示例 别名有四种类型：User_Alias, Runas_Alias, Host_Alias ，Cmnd_Alias 别名格式：[A-Z]([A-Z][0-9]_)* 别名定义：Alias_Type NAME1 = item1, item2, item3 : NAME2 = item4, item5 示例1： Student ALL=(ALL) ALL %wheel ALL=(ALL) ALL 示例2： student ALL=(root) /sbin/pidof,/sbin/ifconfig %wheel ALL=(ALL) NOPASSWD: ALL 示例3 User_Alias NETADMIN= netuser1,netuser2 Cmnd_Alias NETCMD = /usr/sbin/ip NETADMIN ALL=（root） NETCMD 示例4 User_Alias SYSADER=wang,mage,%admins(组) User_Alias DISKADER=tom Host_Alias SERS=www.magedu.com,172.16.0.0/24 Runas_Alias OP=root（代替谁） Cmnd_Alias SYDCMD=/bin/chown,/bin/chmod Cmnd_Alias DSKCMD=/sbin/parted,/sbin/fdisk SYSADER SERS= SYDCMD,DSKCMD (前面空格没写，默认就代表root) DISKADER ALL=(OP) DSKCMD 示例4 User_Alias ADMINUSER = adminuser1,adminuser2 Cmnd_Alias ADMINCMD = /usr/sbin/useradd，/usr/sbin/usermod, /usr/bin/passwd [a-zA-Z]*, !/usr/bin/passwd root ADMINUSER ALL=(root) NOPASSWD:ADMINCMD,PASSWD:/usr/sbin/userdel（这里表示这里删除用户必须要输入口令） 示例5 Defaults:wang runas_default=tom wang ALL=(tom,jerry) ALL ##(这里表示wang在任何主机上代表两个用户，默认用户就代表tom，只有需要代表jerry才需要使用-u) 示例6 wang 192.168.1.6,192.168.1.8=(root) /usr/sbin/,!/usr/sbin/useradd ##/usr/sbin/这个文件夹，表示文件夹下所有的命令都能执行 示例7 wang ALL=(ALL) /bin/cat /var/log/messages* ##这条命令有个bug [pan@centos6 root]$ sudo cat /var/log/messages /etc/shadow ##在最后居然可以查看密码文件 pan ALL=(root) /bin/cat /var/log/messages*,!/bin/cat /var/log/messages* * ##配置文件需要这样改 TCP_Wrappers介绍作者：Wieste Venema，IBM，Google工作在第四层（传输层）的TCP协议对有状态连接的特定服务进行安全检测并实现访问控制以库文件形式实现某进程是否接受libwrap的控制取决于发起此进程的程序在编译时是否针对libwrap进行编译的判断服务程序是否能够由tcp_wrapper进行访问控制的方法：ldd /PATH/TO/PROGRAM|grep libwrap.so strings PATH/TO/PROGRAM|grep libwrap.so cat /etc/hosts.deny sshd: 192.168.152.136 ##只需要在机器行添加这一行，别的机器就无法连接。 ##/etc/hosts.allow文件的优先级比/etc/hosts.deny高，也就是说两个文件如果都有同样一个地址那么也是允许连接的。 [root@centos7 ~]# rpm -ql telent-server /etc/xinetd.d/telnet /usr/sbin/in.telnetd ##主程序名 /usr/share/man/man5/issue.net.5.gz /usr/share/man/man8/in.telnetd.8.gz /usr/share/man/man8/telnetd.8.gz [root@centos6 ~]# cat cat /etc/hosts.deny in.telnetd,sshd:192.168.152.136 ##如果有多个IP可以sshd@192.168.152.136 in.telnetd,sshd:172.18. EXPECT 172.18.0. EXPECT 172.18.0.7 ##在172.18.这个网段中，172.18.0.这个网段不被拒绝，但是172.18.0.7这台机器被拒绝 TCP_Wrappers的使用主机有多个IP，可用@hostIP来实现控制如：in.telnetd@192.168.0.254 示例：只允许192.168.1.0/24的主机访问 sshd /etc/hosts.allow sshd: 192.168.1. /etc/hosts.deny sshd :ALL 示例：只允许192.168.1.0/24的主机访问telnet和vsftpd服务 /etc/hosts.allow vsftpd,in.telnetd: 192.168.1. /etc/host.deny vsftpd,in.telnetd: ALL deny 主要用在/etc/hosts.allow定义“拒绝”规则 如：vsftpd: 172.16. :deny allow 主要用在/etc/hosts.deny定义“允许”规则 如：vsftpd:172.16. :allow spawn 启动一个外部程序完成执行的操作 sshd: ALL :spawn echo &quot;$(date +%%F) login attempt from %c to %s,%d&quot; &gt;&gt;/data/log 在/etc/hosts.allow中添加，允许登录，并记录日志 在/etc/hosts.deny中添加，拒绝登录，并记录日志 %c 客户端信息 %s 服务器端信息 %d 服务名 %p 守护进程的PID %% 表示% twist 实际动作是拒绝访问,使用指定操作替换当前服务,标准输出和ERROR发送到客户端,默认至/dev/null centos6 /etc/hosts.allow内容:in.telnetd:192.168.152. :twist /bin/echo &quot;403 forbindden&quot; [root@centos7 ~]# telnet 192.168.152.131 Trying 192.168.152.131... Connected to 192.168.152.131. Escape character is &#39;^]&#39;. 403 forbindden Connection closed by foreign host. TCP_Wrappers介绍作者：Wieste Venema，IBM，Google工作在第四层（传输层）的TCP协议对有状态连接的特定服务进行安全检测并实现访问控制以库文件形式实现某进程是否接受libwrap的控制取决于发起此进程的程序在编译时是否针对libwrap进行编译的判断服务程序是否能够由tcp_wrapper进行访问控制的方法：ldd /PATH/TO/PROGRAM|grep libwrap.sostrings PATH/TO/PROGRAM|grep libwrap.so--------------------------查询服务是受TCP_Wrappers的控制-------------------------- [root@centos6 data]# rpm -ql telnet-server /etc/xinetd.d/telnet ##里面没有libwrap.so但是他是受xinetd管理的 /usr/sbin/in.telnetd /usr/share/man/man5/issue.net.5.gz /usr/share/man/man8/in.telnetd.8.gz /usr/share/man/man8/telnetd.8.gz [root@centos6 data]# ldd /usr/sbin/in.telnetd linux-vdso.so.1 =&gt; (0x00007ffd506d2000) libutil.so.1 =&gt; /lib64/libutil.so.1 (0x00007fcca686d000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fcca64d9000) /lib64/ld-linux-x86-64.so.2 (0x000055659e77b000) [root@centos6 data]# which xinetd /usr/sbin/xinetd [root@centos6 data]# ldd /usr/sbin/xinetd ##查询到了 linux-vdso.so.1 =&gt; (0x00007ffc9b3b7000) libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f49db17d000) libwrap.so.0 =&gt; /lib64/libwrap.so.0 (0x00007f49daf72000) libnsl.so.1 =&gt; /lib64/libnsl.so.1 (0x00007f49dad58000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f49daad4000) libcrypt.so.1 =&gt; /lib64/libcrypt.so.1 (0x00007f49da89d000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f49da508000) libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f49da304000) /lib64/ld-linux-x86-64.so.2 (0x000055ca092e3000) libfreebl3.so =&gt; /lib64/libfreebl3.so (0x00007f49da101000) cat /etc/hosts.deny sshd: 192.168.152.136 ##只需要在机器行添加这一行，别的机器就无法连接。 ##/etc/hosts.allow文件的优先级比/etc/hosts.deny高，也就是说两个文件如果都有同样一个地址那么也是允许连接的。 [root@centos7 ~]# rpm -ql telent-server /etc/xinetd.d/telnet /usr/sbin/in.telnetd ##主程序名 /usr/share/man/man5/issue.net.5.gz /usr/share/man/man8/in.telnetd.8.gz /usr/share/man/man8/telnetd.8.gz [root@centos6 ~]# cat cat /etc/hosts.deny in.telnetd,sshd:192.168.152.136 ##如果有多个IP可以sshd@192.168.152.136 in.telnetd,sshd:172.18. EXPECT 172.18.0. EXPECT 172.18.0.7 ##在172.18.这个网段中，172.18.0.这个网段不被拒绝，但是172.18.0.7这台机器被拒绝 TCP_Wrappers的使用主机有多个IP，可用@hostIP来实现控制如：in.telnetd@192.168.0.254--------------------------使用例子-------------------------- 示例：只允许192.168.1.0/24的主机访问 sshd /etc/hosts.allow sshd: 192.168.1. /etc/hosts.deny sshd :ALL 示例：只允许192.168.1.0/24的主机访问telnet和vsftpd服务 /etc/hosts.allow vsftpd,in.telnetd: 192.168.1. /etc/host.deny vsftpd,in.telnetd: ALL ##拒绝里面允许，允许里面拒绝 deny 主要用在/etc/hosts.allow定义“拒绝”规则 如：vsftpd: 172.16. :deny allow 主要用在/etc/hosts.deny定义“允许”规则 如：vsftpd:172.16. :allow spawn 启动一个外部程序完成执行的操作 在/etc/hosts.allow中添加，允许登录，并记录日志 在/etc/hosts.deny中添加，拒绝登录，并记录日志 %c 客户端信息 %s 服务器端信息 %d 服务名 %p 守护进程的PID %% 表示% 例：将此添加到文件 sshd: ALL :spawn echo &quot;$(date +%%F) login attempt from %c to %s,%d&quot; &gt;&gt;/data/log [root@centos6 ~]# cat /data/log 2019-07-13 login attempt from 192.168.152.136 to sshd@192.168.152.131,sshd twist 实际动作是拒绝访问,使用指定操作替换当前服务,标准输出和ERROR发送到客户端,默认至/dev/null centos6 /etc/hosts.allow内容: in.telnetd:192.168.152. :twist /bin/echo &quot;403 forbindden&quot; [root@centos7 ~]# telnet 192.168.152.131 Trying 192.168.152.131... Connected to 192.168.152.131. Escape character is &apos;^]&apos;. 403 forbindden Connection closed by foreign host. tcpdmatch [-d] daemon[@host] client(直接改文件可能有风险，所以可以自己创建文件来测试) -d 测试当前目录下的hosts.allow和hosts.deny [root@centos6 data]# cat hosts.allow hosts.deny in.telnetd: 192.168.34. in.telnetd:ALL [root@centos6 data]# tcpdmatch -d in.telnetd 192.168.34.5 client: address 192.168.34.5 server: process in.telnetd access: granted PAM认证机制PAM:Pluggable Authentication Modules认证库：文本文件，MySQL，NIS，LDAP等Sun公司于1995 年开发的一种与认证相关的通用框架机制PAM 是关注如何为服务验证用户的 API，通过提供一些动态链接库和一套统一的API，将系统提供的服务和该服务的认证方式分开使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序一种认证框架，自身不做认证 PAM认证机制它提供了对所有服务进行认证的中央机制，适用于本地登录，远程登录，如：telnet,rlogin,fsh,ftp,点对点协议PPP，su等应用程序中，系统管理员通过PAM配置文件来制定不同应用程序的不同认证策略；应用程序开发者通过在服务程序中使用PAM API(pam_xxxx( ))来实现对认证方法的调用；而PAM服务模块的开发者则利用PAM SPI来编写模块（主要调用函数pam_sm_xxxx( )供PAM接口库调用，将不同的认证机制加入到系统中；PAM接口库（libpam）则读取配置文件，将应用程序和相应的PAM服务模块联系起来 PAM相关文件模块文件目录：/lib64/security/*.so环境相关的设置：/etc/security/主配置文件:/etc/pam.conf，默认不存在为每种应用模块提供一个专用的配置文件：/etc/pam.d/APP_NAME注意：如/etc/pam.d存在，/etc/pam.conf将失效. pam认证原理PAM认证一般遵循这样的顺序：Service(服务)→PAM(配置文件)→pam_*.soPAM认证首先要确定那一项服务，然后加载相应的PAM的配置文件(位于/etc/pam.d下)，最后调用认证文件(位于/lib/security下)进行安全认证 PAM认证过程：1.使用者执行/usr/bin/passwd 程序，并输入密码2.passwd开始调用PAM模块，PAM模块会搜寻passwd程序的PAM相关设置文件，这个设置文件一般是在/etc/pam.d/里边的与程序同名的文件，即PAM会搜寻/etc/pam.d/passwd此设置文件3.经由/etc/pam.d/passwd设定文件的数据，取用PAM所提供的相关模块来进行验证4.将验证结果回传给passwd这个程序，而passwd这个程序会根据PAM回传的结果决定下一个动作（重新输入密码或者通过验证）. PAM认证机制 通用配置文件/etc/pam.conf格式application type control module-path arguments 专用配置文件/etc/pam.d/* 格式type(类型) control module-path(模块名) arguments(模块的参数)说明： 服务名（application）telnet、login、ftp等，服务名字“OTHER”代表所有没有在该文件中明确配置的其它服务 模块类型（module-type） control PAM库该如何处理与该服务相关的PAM模块的成功或失败情况 module-path 用来指明本模块对应的程序文件的路径名 Arguments 用来传递给该模块的参数 模块类型（module-type）Auth 账号的认证和授权Account 与账号管理相关的非认证类的功能，如：用来限制/允许用户对某个服务的访问时间，当前有效的系统资源(最多可以有多少个用户)，限制用户的位置(例如：root用户只能从控制台登录)Password 用户修改密码时密码复杂度检查机制等功能Session 用户获取到服务之前或使用服务完成之后需要进行一些附加的操作，如：记录打开/关闭数据的信息，监视目录等-type 表示因为缺失而不能加载的模块将不记录到系统日志,对于那些不总是安装在系统上的模块有用 ControlPAM库如何处理与该服务相关的PAM模块成功或失败情况两种方式实现：简单和复杂 简单方式实现：一个关健词实现 required ：一票否决，表示本模块必须返回成功才能通过认证，但是如果该模块返回失败，失败结果也不会立即通知用户，而是要等到同一type中的所有模块全部执行完毕再将失败结果返回给应用程序，即为必要条件 requisite ：一票否决，该模块必须返回成功才能通过认证，但是一旦该模块返回失败，将不再执行同一type内的任何模块，而是直接将控制权返回给应用程序。是一个必要条件 sufficient ：一票通过，表明本模块返回成功则通过身份认证的要求，不必再执行同一type内的其它模块，但如果本模块返回失败可忽略，即为充分条件 optional ：表明本模块是可选的，它的成功与否不会对身份认证起关键作用，其返回值一般被忽略 include： 调用其他的配置文件中定义的配置信息. pam_nologin.sotouch /etc/nologin 建立这个文件以后，系统只允许root用户登录 su 除外,因为没有调用 cd /etc/pam.d grep nologin * 查看哪些文件调用了这个模块 login:account required pam_nologin.so 将这行添加到su文件中，这时su也无法切换用户了 echo &quot;此文件的作用不允许普通用户登录&quot; &gt;&gt; /etc/nologin 这个文件的内容，最后会在无法的登录的时候打印到屏幕上 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three]]></title>
    <url>%2F2019%2F06%2F20%2F%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[脚本.. if语句条件选择if语句选择执行：注意：if语句可嵌套单分支if 判断条件;then 条件为真的分支代码fi 双分支if 判断条件; then 条件为真的分支代码else 条件为假的分支代码fi. 多分支if 判断条件1; then 条件1为真的分支代码elif 判断条件2; then 条件2为真的分支代码elif 判断条件3; then 条件3为真的分支代码else 以上条件都为假的分支代码fi逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句=~：左侧字符串是否能够被右侧的PATTERN（正则表达式）所匹配 若匹配则为真，否则为假 条件判断：case语句case 变量引用 inPAT1)分支1;;PAT2)分支2;;…*)默认分支;;esac [root@centos7 data]# cat yes.sh read -p &quot;Do you agree(yes or no)?&quot; ans ans=`echo $ans | tr &#39;A-Z&#39; &#39;a-z&#39;` case $ans in y|yes|ye) echo &quot;OK&quot; ;; no|n) echo &quot;NO&quot; ;; *) echo &quot;input false&quot; ;; esac ans=YE;[[ $ans =~ ^([Yy]|[Yy][Ee][Ss])$ ]] &amp;&amp; echo yes 后面的括号的意思表示里面是一个整体，要么是[Yy]要么是[Yy][Ee][Ss]。然后再^和$。 循环循环执行将某代码段重复运行多次重复运行多少次循环次数事先已知循环次数事先未知有进入条件和退出条件for, while, until列出当前文件夹下的文件名 for num in /data/*.sh ;do echo filename is $num;done #!/bin/bash 从1加到100得出结果5050，这里是算术运算，有记录sum=0for i in {1..100};do let sum=sum+idoneecho sum=$sum问题：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个，第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘多少个桃子？ #!/bin/bash sum=1 for i in {9..1} do let sum=(sum+1)*2 done echo &quot;桃子的个数是：$sum&quot; #!/bin/bash 猴子的升级版本 read -p &quot;请输入天数：&quot; day read -p &quot;请输入最后一天剩下的个数：&quot; sum let day=day-1 for i in `seq $day` do let sum=(sum+1)*2 done echo &quot;桃子的个数是 $sum&quot; 将/data文件夹下，所有的文件后缀改为.log结尾的文件。#!/bin/bash for i in /data/*;do .*表示贪婪模式，找到最后一个. 然后后面的字符让.*去匹配 file=`echo $i | sed -nr &#39;s/(.*)\..*/\1/p&#39;` mv $i $file.sh done 将该目录下的后缀名都修改为sh结尾的文件for ceshi in `ls | sed -nr &#39;s/.*\.(.*)/\1/p&#39; | sort -u`;do rename $ceshi sh *;done 判断网段中主机在线状态#!/bin/bash ip=192.168.100 for id in {1..254};do { #这里表示同时运行 一次ping 1-254个地址 if ping -c1 -w1 $ip.$id &amp;&gt;/dev/null;then #-c1是指ping的次数，-w是指执行的最后期限，也就是执行的时间，单位为秒 echo $ip.$id is up else echo $ip.$id is down fi }&amp; done wait #wait等待后台执行的命令，执行完后退出。如果不写后台命令不敲操作他不会退出。 #!/bin/bash 交互式 read -p &quot;please input ip address: &quot; ip ip=`echo $ip | sed -rn &#39;s/(.*)\..*/\1/p&#39;` for id in {1..254};do { #这里表示同时运行 一次ping 1-254个地址 if ping -c1 -w1 $ip.$id &amp;&gt;/dev/null;then #-c1是指ping的次数，-w是指执行的最后期限，也就是执行的时间，单位为秒 echo $ip.$id is up &gt;&gt; a.txt else echo $ip.$id is down fi }&amp; done wait #wait等待后台执行的命令，执行完后退出。如果不写后台命令不敲操作他不会退出。 根据IP地址和子网掩码得出交互式打印等腰三角形#!/bin/bash read -p &quot;please input line: &quot; line #用户输入的总行数 for i in `seq $line`;do let star=$i*2-1 #&quot;*&quot;的个数 let space=$line-$i #空格的个数=总行数-行号 for j in `seq $space`;do echo -n &quot; &quot; done for k in `seq $star`;do #循环&quot;*&quot;的个数 echo -n &quot;*&quot; #-n 不换行输出 done echo #换行，让接下来的&quot;*&quot;换行输出 done 99乘法表#!/bin/bash for i in `seq 9`;do for j in `seq $i`;do let sum=j*i echo -e &quot;$j*$i=$sum\t\c&quot; \t表示:插入Tab字符 done echo done for循环的特殊格式99乘法表 #!/bin/bash for((i=1;i&lt;=9;i++));do for((j=1;j&lt;=$i;j++));do echo -en &quot;${i}*${j}=$[$i*$j]\t\c&quot; done echo done 乱码文件，tr -c:字符串1中字符集的补集替换此字符集，要求字符集为ASCI。 head -c:取前8个字符，-n是前n行。 cat /dev/urandom | tr -dc &#39;[[:alnum:]]&#39; | head -c 8 whilewhile循环while CONDITION(这里可以写 :或者ture 就是死循环); do循环体doneCONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”终止循环因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正进入条件：CONDITION为true退出条件：CONDITION为false i=1;while [ $i -le 100 ];do let sum+=i;let i++;done;echo sum=$sum until循环until CONDITION; do循环体done进入条件： CONDITION 为false退出条件： CONDITION 为true 循环控制语句continue用于循环体中continue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层while CONDTIITON1; do CMD1…if CONDITION2; then continuefi CMDn…done #!/bin/bash i=0 until [ &quot;$i&quot; -gt 9 ];do let i++ if [ &quot;$i&quot; -eq 5 ];then continue fi echo i=$i done continue:结束当次循环break：结束当前整个循环(是循环不是条件判断语句)，直接跳入下一个循环。循环控制语句break用于循环体中break [N]：提前结束第N层循环，最内层为第1层 #!/bin/bash for ((i=1;i&lt;=3;i++));do for((j=1;j&lt;=10;j++));do if [ &quot;$j&quot; -eq 5 ];then continue 2 #这里默认是1,2的意思是结束本次循环，退到上轮循环。 fi echo j=$j done echo i=$i # 上面是continue 2 所以后面的都不会执行 done echo &quot;************************************************************************&quot; for ((i=1;i&lt;=3;i++));do for((j=1;j&lt;=10;j++));do if [ &quot;$j&quot; -eq 5 ];then break 2 #默认是1，所以2会跳到上层结束掉上层循环，这里只会输出： fi #i=1 echo j=$j #i=2 done #i=3 echo i=$i #i=4 done 监测服务的运行，失败自动运行 #!/bin/bash SLEEPTIME=30 #定义变量SLEEPTIME=30秒 until false;do if ! killall -0 httpd &amp;&gt;/dev/null;then service httpd restart &amp;&gt;/dev/null; echo &quot;At `date +&#39;%F %T&#39;` httpd restarted&quot; &gt;&gt;/data/httpd.log break;#结束循环，退出程序 fi sleep $SLEEPTIME;#如果不匹配if语句里面内容就执行这里的睡眠30s done lastbssh 用户名@ip地址 或者 ssh IP地址lastb 查看失败登录的信息。[root@centos7 ~]# lastb | awk &#39;$3 ~ /^[[:digit:]]/{print $3}&#39; | sort | uniq -c | awk &#39;$1 &gt;=3{print $2}&#39;查看访问的链接IP地址，统计大于等于3次的 grep取IP地址0-9 10-99 100-199 200-249 250-255ifconfig | grep -Eo &quot;(([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])&quot; 批量创建用户用shift#!/bin/bash while : ;do [ -z &quot;$1&quot; ] &amp;&amp; break useradd $1 &amp;&amp; echo $1 is created shift done bash ceshi.txt a b c 可接多个用户名 #!/bin/bash while [ &quot;$1&quot; ];do useradd $1 &amp;&amp; echo $1 is created shift done #!/bin/bash while [ $# -gt 0 ];do #or (( $#&gt;0 )) echo $* shift done $RANDOM: 随机输出数字取余:除数=余数范围最大值+1x%11 余数范围:0-10 while循环的特殊用法(遍历文件的每一行)while read line;do 循环体 done &lt; /PATH/FROM/SOMEFILE依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将行复制给变量line df磁盘%&gt;10输出#!/bin/bash df | while read diskspace;do space=`echo $diskspace | sed -nr &quot;/^\/dev\/sd/s/.* (.+)%.*/\1/p&quot;` disk=`echo $diskspace | sed -nr &quot;/^\/dev\/sd/s/([^ ]+).*/\1/p&quot;` if [[ $space =~ ^[0-9+$] ]];then if [ $space -gt 10 ];then echo $disk:$space fi fi done 查看ip链接次数大于2记录到文件#!/bin/bash netstat -nta | sed -nr &quot;/^tcp/ s/.* ([1-9].*):.*/\1/p&quot; | sort | uniq -c | while read iplist ;do linknum=`echo $iplist | cut -d &quot; &quot; -f 1` ip=`echo $iplist | cut -d &quot; &quot; -f 2` if [ $linknum -ge 2 ];then echo $ip &gt;&gt; /data/cracker_ip.log fi done select 语句select循环与菜单select variable in list do循环体命令doneselect 循环主要用于创建菜单，按数字顺序排列的菜单项将显示在标准错误上，并显示 PS3 提示符，等待用户输入用户输入菜单列表中的某个数字，执行相应的命令用户输入被保存在内置变量 REPLY 中select 是个无限循环，因此要记住用 break 命令退出循环，或用 exit 命令终止脚本。也可以按 ctrl+c 退出循环select 经常和 case 联合使用与 for 循环类似，可以省略 in list，此时使用位置参量 #!/bin/bash PS3=&quot;please input a number: &quot; select MENU in 拉面 烩面 盖饭 饺子 包子 quit;do case $REPLY in 1|2) echo &quot;The price is 15元&quot; ;; 3|5) echo &quot;The price is 20元&quot; ;; 4) echo &quot;The price is 25元&quot; ;; 6) echo &quot;bye&quot; break ;; *) echo &quot;Input false&quot; esac done bcbc 1.06.95 Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc. This is free software with ABSOLUTELY NO WARRANTY. For details type `warranty&#39;. obase=2 输出二进制 222 输入原始数字回车 11011110 计算机输出二进制 ^C (interrupt) Exiting bc. 函数介绍函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运行，而是shell程序的一部分函数和shell程序比较相似，区别在于Shell程序在子Shell中运行而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变量进行修改 定义函数函数由两部分组成：函数名和函数体help function语法一：f_name（）{…函数体…}语法二：function f_name {…函数体…}语法三：function f_name （）{…函数体…} 函数使用函数的定义和使用：可在交互式环境下定义函数可将函数放在脚本文件中作为它的一部分可放在只包含函数的单独文件中调用：函数只有被调用才会执行调用：给定函数名函数名出现的地方，会被自动替换为函数代码函数的生命周期：被调用时创建，返回时终止 [root@centos7 ~]#sysinfo(){ hostname;cat /etc/centos-release; } [root@centos7 ~]# sysinfo centos7.localdomain CentOS Linux release 7.5.1804 (Core) 还可以给变量赋值 sysinfo(){ name=magedu;echo $name;hostname;cat /etc/centos-release; } [root@centos7 ~]# sysinfo magedu centos7.localdomain CentOS Linux release 7.5.1804 (Core) [root@centos7 ~]# echo $name magedu 删除函数 unset sysinfo查看定义的函数 declare -f sysinfo 调用在diao文件里面调用functions文件里面的内容 [root@centos7 data]# cat functions 普通的文本文件 version(){ sed -nr &quot;s/.* ([0-9])\..*/\1/p&quot; /etc/centos-release } sysinfo(){ echo Hostname is `hostname` echo OS version is `version` } [root@centos7 data]# cat diao.sh #!/bin/bash . functions 调用函数路径 sysinfo 调用函数——猜数字#!/bin/bash . /data/functions n=$[RANDOM%11] while read -p &quot;input a 0-10 number: &quot; num ;do is_digit $num || { echo input 0000 no digit; continue; } if [ $num -gt $n ];then echo $num is greater elif [ $num -lt $n ];then echo $num is lower else echo &quot;guess right!&quot; break fi done cat functions is_digit(){ [[ &quot;$1&quot; =~ ^[0-9]+$ ]] &amp;&amp; true || false } 6,7取ip地址:ifconfig | sed -nr &quot;2s/[^0-9]+([0-9.]+).*/\1/p&quot;return#!/bin/bash func(){ echo fun1_cmd1 #return #退出函数本身(提前结束函数) exit #这里退出整个脚本 echo fun1_cmd2 } func #使用return这里也会执行 echo &quot;return&quot; 删除shell函数现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命令完成删除函数命令格式为：unset function_name示例：unset findit再键入set命令，函数将不再显示环境函数使子进程也可使用声明：export -f function_name查看：export -f 或 declare -xf 函数参数函数可以接受参数：传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；例如“testfunc arg1 arg2 …”在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $# 等特殊变量 函数变量变量作用域：环境变量：当前shell和子shell有效本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数局部变量：函数的生命周期；函数结束时变量被自动销毁注意：如果函数中有局部变量，如果其名称同本地变量，使 用局部变量在函数中定义局部变量的方法 local NAME=VALUE 函数递归示例函数递归：函数直接或间接调用自身注意递归层数递归实例：阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语，一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的阶乘为1，自然数n的阶乘写作n!n!=1×2×3×…×n阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×nn!=n(n-1)(n-2)…1n(n-1)! = n(n-1)(n-2)! #!/bin/bash fact(){ if [ &quot;$1&quot; -eq 1 ];then echo 1 else echo $[ $1*`fact $[$1-1]`] fi } fact $1 执行结果 执行 fact.sh 3 这里的3就是末行的$1 fact 3 对于fact来讲他是一个函数，3就是他的参数 然后执行整个文件里面的函数 3 不等于 1 执行else echo $[3*`fact $[3-1]`]就是echo $[3*`fact 2`],但是这里不知fact 2是什么于是再次执行 fact 2 $1=2 2 -eq 1 else echo $[2*`fact 1`],这里也不知道fact 1是什么 fact 1 $1=1 1 -eq 1 echo 1 这个函数的结果就是fact 1就是1 替换上面的 echo $[2*1] fact 2 就是2 ;3*fact 2(fact 2就是2)=6 fork 炸弹fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源函数实现::(){ :|:&amp; };: 这里的:就是一个函数名，故作玄虚。让你看不懂才写一个:所以把它换一个单词就行。bomd(){ bomd | bomd &amp; };bomd函数(){这里的bomd是一个执行函数在里面调用自己 管道的作用就是开启子进程 后台执行并行 }调用此函数脚本实现 cat Bomb.sh 脚本自身 #!/bin/bash cat Bomb.sh ./$0|./$0&amp; $0:脚本自身，用管道传给自己后台执行，并行执行要给文件加上执行权限 斐波那契数列 斐波那契数列又称黄金分割数列，因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……，斐波纳契数列以如下被以递归的方法定义：F（0）=0，F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2）利用函数，求n阶斐波那契数列 #!/bin/bash fei(){ if [ &quot;$1&quot; -eq 0 ];then echo 0 elif [ &quot;$1&quot; -eq 1 ];then echo 1 else echo $[`fei $[$1-1]`+`fei $[$1-2]`] fi } fei 3 大概计算方式 fei 3 fei 2 + fei 1 fei 1 + fei 0 echo 1 echo 0 trap 信号捕捉格式：trap “commands” signals当shell接收到signals指定的信号时（显示当前可用信号kill -l），执行commands命令trap ‘触发指令’ 信号 进程收到系统发出的指定信号后，将执行自定义指令，而不会执行原操作trap ‘’ 信号 忽略信号的操作trap ‘-‘ 信号 恢复原信号的操作trap -p 列出自定义信号操作trap finish EXIT 当脚本退出时，执行finish函数 #!/bin/bash trap &#39;echo 当接受到后面指定的信号时，就执行这里的命令&#39; 2 15 #2(SIGINT 中止正在运行的进程；相当于CTRL+C trap -p for (( i=1;i&lt;=10;i++ ));do echo $i sleep 1 done trap &#39;&#39; 2 15 trap -p for (( i=11;i&lt;=20;i++ ));do echo $i sleep 1 done trap &#39;-&#39; 2 15 trap -p for (( i=21;i&lt;=30;i++ ));do echo $i sleep 1 done #!/bin/bash finish(){ echo &quot;finish&quot; } trap finish exit for ((i=1;i&lt;=50;i++));do let sum+=i sleep 1 done echo $sum 数组变量：存储单个元素的内存空间数组：存储多个元素的连续的内存空间，相当于多个变量的集合数组名和索引索引：编号从0开始，属于数值索引注意：索引可支持使用自定义的格式，而不仅是数值格式，即为关联索引，bash4.0版本之后开始支持bash的数组支持稀疏格式（索引不连续）声明数组：declare -a ARRAY_NAMEdeclare -A ARRAY_NAME: 关联数组注意：两者不可相互转换 数组赋值数组元素的赋值(1) 一次只赋值一个元素数组名[下标 从0开始]=”值”weekdays[0]=&quot;Sunday&quot;weekdays[4]=&quot;Thursday&quot; [root@centos7 data]# title[0]=ceo 赋值 [root@centos7 data]# title[1]=coo [root@centos7 data]# title[2]=cto [root@centos7 data]# title[3]=devops [root@centos7 data]# echo ${title[1]} 查看 coo [root@centos7 data]# echo ${title[0]} ceo (2) 一次赋值全部元素ARRAY_NAME=(“VAL1” “VAL2” “VAL3” …) title=(ceo coo cto) echo ${title[*]} filename=(f{1,2,3}.{txt,log}) echo ${filename[0]} nmae=(`seq 10`) echo ${name[3]} alphe=({a..e}) (3) 只赋值特定元素ARRAY_NAME=([0]=”VAL1” [3]=”VAL2” …)(4) 交互式数组值对赋值 read -a ARRAY [root@centos7 data]# read -a title ceo coo cto 显示所有数组：declare -a 引用数组1引用数组元素 ${ARRAY_NAME[INDEX]} 注意：省略[INDEX]表示引用下标为0的元素引用数组所有元素 echo ${title[*]} echo ${title[@]} 数组的长度(数组中元素的个数)echo ${#title[*]} echo ${#title[@]} for i in `seq 0 $[${#title[@]}-1]`;do echo Title is ${title[$i]};done 列出数组，标准的数组下标=数组元素个数-1 for i in `seq 0 ${#title[@]}`;do echo Title is ${title[$[$i-1]};done 假设不知道下标到多少个了，要在最后添加一个下标可以 查看数组的个数 echo ${#title[*]} title[${#title[*]}]=&quot;new title&quot; echo ${title[*] 删除数组中的某元素：导致稀疏格式:意思是中间的元素被删除了会导致稀疏格式unset ARRAY[INDEX],unset title[1]删除整个数组unset ARRAYunset title 数组数据处理 引用数组中的元素：数组切片:${title[@]:offset:number}echo ${title[*]:1:2} echo ${title[@]:1:2}offset:要跳过的元素个数number:要取出的元素个数取偏移量之后的所有元素 echo ${title[@]:offset} 向数组中追加元素： title[${#title[*]}]=avc 上面有提到不知道下角标 ${#title[*]} 数组长度 关联数组：declare -A ARRAY_NAMEARRAY_NAME=([idx_name1]=’val1’ [idx_name2]=’val2’…)注意：关联数组必须先声明再调用 arr[&quot;a&quot;]=&quot;aaa&quot; arr[&quot;b&quot;]=&quot;bbb&quot; arr[&quot;c&quot;]=&quot;ccc&quot; 这里的数组赋值后查看 echo ${arr[b]} ccc echo ${arr[c]} ccc 显示都一样有问题，要声明 （提前声明） declare -A arr &lt;晚了,声明报错，必须提前声明&gt; -bash: declare: arr: cannot convert indexed to associative array unset arr 先删除他 declare -A arr 先声明 后赋值 arr[&quot;a&quot;]=aaa arr[&quot;b&quot;]=bbb arr[&quot;c&quot;]=ccc echo ${arr[&quot;a&quot;]} aaa echo ${arr[&quot;b&quot;]} bbb 生成10个随机数保存于数组中，并找出其最大值和最小值#!/bin/bash declare -a num for ((i=0;i&lt;10;i++));do num[$i]=$RANDOM if [ $i -eq 0 ];then MAX=${num[$i]} MIN=${num[$i]} else if [ &quot;$MAX&quot; -lt ${num[$i]} ];then MAX=${num[$i]} elif [ &quot;$MIN&quot; -gt ${num[$i]} ];then MIN=${num[$i]} else true fi fi done echo all random are ${num[*]} echo Max random is $MAX echo Max random is $MIN #!/bin/bash declare -i min max declare -a nums for ((i=0;i&lt;10;i++));do nums[$i]=$RANDOM [ $i -eq 0 ] &amp;&amp; min=${nums[$i]} &amp;&amp; max=${nums[$i]}&amp;&amp; continue [ ${nums[$i]} -gt $max ] &amp;&amp; max=${nums[$i]} [ ${nums[$i]} -lt $min ] &amp;&amp; min=${nums[$i]} done echo &quot;All numbers are ${nums[*]}&quot; echo Max is $max echo Min is $min 字符串切片 ${#字符串}:返回字符串变量var的长度 str=`echo {%a..z%} | tr -d` echo $str abcdefghijklmnopqrstuvwxyz echo ${%#str%} 26 ${var:offset}:返回字符串变量var中从第offset个字符后（不包括第offset个字符）的字符开始，到最后的部分，offset的取值在0 到 ${#var}-1 之间(bash4.2后，允许为负值) echo ${str:5} fghijklmnopqrstuvwxyz ${var:offset:number}：返回字符串变量var中从第offset个字符后（不包括第offset个字符）的字符开始，长度为number的部分 [root@centos7 ~]# echo ${str:5:2} fg ${var: -length}：取字符串的最右侧几个字符 注意：冒号后必须有一空白字符 [root@centos7 ~]# echo ${str: -3} xyz ${var:offset:-length}：从最左侧跳过offset字符，一直向右取到距离最右侧lengh个字符之前的内容 [root@centos7 ~]# echo ${str:4:-3} 抛头去尾 efghijklmnopqrstuvw ${var: -length:-offset}：先从最右侧向左取到length个字符开始，再向右取到距离最右侧offset个字符之间的内容，注意：-length前空格 centos6不支持 [root@centos7 ~]# echo ${str: -4: -3} 取最后的四个，再从右往左除去三个数 w [root@centos7 ~]# echo ${str: -5: -3} vw 字符串处理 自左而右基于模式取子串 ${var#*word}：其中word可以是指定的任意字符 功能：自左而右，查找var变量所存储的字符串中，第一次出现的word, 删除字符串开头至第一次出现word字符串（含）之间的所有字符 [root@centos7 ~]# rootinfo=`getent passwd root` [root@centos7 ~]# echo $rootinfo root:x:0:0:root:/root:/bin/bash [root@centos7 ~]# echo ${rootinfo#*root} :x:0:0:root:/root:/bin/bash [root@centos7 ~]# echo ${rootinfo##*root} 贪婪模式 :/bin/bash ${var##*word}：同上，贪婪模式，不同的是，删除的是字符串开头至最后一次由word指定的字符之间的所有内容 示例： file=&quot;var/log/messages&quot; ${file#*/}: log/messages ${file##*/}: messages 字符串处理自右而左 ${var%word*}：其中word可以是指定的任意字符 功能：自右而左，查找var变量所存储的字符串中，第一次出现的word, 删除字符串最后一个字符向左至第一次出现word字符串（含）之间的所有字符 [root@centos7 ~]# echo ${rootinfo%root*} root:x:0:0:root:/ [root@centos7 ~]# echo ${rootinfo%%:*} 贪婪模式 root file=&quot;/var/log/messages&quot; word例子 ${file%/*}: /var/log ${var%%word*}：同上，只不过删除字符串最右侧的字符向左至最后一次出现word字符之间的所有字符 示例： url=http://www.magedu.com:80 ${url##*:} 80 ${url%%:*} http 字符串处理1查找替换${var/pattern/substr}：查找var所表示的字符串中，第一次被pattern所匹配到的字符串，以substr替换之 [root@centos7 ~]# echo $url http://www.magedu.com:80 [root@centos7 ~]# echo ${url/www/ftp} http://ftp.magedu.com:80 查找var所表示的字符串中，所有能被pattern所匹配到的字符串，以substr替换之 [root@centos7 ~]# echo $url http://www.magedu.com:80 [root@centos7]# echo｛ｕｒｌ／／：／／＃｝合理忽略掉空格，这里是用全半角打开写的。若不这样会造成大片内容无法识别 http#//www.magedu.com#80 字符串处理查找并删除${var/pattern}：删除var表示的字符串中第一次被pattern匹配到的字符串 [root@centos7 ~]# echo $url http://www.magedu.com:80 [root@centos7 ~]# echo ${url/:} http//www.magedu.com:80 ${var//pattern}：删除var表示的字符串中所有被pattern匹配到的字符串 [root@centos7 ~]# echo ${url//:} http//www.magedu.com80 ${var/#pattern}：删除var表示的字符串中所有以pattern为行首匹配到的字符串 [root@centos7 ~]# echo $ab a.a.b.b.a.a++ [root@centos7 ~]# echo ${ab/#a} .a.b.b.a.a++ ${var/%pattern}：删除var所表示的字符串中所有以pattern为行尾所匹配到的字符串 [root@centos7 ~]# echo $ab a.a.b.b.a.a++ [root@centos7 ~]# echo ${ab/+} a.a.b.b.a.a+ [root@centos7 ~]# echo ${ab/++} a.a.b.b.a.a 字符大小写转换${var^^}：把var中的所有小写字母转换为大写${var,,}：把var中的所有大写字母转换为小写 [root@centos7 ~]# echo $ab a.a.b.b.a.a++ [root@centos7 ~]# echo ${ab^^} A.A.B.B.A.A++ 高级变量用法-有类型变量Shell变量一般是无类型的，但是bash Shell提供了declare和typeset两个命令用于指定变量的类型，两个命令是等价的declare [选项] 变量名-r 声明或显示只读变量-i 将变量定义为整型数-a 将变量定义为数组-A 将变量定义为关联数组-f 显示已定义的所有函数名及其内容-F 仅显示已定义的所有函数名-x 声明或显示环境变量和函数-l 声明变量为小写字母 declare –l var=UPPER -u 声明变量为大写字母 declare –u var=lower eval命令eval命令将会首先扫描命令行进行所有的置换，然后再执行该命令。该命令适用于那些一次扫描无法实现其功能的变量.该命令对变量进行两次扫描示例：[root@server ~]# CMD=whoami[root@server ~]# echo $CMDwhoami[root@server ~]# eval $CMDroot[root@server ~]# n=10[root@server ~]# echo {0..$n}{0..10}[root@server ~]# eval echo {0..$n}0 1 2 3 4 5 6 7 8 9 10 间接变量引用如果第一个变量的值是第二个变量的名字，从第一个变量引用第二个变量的值就称为间接变量引用variable1的值是variable2，而variable2又是变量名，variable2的值为value，间接变量引用是指通过variable1获得变量值value的行为 variable1=variable2variable2=value 间接变量引用bash Shell提供了两种格式实现间接变量引用 eval tempvar=\$$variable1 ;tempvar=${!variable1}示例： [root@server ~]# N=NAME [root@server ~]# NAME=wangxiaochun [root@server ~]# N1=${!N} [root@server ~]# echo $N1 wangxiaochun [root@server ~]# eval N2=\$$N [root@server ~]# echo $N2 wangxiaochun wangxiaochun 创建临时文件mktemp命令：创建并显示临时文件，可避免冲突mktemp [OPTION]… [TEMPLATE]mktemp fileXXX 会生成一个随机文件OPTION：-d: 创建临时目录-p DIR或–tmpdir=DIR: 指明临时文件所存放目录位置mktemp -d -p /data/ dirXXX示例： mktemp /tmp/testXXX tmpdir=`mktemp –d /tmp/testdirXXX` mktemp --tmpdir=/testdir testXXXXXX 安装复制文件install命令：install [OPTION]… [-T] SOURCE DEST 单文件install [OPTION]… SOURCE… DIRECTORYinstall [OPTION]… -t DIRECTORY SOURCE…install [OPTION]… -d DIRECTORY…创建空目录选项：-m MODE，默认755-o OWNER 所有者-g GROUP 所属组示例： install -m 700 -o wang -g admins srcfile desfile install –m 770 –d /testdir/installdir install -m 700 -o pan -g p1 /etc/issue /data/issue_bak 复制/etc/issue到/data/issue_bak/ 改文件权限为700，所有者为pan 用户，所属组p1。 expect介绍expect 是由Don Libes基于Tcl（ Tool Command Language ）语言开发的，主要应用于自动化交互式操作的场景，借助Expect处理交互的命令，可以将交互过程如：ssh登录，ftp登录等写在一个脚本上，使之自动化完成。尤其适用于需要对多台服务器执行相同操作的环境中，可以大大提高系统管理人员的工作效率 expect命令expect 语法：expect [选项] [ -c cmds ] [ [ -[f|b] ] cmdfile ] [ args ]选项-c：从命令行执行expect脚本，默认expect是交互地执行的示例：expect -c ‘expect “\n” {send “pressed enter\n”}-d：可以输出输出调试信息示例：expect -d ssh.expexpect中相关命令spawn：启动新的进程send：用于向进程发送字符串expect：从进程接收字符串interact：允许用户交互exp_continue 匹配多个字符串在执行动作后加此命令 expectexpect最常用的语法(tcl语言:模式-动作)单一分支模式语法：expect “hi” {send “You said hi\n”}匹配到hi后，会输出“you said hi”，并换行 [root@centos7 ~]# expect expect1.1&gt; expect &quot;hi&quot; { send &quot;You said hi\n&quot; } hi You said hi expect1.2&gt; 多分支模式语法： expect expect &quot;hi&quot; { send &quot;You said hi\n&quot; } \ &quot;hehe&quot; { send &quot;Hehe yourself\n&quot; } \ &quot;bye&quot; { send &quot;Good bye\n&quot; } 匹配 hi,hello,bye任意字符串时，执行相应输出。等同如下： expect { &quot;hi&quot; { send &quot;You said hi\n&quot;} &quot;he&quot; { send &quot;Hehe yourself\n&quot;} &quot;bye&quot; { send &quot;Good bye\n&quot;} } 示例用scp程序从本系统下的/etc/fstab文件传到192.168.152.131这台主机上的/data目录下 [root@centos7 data]# cat expect.sh #!/usr/bin/expect spawn scp /etc/fstab pan@192.168.152.131:/data expect { ##这里是监听如果发现括号中的关键字就执行对应的操作 &quot;yes/no&quot; { send &quot;yes\no&quot;;exp_continue } ##如果是第一次连就要输入yes\no &quot;password&quot; { send &quot;123456\n&quot; } } #第二次输密码 expect eof ##结束expet的命令 SCP 传送文件，第一次会提示yes,第二次会提示密码，但我测试一直都是密码？ 用ssh登录到另外一台主机上并可以允许用户交互执行 #!/usr/bin/expect spawn ssh pan@192.168.152.131 expect { &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue } &quot;password&quot; { send &quot;123456\n&quot; } } interact expect eof 用变量实现#!/usr/bin/expect set ip 192.168.152.131 set user pan set password 123456 spawn ssh $user@$ip expect { &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue } &quot;password&quot; { send &quot;$password\n&quot; } } interact 位置参数#!/usr/bin/expect set ip [lindex $argv 0] set user [lindex $argv 1] set password [lindex $argv 2] spawn ssh $user@$ip expect { &quot;yes/no&quot; { send &quot;yes\n&quot;;} &quot;password&quot; { send &quot;$password\n&quot; } } interact #./ssh3.exp 192.168.152.131 pan 123456 执行多个命令#!/usr/bin/expect set ip [lindex $argv 0] set user [lindex $argv 1] set password [lindex $argv 2] spawn ssh $user@$ip expect { &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue } &quot;password&quot; { send &quot;$password\n&quot; } } expect &quot;]#&quot; { send &quot;useradd expect\n&quot; } expect &quot;]#&quot; { send &quot;echo 123456 |passwd --stdin expect\n&quot; } send &quot;exit\n&quot; expect eof #./ssh4.exp 192.168.152.131 root 123456 shell脚本调用expect#!/bin/bash #想要shell中调用expect ip=$1 user=$2 password=$3 expect &lt;&lt;EOF #expect本身是一个交互式命令，所以想要把命令传入给expect执行，就必须用标准输入输出重定向传入进去。 set timeout 10 spawn ssh $user@$ip expect { &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue } &quot;password&quot; { send &quot;$password\n&quot; } } expect &quot;]#&quot; { send &quot;useradd hehe\n&quot; } expect &quot;]#&quot; { send &quot;echo 123456 |passwd --stdin hehe\n&quot; } expect &quot;]#&quot; { send &quot;exit\n&quot; } expect eof EOF #./ssh5.sh 192.168.8.100 root 123456 expect循环修改可以批量读入ip地址从而到达他们的主机进行修改 #!/bin/bash while read ip;do user=root password=123456 expect &lt;&lt;EOF spawn ssh $user@$ip expect { &quot;yes/no&quot; { send &quot;yes\n&quot;; } &quot;password&quot; { send &quot;$password\n&quot; } } expect &quot;]#&quot; { send &quot;sed -i &#39;s/^SELINUX=.*/SELINUX=permissive/&#39; /etc/selinux/config \n&quot; } expect &quot;]#&quot; { send &quot;exit\n&quot; } expect eof EOF done &lt; iplist.txt [root@centos7 data]# cat iplist.txt 192.168.152.131 Linux组成Linux: kernel+rootfskernel: 进程管理、内存管理、网络管理、驱动程序、文件系统、安全功能rootfs:程序和glibc库：函数集合, function, 调用接口（头文件负责描述）过程调用：procedure，无返回值函数调用：function程序：二进制执行文件内核设计流派：单内核(monolithic kernel)：Linux把所有功能集成于同一个程序微内核(micro kernel)：Windows, Solaris每种功能使用一个单独子系统实现 Linux内核特点：支持模块化：.ko（内核对象）如：文件系统，硬件驱动，网络协议等支持内核模块的动态装载和卸载组成部分：核心文件：/boot/vmlinuz-VERSION-release ramdisk：辅助的伪根系统CentOS 5: /boot/initrd-VERSION-release.imgCentOS 6,7: /boot/initramfs-VERSION-release.img 模块文件：/lib/modules/VERSION-release Centos6启动流程CentOS6启动流程1.加载BIOS的硬件信息，获取第一个启动设备2.读取第一个启动设备MBR的引导加载程序(grub)的启动信息3.加载核心操作系统的核心信息，核心开始解压缩，并尝试驱动所有的硬件设备4.核心执行init程序，并获取默认的运行信息5.init程序执行/etc/rc.d/rc.sysinit文件6.启动核心的外挂模块7.init执行运行的各个批处理文件(scripts)8.init执行/etc/rc.d/rc.local9.执行/bin/login程序，等待用户登录10.登录之后开始以Shell控制主机 启动流程POST：Power-On-Self-Test，加电自检，是BIOS功能的一个主要部分。负责完成对CPU、主板、内存、硬盘子系统、显示子系统、串并行接口、键盘等硬件情况的检测ROM：BIOS，Basic Input and Output System，保存着有关计算机系统最重要的基本输入输出程序，系统信息设置、开机加电自检程序和系统启动自举程序等RAM：CMOS互补金属氧化物半导体，保存各项参数的设定按次序查找引导设备，第一个有引导程序的设备为本次启动设备bootloader: 引导加载器，引导程序 windows: ntloader，仅是启动OSLinux：功能丰富，提供菜单，允许用户选择要启动系统或不同的内核版本；把用户选定的内核装载到内存中的特定空间中，解压、展开，并把系统控制权移交给内核LILO：LInux LOaderGRUB: GRand Unified BootloaderGRUB 0.X: GRUB Legacy， GRUB2 启动流程 MBR：第一个扇区前446字节 bootloader中间64字节 分区表最后2字节 55AA GRUB:primary boot loader : 1st stage，1.5 stagesecondary boot loader ：2nd stage，分区文件 kernel：自身初始化：探测可识别到的所有硬件设备加载硬件驱动程序（借助于ramdisk加载驱动）以只读方式挂载根文件系统运行用户空间的第一个应用程序：/sbin/init 启动流程ramdisk：内核中的特性之一：使用缓冲和缓存来加速对磁盘上的文件访问，并加载相应的硬件驱动ramdisk –&gt; ramfs 提高速度 CentOS 5: initrd工具程序：mkinitrd CentOS 6，7: initramfs工具程序：mkinitrd, dracut系统初始化：POST –&gt; BootSequence (BIOS) –&gt; Bootloader(MBR) –&gt; kernel(ramdisk) –&gt; rootfs(只读) –&gt; init（systemd） ramdisk管理initramfs-2.6.32-754.el6.x86_64.img 删除后的修复方法ramdisk文件的制作：(1) mkinitrd命令为当前正在使用的内核重新制作ramdisk文件mkinitrd /boot/initramfs-$(uname -r).img $(uname -r)(2) dracut命令为当前正在使用的内核重新制作ramdisk文件dracut /boot/initramfs-$(uname -r).img $(uname -r) 系统启动流程 init程序的类型：SysV: init, CentOS 5之前配置文件：/etc/inittab：开机默认启动模式(0-6)。Upstart: init,CentOS 6配置文件：/etc/inittab,/etc/init/*.confSystemd：systemd, CentOS 7配置文件：/usr/lib/systemd/system/etc/systemd/system 启动流程/sbin/init CentOS6之前运行级别：为系统运行或维护等目的而设定；0-6：7个级别0：关机1：单用户模式(root自动登录), single, 维护模式2: 多用户模式，启动网络功能，但不会启动NFS；维护模式3：多用户模式，正常模式；文本界面4：预留级别；可同3级别5：多用户模式，正常模式；图形界面6：重启默认级别：3, 5切换级别：init #查看级别：runlevel; who -r init初始化init读取其初始化文件：/etc/inittab初始运行级别(RUN LEVEL)系统初始化脚本对应运行级别的脚本目录捕获某个关键字顺序定义UPS电源终端/恢复脚本在虚拟控制台生成getty在运行级别5初始化X /etc/rc.d/rc.sysinit: 系统初始化脚本(1) 设置主机名(2) 设置欢迎信息(3) 激活udev和selinux(4) 挂载/etc/fstab文件中定义的文件系统(5) 检测根文件系统，并以读写方式重新挂载根文件系统(6) 设置系统时钟(7) 激活swap设备(8) 根据/etc/sysctl.conf文件设置内核参数(9) 激活lvm及software raid设备(10) 加载额外设备的驱动程序(11) 清理操作 CentOS 5的inittab文件每一行格式： id:runlevel:action:process id：是惟一标识该项的字符序列runlevels： 定义了操作所使用的运行级别action： 指定了要执行的特定操作wait: 切换至此级别运行一次respawn：此process终止，就重新启动之initdefault：设定默认运行级别；process省略sysinit：设定系统初始化方式process：定义了要执行的进程示例：id:3:initdefault:si::sysinit:/etc/rc.d/rc.sysinitl0:0:wait:/etc/rc.d/rc 0l1:1:wait:/etc/rc.d/rc 1…l6:6:wait:/etc/rc.d/rc 6ca::ctrlaltdel:/sbin/shutdown -t3 -r now hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技巧集合]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[linux 小技巧+总结 simple commanduname -a # 查看Linux内核版本信息 cat /proc/version # 查看内核版本 cat /etc/issue # 查看系统版本 lsb_release -a # 查看系统版本 需安装 centos-release locale -a # 列出所有语系 locale # 当前环境变量中所有编码 hwclock # 查看时间 who # 当前在线用户 w # 当前在线用户 whoami # 查看当前用户名 logname # 查看初始登陆用户名 uptime # 查看服务器启动时间 sar -n DEV 1 10 # 查看网卡网速流量 dmesg # 显示开机信息 lsmod # 查看内核模块 Descriptionsedsed 执行系统命令。查找当前目录以及子目录中以 “.sh”,并改为以”.shell”结尾。find ./a -type f -regex &quot;.*/.sh$&quot; | sed -r -n &#39;s#(.*\.)sh$#mv &amp; \1shell#e&#39; -regex: 使用正则表达式&quot;.*/.sh$&quot; 给出的正则表达式必须要匹配完整的文件路径,比如：find / -regex &quot;find&quot; 这样子是找不到/usr/bin/find的，要像这样find / -regex &quot;.*find&quot;或者更精确一点find / -regex &quot;.*/find&quot; &amp;: 匹配前面找到的内容 e: 末尾的e表示# #这里允许执行命令然后得到结果#,也就是mv 前面匹配到的.sh文件 任意内容.shell Bash中${}的用法和变量的间接引用${STR^^}, 把STR中的所有小写字母转换为大写输出(不改变值) [root@junun ~]# str=abcde [root@junun ~]# echo ${str^^} ABCDE ${STR,,}, 把STR中的所有大写字母转换为小写输出(不改变值) [root@junun ~]# str1=ABCDE [root@junun ~]# echo ${str1,,} abcde 交互登录式shell的配置文件加载次序 linux使用dhclient自动获取IP获取IP: dhclient eth1查看结果:-方法1: ifconfig eth1-方法2,显示更详细: cat /var/lib/dhclient/dhclient.leases释放IP: dhclient -rdhclient -r并没有真正释放IP，下一次执行dhclient eth1时，没有discover这个步骤，而是直接REQUEST上次IP。在网络拓扑或者配置变化的情况下，获取不到IP，需要删除/var/lib/dhclient/dhclient.leases 文件 PS1修改[root@Tiger data]# cat /etc/profile.d/panxiaohu.sh PS1=&#39;\[\033[1;40;33m\][\u@\h \W]\$ \[\033[0m\]&#39; #注意引号 &#39;PATH=/etc/profile.d/:$PATH&#39; dfdf -T 可以查看文件系统类型 文件重启cat /sbin/shutdown -t3 -r now 三秒以后重启 进程ps -eaf # 查看所有进程 kill -9 PID # 强制终止某个PID进程 kill -15 PID # 安全退出 需程序内部处理信号 cmd &amp; # 命令后台运行 nohup cmd &amp; # 后台运行不受shell退出影响 ctrl+z # 将前台放入后台(暂停) jobs # 查看后台运行程序 bg 2 # 启动后台暂停进程 fg 2 # 调回后台进程 pstree # 进程树 vmstat 1 9 # 每隔一秒报告系统性能信息9次 sar # 查看cpu等状态 lsof file # 显示打开指定文件的所有进程 lsof -i:32768 # 查看端口的进程 renice +1 180 # 把180号进程的优先级加1 用户和用户组https://mp.weixin.qq.com/s?__biz=MzA3OTgyMDcwNg==&amp;mid=2650637412&amp;idx=1&amp;sn=ffb9ec56b91bdcbd93c042da254375e7&amp;chksm=87a486a9b0d30fbfe01b5e9f714c49944cf5f292d14e3827f6958262eb2d66e6d2b65662d4fd&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1564102447782&amp;sharer_shareid=837dfcba2206d025ecf6e6476b699921#rd 开机启动脚本顺序/etc/profile /etc/profile.d/*.sh ~/bash_profile ~/.bashrc /etc/bashrc sed 替换内容将seq 10返回内容的1,5,8替换成xxxseq 10 | sed -e{1,5,8}&#39;s#.*#xxx#&#39;# 显示已知用户的信息lslogins# 特殊变量：shell对一些参数做特殊处理,这些参数只能被引用而不能被赋值$# 传递到脚本的参数个数$* 显示所有向脚本传递的参数 #与位置变量不同，此选项参数可超过9个$$ 获取当前shell的进程号$! 执行上一个指令的进程号$? 获取执行的上一个指令的返回值 #0为执行成功，非零为执行失败$- 显示shell使用的当前选项，与set命令功能相同$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数# 服务端口samba 默认用445端口httpd 默认80端口# 同步分区表partprobe: 通知系统分区表的变化,用fdisk更改分区后，分区会不同步，使用这条命令，是分区同步。 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Summary one]]></title>
    <url>%2F2018%2F12%2F19%2F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[目录结构+Vim+压缩打包 网络基础局域网特点:覆盖地理范围小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。使用专门铺设的传输介质进行联网，数据传输效率高(10MB/s-10Gb/s)通信延迟短，可靠性高。局域网可以支持多种传输介质。广域网的特点:适应大容量与突发性通信的要求；适应综合业务服务的要求；开放的设备接口与规范化的协议；完善的通信服务与网络管理。 linux 目录结构 /boot:引导文件存放目录，内核文件(vmlinuxz),引导加载器(bootloader,grub)都存放与此目录。/bin:存所用用户使用的基本命令；不能关联至独立分区，OS启动就会启动用到的程序。/sbin:系统管理命令，与用户相关，例如大部分服务器程序。必要的二进制文件/lib:启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)/lib64:专用于x86_64系统上的辅助共享库文件存放位置/etc:配置文件目录/home:普通用户的家目录/media:便携式移动设备挂载点/mnt:临时文件系统挂载点/dev:设备文件及特殊文件存储位置/proc:存放所有标志为文件的进程，他们是通过进程号或其他的系统动态信息进行标识。例如CPU,硬盘分区，内存信息等存放在这里/opt:作为可选文件哈程序的存放目录，有些软件包也会被安装在这里，也就是自定义软件包。 文件类型 文件属性 文件类型 - 普通文件 d 目录 b 块设备文件 l 符号链接文件，又称软链接文件 p pipe即命令管道文件 s socket即套接字文件,用于实现两个进程进行通信 颜色属性蓝色：目录绿色：可执行文件红色：压缩文件浅蓝色：链接文件白色：普通文件黄色：设备文件 vim 快捷键A:跳到行尾插入 I:跳到行首插入 O:添加上一行 GG:跳到文章最后一行的行首a:跳到光标后插入 i:跳到光标前插入 o:添加下一行 gg:跳到文件第一行的行首 Home:跳到行首(还是处于命令模式) P:向上粘贴U:撤销当前行中所有的改动 yy:拷贝光标所在的一行 dd:删除光标所在的一行END:跳到行尾(还是处于命令模式) p:向下粘贴 u:撤销上一步的操作/ 查找 ZZ:保存并退出 vim替换% 所有行 g 单行内所有匹配项 i 忽略大小写 c 确认是否替换(询问) :%s/a/b 每一行的a都替换成b :%s/a/b/g 将文章中所有的a都换成b :s/a/b/g 表示只替换光标所在的一行，全部替换。 :1,5s/a/b/g 将1-5行中的a替换成b，所有a全部替换。 vim设置set nu 显示行号 set nonu 取消行号 set ic 不区分大小写 set noic 取消不区分大小写 set ts=4 设置tab键长度 set sw=4 设置自动缩进的tab键长度 压缩 .zip使用zip压缩不会删除源文件(只有zip默认可以保存源文件)，可以压缩目录(只有zip可以压缩目录) 压缩: zip 压缩文件名 源文件 zip -r 压缩文件名 源目录 解压: unzip 压缩文件 [-d &lt;文件解压缩后所要存储的目录&gt;] .gz.gz默认不保留源文件。要保留源文件加参数-c 压缩: gzip 源文件 gzip -c 源文件 &gt; 压缩文件 -c:保留源文件 gzip -r 目录 压缩目录下所有的子文件，但是不能压缩目录。压缩文件自动存储在压缩的目录下 解压: gzip -d 压缩文件 gunzip 压缩文件 gunzip -r 目录(解压缩目录子文件) 不解压缩查看内容: zcat 压缩文件 .bz2默认源文件也不保存，保留加参数-k。bzip2不能压缩目录 压缩: bzip2 源文件 bzip2 -k 源文件 保留源文件 解压缩: bzip2 -d 压缩文件 不解压查看文件: bzcat 压缩文件 .xz需要保留源文件-k 压缩: xz 源文件 解压缩: xz -d 压缩文件 unxz 压缩文件 不解压查看文件: xzcat 压缩文件 打包:tar-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的------------------------------普通打包例:------------------------------ tar cf file.tar files 将一个或多个文件，目录打包到tar包。 tar rf file.tar file 将文件file添加到tar包中。 tar uf file.tar file 将文件file更新tar包中相应的文件。 tar tf file.tar 查看tar内容。 tar xf file.tar 解压tar包。 -z:有gzip属性,即需要用 gzip 压缩 -j:有bz2属性,即需要用 bzip2 压缩 -v:显示处理过程 -C:指定解压输出目录 tar zxvf test.tar.gz -C test-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 -O：将文件解开到标准输出------------------------------先打包后压缩例:------------------------------ .tar.gz格式是先打包为.tar格式，再压缩为.gz格式 tar -zxvf file.tar.gz 源文件 压缩为.tar.gz格式的包 tar -zxvf file.tar.gz [-C 解压位置] 例:tar -zxvf a.tar.gz -C /home/ tar -ztvf file.tar.gz 只查看不解压 .tar.bz2格式: tar -jcvf 压缩包名.tar.bz2 压缩 tar -jxvf 压缩报名.tar.bz2 解压缩 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[one]]></title>
    <url>%2F2018%2F08%2F28%2F%E9%A9%AC%E5%93%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux 培训的笔记 命令积累lscpu 查看cpu信息 lsblk （列出块设备）命令用于列出所有可用块设备的信息sosreport 收集日志 查看内存：cat /proc/meminfopartorobe 新分区不用重启的识别命令。刷新硬盘分区表 centos7partx -a centos6 -a对于增加硬盘的选项partx -d --nr 6 /dev/sda 对于删除分区后，刷新硬盘的选项centos7查看服务是否开机启动:systemctl is-enabled sshd查看指定服务的状态: systemctl status sshd 用户的UID大于500的都是非系统账号，500以下的都为系统保留的账号 进制转换0 0 1 1 10 2 11 3 100 4 101 5 110 6 111 7 1000 8(2^3) 10000 16(2^4) 100000 32(2^5) 1000000 64(2^6) 10000000 128(2^7) 2^0=1 2^1=2 2^2=4 2^3=8 16 32 64 128例：97(十进制)=64+32+1=1000000+100000+1=1100001。例：10101010(二进制)=128+32+8+2=170。1Gbps：每秒传输1g的位。1Gbit/second1Byte=8bit touch建立带-的文件:touch -- -atouch ./-b DAS NAS SAM 存储基础知识—存储网络 DAS NAS SAM 传输类型 SCSI、FC IP IP、FC、SAS 数据类型 数据块 文件 数据块 典型应用 任何 文件服务器 数据库应用 优点 磁盘与服务器分离，便于统一管理 不占用应用服务器资源 高扩展性，高可用性，数据集中，易管理 缺点 连接距离短，数据分散，共享困难，存储空间利用率不高，扩展性有限 不适合存储大量的块级应用，数据备份已恢复占用网络带宽 相比NAS成本较高，安装和升级比NAS复杂 分区分区分配一个目录名mount point,名为挂载分区：MBR,GPT主：一个硬盘最多有四个，只有一个是活动，1-4扩展：最多一个，划分更小的分区，扩展+主分区&lt;=4 1-4逻辑分区：5,6 运行模式：runlevel3 5.3表示前一次的运行级别，5表示现在的运行级别N:表示前一次没有运行级别 。init 3：切换到3级别，init要登录startx:切换到？级别，startx不需要登录5：字符界面 0：关机 6：重启 终端tty显示终端号chvt 2:表示ctrl+Alt+F2切换到的界面 centos7启动网络启动网络：nmcli connection modify ens33 connection.autoconnect yesid -u:当前用户的UID，root为0，非0为普通用户。 查看版本号cat /etc/centos-release lsb_release -a 命令提示符查看：echo $PS1更改：PS1=&quot;\[\e[1;33m\][\u@\h \w \!]\\$\[\e[0m\]&quot;命令提示符:prompt # :管理员 $ :普通用户显示提示符格式：echo $PS1修改提示符格式：PS1=&quot;\e[1;33m\[[\u@\h \W]\\$\\e[0m&quot;PS1=&#39;\e[1;33m[\u@\h \w]\$ &#39; \e \033 \u 当前用户 \h 主机名称 \H 主机名 \w 当前工作目录 \W 当前工作目录最后目录名 \t 24小时时间格式 \T 12小时时间格式 \！命令历史数 \# 开机后命令历史数cat ~/.bashrc 命令提示符当前用户修改路径echo -e &quot;\033[5;41;33m文字文字\033[0m&quot; 闪烁+颜色 虚拟机取消密码进入vim /etc/gdm/custom.conf AutomaticLoginEnable=true AutomaticLogin=root 查看命令类型type pwd:显示命令的类型外部命令或者内部命令 -a :显示所有的内部命令后外部命令的列表 执行命令输入命令后回车:提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来。在shell中可执行的命令有两类1.内部命令：由shell自带的，而且通过某种命令形式提供 help内部命令列表enable cmd 启动内部命令enable -n cmd 禁用内部命令enable -n 查看所有禁用的内部命令2.外部命令：在文件系统路径下有对应的可执行程序文件查看路径：which -a |–skip-alias; whereis3.区别指定的命令是内部或外部命令type COMMANDwhereis:查看外部命令路径和他的配置文件文档路径 命令执行路径alias –内部 –hash表(记录外部命令的路劲) –$PATH –命令找不到 Hash缓存表 系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将这条命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先会查看hash表，存在将执行之，如果不存在，将会去PATH路径下寻找，利用hash缓存表可大大提高命令的调用率。 hash常见用法 hash 显示hash缓存 hash -l 显示hash缓存，可作为输入使用 hash -p path name 将命令全路径path起别名为name hash -t name 打印缓存中name的路径 hash -d name 清除name缓存 hash -r 清除缓存 别名显示当前shell进程所有可用的命令别名alias定义别名NAME，其相当于执行命令VALUEalias NAME=&#39;VALUE&#39;在命令行中定义的别名，仅对当前shell进程有效如果想要永久有效，要定义在配置文件中 仅对当前用户： ~/.bashrc 对所有用户有效： /etc/bashrc 写入文件后，文件存储在磁盘上没有生效，必须让他在内存中才会生效，使用命令source.bashrc删除别名(指在内存中删除)：unalias 别名编辑配置给出的新配置不会立即生效bash进程重新读取配置文件. source /path/to/config_file ./path/to/config_file 撤销别名: unalias [name] -a取消所有别名如果别名同原命令同名，如果要执行原命令，可使用 \ALIASNAME &quot;ALIASNAME&quot; &#39;ALIASNAME&#39; command ALIASNAME /path/command 针对外部命令 . 日期和时间linux的两种时钟系统时钟：由Linu内核通过CPU的工作频率进行的硬件时钟：主板相关命令:date 显示和设置系统时间 date +%s date -d @1509536033hwclock,clock:显示硬件时钟-s,–hctosys 以硬件时钟为准，校正系统时钟-w,–systohc 以系统时钟为准，校正硬件时钟时区：/etc/localtime显示日历：cal 显示前一天的时间 date -d &#39;-1 day&#39; +%F-%H显示两天前的时间 date -d &#39;-2 days ago&#39;显示3月零1天以后的时间 date -d &#39;3 months 1 days&#39;显示12月25日在当年的哪一天 date -d &#39;25 Dec&#39; +%j.月日小时分年.秒 date 061816432019.00 whoami用户登录信息查看命令:whoami :显示当前登录有效用户who :系统当前所有的登录会话w :系统当前所有的登录会话及所做的操作. 远程协助：screen screen 命令：创建新screen会话 screen -S [SESSION]加入screen会话 screen -x [SESSION]退出并关闭screen会话 exit剥离当前screen会话 Ctrl+a,d显示所有已经打开的screen会话 screen -ls恢复screen会话 screen -r [SESSION]. echolinux中换行表示：移动到下一行回车：光标移动到行首说明：echo会将输入的字符送往输出。输出的字符串间以空白字符隔开，并在最后加上换行号。-E :(默认)不支持\解释功能 -n :不自动换行 -e :启用\字符的解释功能 显示变量：echo &quot;$VAR_NAME&quot; 变量会替换，弱引用 单双引号的区别echo &#39;$VAR_NAME&#39; 变量会替换，强引用反引号里面可执行命令（可用$(命令)代替）`` ls -l `echo $SHELL` 得到的是/bin/bash 文件的详细信息 启用命令选项：-e,若字符串中出现以下字符，则特别加以处理，而不会将他当成一般文字输出\a :发出警告声\b :退格键\c :最后不加上换行符号\n :换行且光标移动至行首\r :回车，即光标移动至行首，但不换行\t :插入Tab字符\ :插入\字符\0nnn :插入nnn(八进制)所代表的ASCII字符 echo -e &#39;\033[43;31;5mmagedu\033[0m&#39;\xHH插入HH(十六进制)所代表的ASCII数字(man 7 ascii) hexdump查看”二进制”文件的十六进制编码 [root@centos7localdomain ~]# hexdump -C a 00000000 31 0a |1. | 00000002 [root@centos7localdomain ~]# hexdump -C a 00000000 31 32 0a 33 0a 61 0a |12.3.a. | 00000007 查看文件a的十六进制和ASCII码。偏移量；十六进制；ASCII码； 原始数据 （最后有空格）文件原始数据每行一个数。 Centos7设置语言localectl list-locales查看语言列表localectl set-locale LANG=en_US.utf8 修改修改后要注销再登录cat /etc/locale.conf 符号命令行扩展，被括起来的集合命令行扩展: $()或``把一个命令的输出打印给另一个命令的参数 echo &quot;This system&#39;s name is $(hostname)&quot; This system&#39;s name is server1.example.com echo &quot;i am `whoami`&quot; i am root 括号扩展:{}打印重复字符串的简化形式echo file{1,3,5} 结果为: file1 file3 file5rm -fr file{1,3,5}echo {1..10}echo {a..z}. whatiscentos6生成whatis数据库:makewhatisCentos7: mandbwhatis:显示命令的简短叙述;使用数据库;刚安装后不可立即使用makewhatis | mandb 制作数据库使用示例: whatis cal 或 man -f cal history 重复前一个命令使用上方向键，并且执行 按!!并回车执行 输入!-1执行倒数第一个命令 按Ctrl+p 并回车执行!:0 执行前一条命令(去除参数)Ctrl+n 显示当前历史中的下一条命令，但不执行Ctrl+j 执行当前密令!n 执行history命令输出对应序号n的命令!-n 执行history历史中倒数的第n个命令!string 重复前一个以”string”开头的命令!?string 重复前一个包含string的命令!string:p 仅打印命令历史，而不执行!$:p 打印输出!$(上一条命令的最后一个参数)的内容!*:p 打印输出!*(上一条命令的所有参数)的内容^string 删除上一条命令中的第一个string^string1^string2 将上一条命令中的第一个string1替换为string2!:g/s/string/string2 将上一条命令中所有的string1都替换为string2 3. 使用up(向上)和down(向下)键上下浏览从前输入的命令ctrl+r 在历史命令中搜索ctrl+g 从历史搜索模式中退出要重新调用前一个命令中最后一个参数：!$ESC,.(点击ESC键后松开，然后点击.键)Alt+. (按住Alt键的同时点击.键) 4. command !^ 利用上一个命令的第一个参数做cmd的参数.command !$ 利用上一个命令的最后一个参数做cmd的参数command !* 利用上一个命令的全部参数做cmd的参数command !:n 利用上一个命令的第n个参数做cmd的参数command !n:m 调用第n条命令的第m个参数command !n:* 调用第n条命令的所有参数 -c :清空命令历史 -d offser :删除历史中指定的第offser个命令 n :显示最近的n条历史 -a :追加本次会话新执行的命令历史列表至历史文件 -r :读历史文件附加到历史列表 -w :保存历史列表到指定的历史文件 -n :读取历史文件中未读过的行到历史列表 -p :展开历史参数成多行，但不存在历史列表中 -s :展开参数成一行，附加在历史列表后 -p:可以执行命令但不存在历史记录中。-s:伪造历史，不执行命令。HISTTIMEFORMAT=&quot;%F %T &quot;历史加上时间. 5.命令历史相关环境变量 HISTSIZE :命令历史记录的条数HISTFILE :指定历史文件，默认为~/.bash_history HISTFILESIZE :命令历史文件记录历史的条数 HISTTIMEFORMAT= “%F %T” 显示时间 HISTIGNORE= “str1:str2*……” 忽略str1命令，str2开头的历史 控制命令历史的记录方式： 环境变量：HISTCONTROL ignoredups 默认，忽略重复的命令，连续且相同为”重复” ignorespace 忽略所有已空白开头的命令 ignoreboth 相当于ignoredups,ignorespace的组合 erasedups 删除重复命令export 变量名=”值”存放在 /etc/profile 或 ~/.bash_profile. man查看man手册页 man [章节] keyword列出所有帮助 man -a keyword搜索man手册 man -k keyword 列出所有匹配的页面相当于whatis 数据库 man -f keyword打印man帮助文件的路径 man -w [章节] keyword man 命令的操作方法：使用less 命令实现待续写 man搜索待续写 bash 的快捷键Ctrl + l 清屏，相当于clear命令Ctrl + o 执行当前命令，并重新显示本命令Ctrl + s 阻止屏幕输出，锁定Ctrl + q 允许屏幕输出Ctrl + c 终止命令Ctrl + z 挂起命令 基名，目录名basename :取文件基名dirname :取文件目录名 centos6自动挂载cd /misc/cd 目录磁盘会自动挂载 通配符* 匹配零个或多个字符? 匹配任何单个字符~ 当前用户家目录 ~mage 用户mage家目录~+ 当前工作目录~- 前一个工作目录[0-9] 匹配数字范围 [a-z]:字母 [A-Z]:字母 [wang]匹配列表中的任何的一个字符[^wang] 匹配列表中的所有字符以外的字符ls 1[a-z].txt:不会显示出小写字母到大写字母的文件，他会以小写大写的顺序排列出来预定义的字符类：man 7 glob [:digit:] :任意数字，相当于0-9[:lower:] :任意小写字母[:upper:] :任意大写字母[:alpha:] :任意大小写字母[:alnum:] :任意数字或字母[:blank:] :水平空白字符[:space:] :水平或垂直空白字符[:punct:] :标点符号[:print:] :可打印字符[:cntrl:] :控制(非打印)字符[:graph:] :图形字符[:xdigit:] :十六进制字符ls .[^.]*显示当前目录下的隐藏目录ls -d .*ls -l &quot;[^.]*&quot; -a 三种显示方式 atime mtime ctimetouch命令-a 仅改变 atime和ctime-m 仅改变 mtime和ctime-t [[CC]YY]MMDDhhmm[.ss] touch -t 201802062036.18 linuxidc.txt 指定atime和mtime的时间戳-c 如果文件不存在，则不予创建, 如果文件存在，touch将更新访问时间 cpcp -r递归cp /etc/passwd ./a --backup将文件cp到a文件夹并备份-d:保留链接属性-a:归档，相当于-d,-p,-r-v:显示复制过程-p:此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中-u:两个同样的文件覆盖时，只复制新的到旧的上去。-f:复制已经存在的目标文时件不提示-i:询问，如果目标文件已经存在，则会询问是否覆盖-l:把目标文件建立为源文件的硬链接文件，而不是复制源文件；-b:覆盖前，目标存在先备份cp /etc/passwd ./a1 --backup=numbered例：cp -av /etc/ app/back date +%F :/etc/目录下所有文件，备份到/app独立的子目录下，要求子目录格式为backYYY-mm-dd,备份过程可见。 mv-b: 如果有相同的文件，覆盖前先备份。 -t移动文件路径和目标路径颠倒 alias rm=&#39;mv -t /data&#39; renamerename 原字符串 目标字符串 文件(列表)原字符串：将文件名需要替换的字符串；目标字符串：将文件名中含有的原字符替换成目标字符串；文件：指定要改变文件名的文件列表。将main1.c重命名为main.c rename main1.c main.c main1.crename支持通配符? 可替代单个字符* 可替代多个字符[charset] 可替代charset集中的任意单个字符举例：文件夹中有这些文件foo1, …, foo9, foo10, …, foo278rename foo foo0 foo?该命令会把foo1到foo9的文件重命名为foo01到foo09，重命名的文件只是有4个字符长度名称的文件，文件名中的foo被替换为foo0。rename支持正则表达式现在以一个具体的例子讲解该命令中正则表达式的使用：今天下午我手中的数据（图片）命名是(1).jpg、(2).jpg……到(16720).jpg。现在我想要把文件名改为00001.png、00002.png、…….16720.png第一步：将后缀名.jpg改成.png rename &#39;s/\.jpg$/\.png/&#39; *.jpg第二步：讲左括号”(“去掉：rename &#39;s/^\(//&#39; *.png第三步，将右括号“）”去掉：rename &#39;s/\)//&#39; *.png第四步：将文件名字改成五位数，不足五位数的前面补0即可。创建脚本a.sh完成，脚本内容如下： #！/bin/bash 上面三部后的结果：1.png for i in {1..9} do mv $i.png 0000$i.png done for i in {10..99} do mv $i.png 000$i.png done for i in {100..999} do mv $i.png 00$i.png done for i in {1000..9999} do mv $i.png 0$i.png done rename支持正则表达式:rename &quot;s/AA/aa/&quot; //把文件名中的AA替换成aa修改文件的后缀 rename &quot;s//.html//.php/&quot; //把.html 后缀的改成 .php后缀批量添加文件后缀 rename &quot;s/$//.txt/&quot; //把所有的文件名都以txt结尾批量删除文件名 rename &quot;s//.txt//&quot; //把所有以.txt结尾的文件名的.txt删掉如我们想把文件扩展名为.bak 的文件扩展名去掉，可以这样 rename &#39;s/.bak$//&#39; \*.bak*.bak 为通配符(wildcard)，会被shell展开为各个文件名 去除文件名中的空格 rename &#39;s/ //g&#39; g 是global的意思，替换所有的空格为空字符（也就是删除啦） 文件名转为小写: rename &#39;y/A-Z/a-z/&#39; tree显示目录树 -d :只显示目录 -L level :指定显示的层级数目 -P pattern :只显示由指定pattern匹配到的路径tree -P /etc/rc* mkdir创建目录 -p :存在于不报错，且可自动创建所需的各目录 -v :显示详细信息 -m MODE :创建目录时直接指定权限 rmdir删除空目录 -p :递归删除父目录(rmdir -p:从下往上删除，从深往浅删除) -v :显示详细信息rm -r :递归删除目录树 例：1.创建/testdir/dir1/x,/testdir/dir1/y,/testdir/dir1/x/a,/testdir/dir1/x/b,/testdir/dir1/y/a,/testdir/dir1/y/bmkdir -p ./testdir/dir1/{x,y}/{a,b}2.创建/testdir/dir2/x,/testdir/dir2/y,/testdir/dir2/x/a,testdir/dir2/x/bmkdir -p testdir/dir2{x/{a,b},y}3.创建/testdir/dir3,/testdir/dir4,/testdir/dir5,/testdir/dir5/dir6,testdir/dir5/dir7mkdir -p ./testdir/dir{3,4,5/dir{6,7}} inode索引节点:inode(index node)表中包含文件系统所有文件列表一个节点(索引节点)是在一个表项，包含有关文件的信息(元数据),包括： 文件类型,权限,UID,GID 链接数(指向这个文件名路径名称个数) 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 硬链接创建硬链接会增加额外的记录项以引用文件对应于同一文件系统上一个物理文件每个目录引用相同的inode号创建时链接数递增删除文件时：rm命令递减计数的链接文件要存在，至少有一个链接数当链接数为零时，该文件被删除不能跨越驱动器或分区同一个文件的不同名字，改动其中一个文件，另外一个有相同的变化。语法:ln filename 目录不支持硬链接，他前面的数字表示链接的次数是指目录下的隐藏文件夹，.和.. 软链接一个符号链接指向另一个文件ls -l的 显示链接的名称和引用的文件一个符号链接的内容是它引用文件的名称可以对目录进行可以跨分区指向的是另一个文件的路径；其大小为指向的路径字符串的长度；不增加或减少目标文件inode的引用计数；语法：ln -s filename 软链接大小是指向的路径大小这里的相对路径: ln -s ../../../data/a.txt /d1/d2/d3/a-link 写法要注意，这里就是我现在在d3要去找到data，那么就是先回到根目录，然后去data目录下。简单说就是我现在在d3目录利用相对路径去找到data。 file文件可以包含多种类型的数据。检查文件的类型，然后确定适当的打开命令或应用程序使用file [options] &lt;\filename&gt;… -b 列出文件辨识结果时，不显示文件名称-f filelist 列出文件filelist中文件名的文件类型-F 使用指定分隔符号替换输出文件名后默认的”:”分隔符-L 查看对应软链接对应文件的文件类型 tr-c:取反-s:压缩重复字符 [root@centos7 data]# tr &#39;a-z&#39; &#39;A-Z&#39; dfsjfidshijfidsijifjdisjidishifj DFSJFIDSHIJFIDSIJIFJDISJIDISHIFJ jdihsifjdisjfiiehuHIHIJ JDIHSIFJDISJFIIEHUHIHIJ [root@centos7 data]# [root@centos7 data]# tr -t &quot;a-d&quot; &quot;1-3&quot; a-d对应1-3进行替换 fdjfreg fdjfreg aaaaaasdfdsadfgh 111111sdfds1dfgh abcfg 123fg [root@centos7 data]# [root@centos7 data]# tr -d &#39;0-9&#39; dsgds546y7ujyr564wef5 dsgdsyujyrwef [root@centos7 data]# [root@centos7 data]# tr -dc &#39;0-9&#39; dsgrere54545tg653r45 5454565345[root@centos7 data]# [root@centos7 data]# tr -s &#39;dfg&#39; ddfsggvffcddd dfsgvfcd 用户管理员：root, 0普通用户：1-60000 自动分配系统用户：1-499, 1-999 （CentOS7）对守护进程获取资源进行权限分配登录用户：500+, 1000+（CentOS7） Linux安全上下文运行中的程序：进程 (process) 以进程发起者的身份运行：root: /bin/catmage: /bin/cat进程所能够访问资源的权限取决于进程的运行者的身份 组Linux组：Groupname/GID管理员组：root, 0普通组： 系统组：1-499, 1-999（CENTOS7） 普通组：500+, 1000+（CENTOS7） Linux组的类别:用户的主要组(primary group)用户必须属于一个且只有一个主组组名同用户名，且仅包含一个用户，私有组用户的附加组(supplementary group)一个用户可以属于零个或多个辅助组. 用户和组的配置文件 Linux用户和组的主要配置文件：/etc/passwd：用户及其属性信息(名称、UID、主组ID等）/etc/group：组及其属性信息/etc/shadow：用户密码及其相关属性/etc/gshadow：组密码及其相关属性 . passwd 文件格式login name：登录用名（wang）passwd：密码 (x)UID：用户身份编号 (1000)GID：登录默认所在组编号 (1000)GECOS：用户全名或注释home directory：用户主目录 (/home/wang)shell：用户默认使用shell (/bin/bash) shadow文件格式登录用名用户密码:一般用sha512加密从1970年1月1日起到密码最近一次被更改的时间密码再过几天可以被变更（0表示随时可被变更）密码再过几天必须被变更（99999表示永不过期）密码过期前几天系统提醒用户（默认为一周）密码过期几天后帐号会被锁定从1970年1月1日算起，多少天后帐号失效 例groupmems -a p2 -g p1:将用户p2加入p1组 groupmems -d p2 -g p1:将用户p2从p1组删除 [root@centos7 ~]# getent group p1 p1:x:1001:p2 [root@centos7 ~]# getent group p2 p2:x:1002: [root@centos7 ~]# newgrp p1：将当前用户的主组临时修改为p1,要求当前用户必须在p1组。 vipw == vi /etc/passwdvigr == vi /etc/growuseradd-o:忽略id的唯一性检查-r:建立系统用户，他默认不会创建家目录-s:指定shell类型-c:描述groups x:查看用户x属于那些组-N：不要创建以用户名称为名的群组(默认加组users)新建用户默认属性文件： id-g或–group 显示用户所属群组的ID。-G或–groups 显示用户所属附加群组的ID。-n或–name 显示用户，所属群组或附加群组的名称。-r或–real 显示实际ID。-u或–user 显示用户ID。-help 显示帮助。-version 显示版本信息[root@localhost ~]# iduid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)用户root的UID号码 = 0，GID号码 = 0。用户root是下面组的成员：root组GID号是：0bin组GID号是：1daemon组GID号是：2sys组GID号是：3adm组GID号是：4disk组GID号是：6wheel组GID号是：10 su切换用户或以其他用户身份执行命令su [options…] [-] [user [args…]]切换用户的方式：su UserName：非登录式切换，即不会读取目标用户的配置文件，不改变当前工作目录su - UserName：登录式切换，会读取目标用户的配置文件，切换至家目录，完全切换root su至其他用户无须密码；非root用户切换时需要密码换个身份执行命令：su [-] UserName -c ‘COMMAND’选项：-l –loginsu -l UserName 相当于 su - UserNamesu - pan -c &#39;ls&#39; 到用户pan执行命令ls再退回 passwd-d：删除指定用户密码 -l：锁定指定用户 -u：解锁指定用户 -e：强制用户下次登录修改密码 -f：强制操作 -n mindays：指定最短使用期限 -x maxdays：最大使用期限 -w warndays：提前多少天开始警告 -i inactivedays：非活动期限–stdin：从标准输入接收用户密码echo “PASSWORD” | passwd –stdin USERNAME chage修改用户密码状态chagechage [选项] 用户名 -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期(shadow3字段) -m 天数:两次密码修改间隔(4字段) -M 天数:密码有效期(5字段) -W 天数:密码过期前警告天数(7字段) -I 天数:密码过后宽限天数(7字段) -E 日期:账号失效时间(8字段)chage -d 0 username这个命令其实是把密码修改日期归0了(shadow第3字段)，这样用户只要一登录就要修改密码。第三字段是指密码最后一次修改时间的日期。1970年1月1号到现在修改密码的时间戳。如果第3字段改为0，系统会认为用户没有修改过操作密码，那么当此用户一旦登录系统就会提示要修改密码，才可正常使用。. groupmod修改和删除组组属性修改：groupmod groupmod [OPTION]… group-n group_name: 新名字-g GID: 新的GID组删除：groupdelgroupdel GROUPgroupmod -n p1(新名字) pangroupmod -g 1004 p1 gpasswd更改组密码组密码：gpasswdgpasswd [OPTION] GROUP-a user 将user添加至指定组中-d user 从指定组中移除用户user-A user1,user2,… 设置有管理权限的用户列表newgrp命令：临时切换主组如果用户本不属于此组，则需要组密码 groupmemsgroupmems [options] [action] options：-g, –group groupname 更改为指定组 (只有root) Actions:-a, –add username 指定用户加入组 -d, –delete username 从组中删除用户-p, –purge 从组中清除所有成员-l, –list 显示组成员列表groups [OPTION].[USERNAME]… 查看用户所属组列表 groupmems -g admins -a zhu------将zhu用户添加到admins组中 groupmems -g admins -l ------------查看admins组中的用户列表 groupmems -g admins -d ma-------将ma从admins组中删除 groupmems -g admins -p------------清空admins组中的所有组成员 umask新建文件和目录的默认权限umask值 可以用来保留在创建文件权限 新建FILE权限: 666-umask如果所得结果某位存在执行（奇数）权限，则将其权限+1 新建DIR权限: 777-umask 非特权用户umask是 002 root的umask 是 022 umask: 查看 umask #: 设定umask 002 umask –S 模式方式显示 umask –p 输出可被调用 全局设置： /etc/bashrc 用户设置：~/.bashrc SUID SGID STICKYsuid:4 作用在二进制可执行的文件上，功能：当用户执行此文件，会继承此文件所有者的权限。sgid:2 作用于二进制可执行的文件上，功能：会执行此文件所属组的权限 。 作用于目录上，功能：当用户在此目录建新文件时，此新文件的所属组继承目录的所属组。stikey:1 作用于目录上，功能：对于目录的文件只能删除自己的文件。 chattrchattr +i 不能删除，改名，更改chattr +a 只能追加内容lsattr 显示特定属性 ACL访问控制列表ACL：Access Control List，实现灵活的权限管理除了文件的所有者，所属组和其它人，可以对更多的用户设置权限CentOS7 默认创建的xfs和ext4文件系统具有ACL功能CentOS7 之前版本，默认手工创建的ext4文件系统无ACL功能,需手动增加 tune2fs –o acl /dev/sdb1mount –o acl /dev/sdb1 /mnt/testACL生效顺序：所有者，自定义用户，自定义组，其他人 setfacl -R -m d:u:p1:rw text 给文件夹text设置acl权限，默认以后文件下创建的文件都会有这个权限(text文件夹下所有的文件夹马上会带有acl权限。)setfacl -b test #清除所有aclsetfacl -x u:tank test #清除tank用户，对test文件acl规则setfcl -k test 清楚text目录下所有文件的默认acl权限(文件夹除外)赋权给用户： setfacl -m u:USERNAME:MODE file赋权给组： serfacl -m g:GROUPNAME:MODE file[root@centos7 text]# cat au:p1:rwu:p2:rwsetfacl -M a.txt aa 将已编辑好的acl文件a，赋给aa文件。设置文件的ACL权限后，会有一个mask权限，他表示所有权限的上限(所有者除外)，其他用户和组的权限都要以他为最大标准。ll查看文件的基础权限组权限就是mask权限，更改组的权限相当更改mask权限。所以文件的组的权限在getfacl里面 [root@centos7 text]# getfacl a # file: a # owner: root # group: root user::rwx user:p1:rwx #effective:rw- 最大权限rw group::r-- 基础组权限 group:p1:rwx #effective:rw- mask::rw- other::--- [root@centos7 text]# ll a -rwxrw----+ 1 root root 41 Apr 7 12:03 a setfacl -m mask::rw 更改mask权限 或者直接chmod更改 cat,head,tail,cut文件查看 文件查看命令：cat，tac，rev cat [OPTION]… [FILE]…-E：显示行结束符$-n：对显示出的每一行进行编号-A：显示所有控制符-b：非空行编号-s：压缩连续的空行成一行 tac rev 显示文本前或后行内容head [OPTION]… [FILE]…-c #: 指定获取前#字节-n #: 指定获取前#行-#： 指定行数 tail [OPTION]… [FILE]…-c #: 指定获取后#字节-n #: 指定获取后#行-#：同上-f: 跟踪显示文件fd新追加的内容,常用日志监控相当于 –follow=descriptor-F: 跟踪文件名，相当于–follow=name –retry tailf 类似tail –f，当文件不增长时并不访问文件 按列抽取文本cut和合并文件pastecut [OPTION]… [FILE]…-d DELIMITER: 指明分隔符，默认tab-f FILEDS:#: 第 # 个 字 段 #,#[,#]：离散的多个字段，例如1,3,6 #-#：连续的多个字段, 例如1-6混合使用：1-3,7-c 按字符切割–output-delimiter=STRING指定输出分隔符cut -d : -f 1,3 --output-delimiter=+ /etc/passwd输出分隔符为’+’ cut和paste显示文件或STDIN数据的指定列cut -d: -f1 /etc/passwdcat /etc/passwd | cut -d: -f7 cut -c2-5 /usr/share/dict/wordspaste 合并两个文件同行号的列到一行paste [OPTION]… [FILE]…-d 分隔符：指定分隔符，默认用TAB-s : 所有行合成一行显示示 例 ： paste f1 f2paste -s f1 f2 wc计数单词总数、行总数、字节总数和字符总数可以对文件或STDIN中的数据运行wc story.txt39 237 1901 story.txt 行数 字数 字节数常用选项-l 只计数行数-w 只计数单词总数-c 只计数字节总数-m 只计数字符总数-L 显示文件中最长行的长度 sort文本排序sort把整理过的文本显示在STDOUT，不改变原始文件sort [options] file(s)常用选项-r 执行反方向（由上至下）整理-R 随机排序-n 执行按数字大小整理-f 选项忽略（fold）字符串中的字符大小写-u 选项（独特，unique）删除输出中的重复行-t c 选项使用c做为字段界定符-k X 选项按照使用c字符分隔的X列来整理能够使用多次 uniquniq命令：从输入中删除前后相接的重复的行uniq [OPTION]… [FILE]…-c: 显示每行重复出现的次数-d: 仅显示重复过的行-u: 仅显示不曾重复的行注：连续且完全相同方为重复 常和sort 命令一起配合使用： sort userlist.txt | uniq -c patch复制对文件改变patchdiff 命令的输出被保存在一种叫做“补丁”的文件中使用 -u 选项来输出“统一的（unified）”diff格式文件，最适用于补丁文件patch 复制在其它文件中进行的改变（要谨慎使用）适用 -b 选项来自动备份改变了的文件diff -u foo.conf foo2.conf &gt; foo.patch patch -b foo.conf foo.patch grep–color=auto: 对匹配到的文本着色显示 -v: 显示不被pattern匹配到的行 -i: 忽略字符大小写 -n：显示匹配的行号 -c: 统计匹配的行数 -o: 仅显示匹配到的字符串 -q: 静默模式，不输出任何信息 -A #: after, 后#行 -B #: before, 前#行 -C #：context, 前后各#行 -e：实现多个选项间的逻辑or关系 grep –e &#39;cat&#39; -e dog&#39; file-w：匹配整个单词 -E：使用ERE -F：相当于fgrep，不支持正则表达式 -f file: 根据模式文件处理 字符匹配基本正则表达式元字符. 匹配任意单个字符[] 匹配指定范围内的任意单个字符，示例：[wang] [0-9] [a-z] [a-zA-Z][^] 匹配指定范围外的任意单个字符[:alnum:] 字母和数字[:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z[:lower:] 小写字母[:upper:] 大写字母[:blank:] 空白字符（空格和制表符）[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）[:cntrl:] 不可打印的控制字符（退格、删除、警铃…）[:digit:] 十进制数字[:xdigit:]十六进制数字[:graph:] 可打印的非空白字符[:print:] 可打印字符[:punct:] 标点符号 匹配次数用在要指定次数的字符后面，用于指定前面的字符要出现的次数* 匹配前面的字符任意次，包括0次贪婪模式：尽可能长的匹配.* 任意长度的任意字符\? 匹配其前面的字符0或1次\+ 匹配其前面的字符至少1次\{n\} 匹配前面的字符n次\{m,n\} 匹配前面的字符至少m次，至多n次\{,n\} 匹配前面的字符至多n次\{n,\} 匹配前面的字符至少n次 位置锚定定位出现的位置：^ 行首锚定，用于模式的最左侧$行尾锚定，用于模式的最右侧^PATTERN$ 用于模式匹配整行^$ 空行^[[:space:]]*$ 空白行\&lt; #锚定单词的开始，如:&#39;\&lt;grep&#39;匹配包含以grep开头的单词的行\&gt; #锚定单词的结束，如:&#39;grep\&gt;&#39;匹配包含以grep结尾的单词的行\b #单词锁定符，如: &#39;\bgrep\b&#39;只匹配grep 数字,字母,下划线,不能作为单词的分隔符。. 分组\(\) 将一个或多个字符捆绑在一起，当作一个整体处理，如：\(root\)\+分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \1, \2, \3, …\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符 示例： \(string1\+\(string2\)*\)\1: string1\+\(string2\)*\2: string2后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身或者：|示例：a|b: a或b C|cat: C或cat (C|c)at:Cat或cat ^ 行首$ 行尾 . 任意单一字符 [][]内任意单一字符 [^] 除[]内任意单一字符 * 前面字符重复不确定次数 \+ 前面字符重复一次以上不确定次数 \? 前面字符重复0或1次 \ 转义符.* 任意长度字符 \{n\} 前面字符重复n次 \{n,\} 前面字符重复n次以上\{m,n\} 前面字符重复m次和n次之间 扩展正则egrep = grep -Eegrep [OPTIONS] PATTERN [FILE…]扩展正则表达式的元字符：字符匹配：.任意单个字符 [] 指定范围的字符 [^] 不在指定范围的字符 次数匹配：* 匹配前面字符任意次 ? 0或1次 + 1次或多次 {m} 匹配m次 {m,n} 至少m，至多n次 位置锚定：^ 行首 $ 行尾 \&lt; #锚定单词的开始 \&gt; #锚定单词的结束 \b #单词锁定符 分组：() 后向引用：\1, \2, …或者：a|ba或b C|catC或cat (C|c)atCat或cat. vim:r! 命令 可以将命令执行的结果复制到内容里面去 脚本编程 脚本调试检测脚本中的语法错误bash -n /path/to/some_script 调试执行bash -x /path/to/some_script 环境变量局部变量变量赋值：name=‘value’可以使用引用value: (1)可以是直接字串; name=“root” (2) 变量引用：name=”$USER” (3) 命令引用：name=COMMAND name=$(COMMAND)变量引用：${name} $name “”：弱引用，其中的变量引用会被替换为变量值 ‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串显示已定义的所有变量：set 删除变量：unset name查看当前shell进程号：echo $$ echo BASHPID只读和位置变量只读变量：只能声明，但不能修改和删除声明只读变量：readonly namedeclare -r name查看只读变量： readonly –p 位置变量：在脚本代码中调用通过命令行传递给脚本的参数$1, $2, …：对应第1、第2等参数，shift [n]换位置 $0: 命令本身$*: 传递给脚本的所有参数，全部参数合为一个字符串$@: 传递给脚本的所有参数，每个参数为独立字符串$#: 传递给脚本的参数的个数$@ $* 只在被双引号包起来的时候才会有差异set – 清空所有位置变量 退出状态进程使用退出状态来报告成功或失败• 0 代表成功，1－255代表失败• $? 变量保存最近的命令退出状态例如：ping -c1 -W1 hostdown &amp;&gt; /dev/null echo $?返回值可以被指定。exit 100退出状态码bash自定义退出状态码 exit [n]：自定义退出状态码注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码 算术运算算术运算bash中的算术运算:help let+, -, *, /, %取模（取余）, **（乘方）实现算术运算：(1) let var=算术表达式(2) var=$[算术表达式](3) var=$((算术表达式))(4) var=$(expr arg1 arg2 arg3 …)(5) declare –i var = 数值(6) echo ‘算术表达式’ | bc乘法符号有些场景中需要转义，如*bash有内建的随机数生成器：$RANDOM（0-32767） echo $[$RANDOM%50] ：0-49之间随机数 let &quot;a=8+9&quot; a=$[9+7] expr 1 + 3 declare -i n=3+6 颜色指定Color=”\e[1;5;$[RANDOM%7+31]m”END=”\e[0m”echo -e “$Color 你好 $END”1：表示亮度；5：表示闪烁表示随机打印出任意颜色的 “你好” 赋值增强型赋值：+=, -=, *=, /=, %let varOPERvalue例如:let count+=3自加3后自赋值自增，自减：let var+=1let var++let var-=1let var– 逻辑运算true, false 1, 0与：1 与 1 = 11 与 0 = 0 0 与 1 = 00 与 0 = 0 或:1 或 1 = 11 或 0 = 10 或 1 = 10 或 0 = 0 非：！! 1 = 0 ! true! 0 = 1 ! false短路运算短路与第一个为0，结果必定为0第一个为1，第二个必须要参与运算短路或第一个为1，结果必定为1第一个为0，第二个必须要参与运算异或：^异或的两个值,相同为假，不同为真#str=abcde;[[ &quot;$str&quot; =~ ^abc ]] &amp;&amp; echo true || echo false正则表达式#str=abcdef;[[ &quot;$str&quot; == abc* ]] &amp;&amp; echo true || echo false通配符id $1 &amp;&gt; /dev/null &amp; ( echo &amp;1 is exist;exit ) || (useradd $1;echo $1 is created)echo finined小括号会开启子shell。退出只会退出子shell，不会退出脚本本身。 条件测试判断某需求是否满足，需要由测试机制来实现专用的测试表达式需要由测试命令辅助完成测试过程评估布尔声明，以便用在条件性执行中• 若真，则返回0• 若假，则返回1测试命令：• test EXPRESSION• [ EXPRESSION ]• [[ EXPRESSION ]]注意：EXPRESSION前后必须有空白字符 Bash的文件权限测试存在性测试-a FILE：同-e-e FILE: 文件存在性测试，存在为真，否则为假存在性及类别测试-b FILE：是否存在且为块设备文件-c FILE：是否存在且为字符设备文件-d FILE：是否存在且为目录文件-f FILE：是否存在且为普通文件-h FILE 或 -L FILE：存在且为符号链接文件-p FILE：是否存在且为命名管道文件-S FILE：是否存在且为套接字文件 Bash的文件属性测试文件权限测试：-r FILE：是否存在且可读-w FILE: 是否存在且可写-x FILE: 是否存在且可执行文件特殊权限测试：-u FILE：是否存在且拥有suid权限-g FILE：是否存在且拥有sgid权限-k FILE：是否存在且拥有sticky权限 文件大小测试：-s FILE: 是否存在且非空文件是否打开：-t fd: fd 文件描述符是否在某终端已经打开-N FILE：文件自从上一次被读取之后是否被修改过-O FILE：当前有效用户是否为文件属主-G FILE：当前有效用户是否为文件属组 双目测试：FILE1 -ef FILE2: FILE1是否是FILE2的硬链接FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）FILE1 -ot FILE2: FILE1是否旧于FILE2 Bash的组合测试条件第一种方式：COMMAND1 &amp;&amp; COMMAND2 并且COMMAND1 || COMMAND2 或者! COMMAND 非如：[ -f “$FILE” ] &amp;&amp; [[ “$FILE”=~ .*\.sh$ ]]第二种方式：EXPRESSION1 -a EXPRESSION2 并且EXPRESSION1 -o EXPRESSION2 或者! EXPRESSION必须使用测试命令进行，[[ ]] 不支持示例：[ -z “$HOSTNAME” -o $HOSTNAME &quot;==&quot;localhost.localdomain&quot; ] \ &amp;&amp; hostname www.magedu.com[ -f /bin/cat -a -x /bin/cat ] &amp;&amp; cat /etc/fstab read使用read来把输入值分配给一个或多个shell变量 -p 指定要显示的提示-s 静默输入，一般用于密码 -n N 指定输入的字符长度N -d ‘字符’ 输入结束符-t N TIMEOUT为N秒read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量read -p “Enter a filename: “ FILE bash如何展开命令行把命令行分成单个命令词展开别名展开大括号的声明（{}）展开波浪符声明（~）命令替换$() 和 ）再次把命令行分成命令词展开文件通配（*、?、[abc]等等）准备I/0重导向（&lt;、&gt;）运行命令 防止扩展反斜线（\）会使随后的字符按原意解释 $ echo Your cost: \$5.00Your cost: $5.00加引号来防止扩展• 单引号（’）防止所有扩展• 双引号（”）也防止所有扩展，但是以下情况例外：$（美元符号） － 变量扩展`（反引号） － 命令替换\（反斜线） － 禁止单个字符扩展!（叹号） － 历史命令替换 bash的配置文件按生效范围划分，存在两类：全局配置：/etc/profile/etc/profile.d/*.sh/etc/bashrc个人配置：~/.bash_profile ~/.bashrc shell登录两种方式交互式登录：(1)直接通过终端输入账号密码登录(2)使用“su - UserName” 切换的用户执行顺序：/etc/profile --&gt; /etc/profile.d/*.sh --&gt; ~/.bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc非交互式登录：(1)su UserName(2)图形界面下打开的终端(3)执行脚本(4)任何其它的bash实例执行顺序： /etc/profile.d/*.sh --&gt; /etc/bashrc --&gt;~/.bashrc Profile类按功能划分，存在两类：profile类和bashrc类profile类：为交互式登录的shell提供配置全局：/etc/profile, /etc/profile.d/*.sh 个人：~/.bash_profile功用：(1) 用于定义环境变量(2) 运行命令或脚本 bashrc类：为非交互式和交互式登录的shell提供配置全局：/etc/bashrc个人：~/.bashrc功用：(1) 定义命令别名和函数(2) 定义本地变量 编辑配置文件生效修改profile和bashrc文件后需要生效：两种方法：.重新启动shell进程.或source例：.~/.bashrc Bash 退出任务保存在~/.bash_logout文件中(用户)在退出登录shell时运行用于：创建自动备份清除临时文件想要登出后系统自动执行操作可以将执行动作放在： ~/.bash_logot $-h：hashall，打开这个选项后，Shell 会将命令所在的路径hash下来，避免每次都要查询。通过set +h将h选项关闭i：interactive-comments，包含这个选项说明当前的 shell 是一个交互式的shell。所谓的交互式shell,在脚本中，i选项是关闭的。m：monitor，打开监控模式，就可以通过Job control来控制进程的停止、继续，后台或者前台执行等。B：braceexpand，大括号扩展H：history，H选项打开，可以展开历史列表中的命令，可以通过!感叹号来完成，例如“!!”返回上最近的一个历史命令，“!n”返回第 n 个历史命令 locate-i 不区分大小写的搜索-n N 只列举前N个匹配项目-r 使用正则表达式例：搜索名称或路径中带有”conf”的文件locate conf find指搜索层级-maxdepth level 最大搜索目录深度，指定目录为第1级-maindepth level 最小搜索目录深度find /data -maxdepth 2 -mindepth 2 -name &quot;*.sh&quot; 表示只在/data下的二级目录下搜索先处理目录内的文件，再处理目录 -depth根据文件名和inode查找： -name “文件名称”:支持使用glob *,?,[],[^] -iname “文件名称”:不区分字母大小写 -inum n 按inode号查找 -samefile name 相同inode号的文件 -links n 链接数为n的文件 -reges “PATTERN”:以PATTERN匹配整个文件路径，而非文件名称 查找条件根据属主，属组查找：-user USERNAME :查找属主为指定用户(UID)的文件 -group GROUPNAME :查找属组为指定组(GID)的文件 -uid UserID :查找属主为指定的UID号的文件 -gid GroupID :查找属组为指定的GID号的文件 -nouser :查找没有属主的文件 -nogroup :查找没有属组的文件 根据文件类型查找：-type TYPE: f :普通文件 d :目录文件 l :符号链接文件 s :套接字文件 b :块设备文件 c :字符设备文件 p :管道文件空文件或目录： -emptyfind /app -type d -empty 查找条件组合条件： 与：-a 或：-o 非：-not,!德 摩根定律：(非A)或(非B)=非(A或B)(非A)且(非B)=非(A或B)示例： !A -a !B = !(A -o B) !A -o !B = !(A -a B) 根据文件大小来查找 -size[+|-]#UNIT 常用单位:k,M,G,c(byte) #UNIT:(#-1,#] 如: 6k表示(5k,6k] -#UNIT:[0,#-1] 如: +6k表示(0,5k] +#UNIT:(#,∞) 如: +6k表示(6k,∞) 根据时间戳：以”天”为单位-atime [+|-]#, #:[#,#+1) +#:[#+1,∞] -#:[0,#)-mtime-ctiime以”分钟”为单位-amin-mmin-cmin atime、ctime、mtime的区别atime：上一次访问这个文件是什么时候ctime：上一次改变这个文件的属性(元数据)是什么时候mtime：上一次改变这个文件的内容是什么时候 . 根据权限查找：-perm[/|-]MODE MODE:精确权限匹配 /MODE:任何一类(u,g,o)对象的权限中只要能一位匹配即可，或关系，从centos7开始淘汰 -MODE:每一类对象都必须同时拥有指定权限，与关系 ０:表示不关注find -perm 755会匹配权限模式恰好是755的文件只有当任意人有写权限时，find -perm +222就会匹配只要当每个人都有写权限时，find -perm -222才会匹配只要当其他人(other)有写权限时，find -perm -002 才会匹配 . 处理动作-exec COMMAND {} \;:对查到的每个文件执行有COMMAND指定的命令{}:用于引用查找到的文件名称自身find传递查找到的文件至后面的命令时，查找到所有符合条件的文件一次性传递给后面的命令 参数替换xargs由于很多命令不支持管道|来传递参数，而日常工作中有这个必要，所以就有了xargs命令xargs用于产生某个命令的参数，xargs可以读入stdin的数据，并且已空格符或回车将stdin的数据分隔为arguments注意:文件名或者是其他意义的名词内含有空格符的情况有些命令不能接受过多参数，命令执行可能会失败，xargs可以解决示例：ls f* | xargs rmfind /sbin -perm +700 | ls -l 这个命令是错误的,ls不支持标准输入find /sbin -perm +7000 | xargs ls -l 查找特殊权限的文件find和xargs格式:find | xargs COMMAND . 压缩compress [-dfvcVr]\[-b maxbits]\[file…] -d :解压缩，相当于gunzip -c :结果输出至标准输出，不删除原文件 -v :显示详情 uncompress 解压缩zcat file.Z &gt; file gzip/gunzip-d:解压缩，相当于gunzip-c :结果输出至标准输出，保留源文件不改变 -# :1-9，指定压缩比，值越大压缩比越大 zcat:不解压缩的前提下查看文本文件内容示例： gzip -c messages &gt; messages.gzgzip -c -d message.gz &gt; messageszcat messages.gz &gt; messagescat messages | gzip &gt; m.gz. bzip2/bunzip2/bzcatbzip2 [option]…FILE… -k :keep，保留原文件 -d :解压缩 -# :1-9,压缩比，默认为9 bzcat:不显示解压缩的前提下查看文件文件内容 xz/unxz/xzcatxz[OPTION]…FILE… -k :keep，保留原文件 -d :解压缩 -# :1-9，压缩比，默认为6unxz file.xz 解压缩xzcat: 不显示解压缩的前提下查看文本文件内容 -J：使用xz归档压缩；-Jcf /PATH/TO/SOMEFILES.tar FILE…|DIR：归档压缩；-Jxf /PATH/TO/SOMEFILES.tar：展开归档解压缩. zip/unzip 打包压缩zip -r /backup/sysconfig /etc/sysconfig解包解压缩unzip sysconfig.zipcat /var/log/messages | zip messages -unzip -p message &gt; message tar工具-exclude 排除文件tar zcvf /root/a3.tgz --exclude=/app/host1 --exclude=/app/host2/app-T选项指定输入文件，-X选项指定包含要排除的文件列表tar zcvf mybackup.tgz -T /root/includefilelist -X /root/excludefilelist splist:: 分割一个文件为多个文件分割大的tar文件为多份小文件split -b Size -d tar-file-name prefix-namesplit -b 1M -d mybackup.tgz mybackup-partssplit -b 1m mybackup.taz mybackup-parts合并：cat mybackup-parts* &gt; mybackup.tar.gz. spilt -b 2M -d /root/data.tar.xz databak -d会以数字结尾 cpio功能：cpio用于创建、解压归档文件，也可以对归档文件执行拷入拷出的动作，即向归档文件中追加文件，或从归档文件中提取文件。它也支持tar格式的归档文件，但是对压缩后的tar(如.tar.gz格式)就没法支持了，cpio毕竟不会调用对应的(解)压缩工具。cpio命令是通过重定向的方式将文件进行打包备份，还原恢复的工具，它可以解压以.cpio或者.tar结尾的文件 cpio [选项] &gt; 文件名或者设备名cpio [选项] &lt; 文件名或者设备名 -o 将文件拷贝打包成文件或者将文件输出到设备上 -O filename 输出到指定的归档文件名 -A 向已存在的归档文件中追加文件 -i 解包，将打包文件解压或将设备上的备份还原到系统 -I filename 对指定的归档文件名解压 -t 预览，查看文件内容或者输出到设备上的文件内容 -F filename 使用指定的文件名替代标准输入或输出 -d 解包生成目录，在cpio还原时，自动的建立目录 -v 显示打包过程中的文件名称 将etc目录备份：find ./etc -print |cpio -ov &gt;bak.cpio 将/data内容追加bak.cpio find /data | cpio -oA -F bak.cpio 内容预览cpio –tv &lt; etc.cpio 解包文件 cpio –idv &lt; etc.cpio . sed-n 不输出模式空间内容到屏幕，即不自动打印 -e 多点编辑 -f /PATH/SCRIPT_FILE 从指定文件中读取编辑脚本 -r 支持使用扩展正则表达 -i.bak 备份文件并原处编辑-i 直接修改script: &#39;地址命令&#39;地址定界： (1) 不给地址：对全文进行处理(2) 单地址： #: 指定的行，$：最后一行 /pattern/：被此处模式所能够匹配到的每一行(3) 地址范围： #,# #,+# pat1/,/pat2/ #,/pat1/(4) ~：步进 1~2 奇数行, 2~2 偶数行sed -i.back &#39;/^root/aadmin line passwd&#39; 插入并备份原文件 使用sed将/etc/httpd/conf/httpd.conf中#NameVirtualHost *:80去掉#号,同时将最后7行的#都去掉解:sed -e &#39;s/#Name/Name/&#39; -e &#39;/#&lt;VirtualHost/,/#&lt;\/Virtual/s/#//&#39; /etc/httpd/conf/httpd.conf. 编辑命令d 删除模式空间匹配的行，并立即启用下一轮循环p 打印当前模式空间内容，追加到默认输出之后a []text在指定行后面追加文本，支持使用\n实现多行追加i []text在行前面插入文本c []text 替换行为单行或多行文本w /path/file 保存模式匹配的行至指定文件r /path/file读取指定文件的文本至模式空间中匹配到的行后= 为模式空间中的行打印行号! 模式空间中匹配行取反处理 sed &#39;/^UUID/r /etc/issue&#39; /etc/fstab 读取/etc/issue中的内容到/etc/fstab UUID开头的行后 seq 10 | sed &#39;1~2d&#39; 输出双数的行 seq 10 | sed &#39;axxx\nyyy\nzzz&#39; sed &#39;/^root/i\ admin line&#39; /etc/passwd 加入了空格 sed &#39;/^root/aadmin line&#39; /etc/passwd sed &#39;/^UUID/w f1&#39; /etc/fstab sed &#39;/^UUID/=&#39; /etc/fstab 打印UUID开头的行显示行号 [root@centos7 ~]# seq -s + 10 -s指定分隔符 1+2+3+4+5+6+7+8+9+10 sed替换s/// 查找替换,支持使用其它分隔符，s@@@，s###替换标记：g 行内全局替换p 显示替换成功的行w /PATH/FILE 将替换成功的行保存至文件中例：sed -n &#39;s/UUID/tempfilesystem/gp&#39; /etc/fstabifconfig | sed -n &#39;2p&#39; | sed &#39;s/.*inet //&#39;|sed &#39;s@ netmask.*$@@&#39;ifconfig | sed -nr &#39;2s/.*t (.*) net.*/\1/gp&#39;ifconfig ens33 | sed -r &#39;2!d;s/.*inet (addr:)?//;s/ .*//&#39; sed取IP地址echo /etc/sysconfig/network-scripts/ | sed -nr &#39;s#(^.*/)([^/].*)/?$#\1#p&#39;取基名（不理解）sed大小写转换：sed -r &#39;s/[[:alpha:]]/\u&amp;/g&#39; /etc/fstabsed -r &#39;s/[[:alpha:]]/\l&amp;/g&#39; /etc/fstab sed 示例sed ‘2p’ /etc/passwd sed –n ‘2p’ /etc/passwd sed –n ‘1,4p’ /etc/passwd sed –n ‘/root/p’ /etc/passwd sed –n ‘2,/root/p’ /etc/passwd 从2行开始 sed -n ‘/^$/=’ file 显示空行行号 sed –n –e ‘/^$/p’ –e ‘/^$/=’ file sed ‘/root/a\superman’ /etc/passwd行后 sed ‘/root/i\superman’ /etc/passwd 行前 sed ‘/root/c\superman’ /etc/passwd 代替行 c:是表示将我现在所写的字符与所找到的行全部替换。不是字符替换。 sed ‘/^$/d’ file sed ‘1,10d’ file nl /etc/passwd | sed ‘2,5d’ nl /etc/passwd | sed ‘2a tea’ sed &#39;s/test/mytest/g&#39; example sed –n ‘s/root/&amp;superman/p’ /etc/passwd 单词后 sed –n ‘s/root/superman&amp;/p’ /etc/passwd 单词前 sed -e ‘s/dog/cat/’ -e ‘s/hi/lo/’ pets sed –i.bak ‘s/dog/cat/g’ pets nl:表示显示行号，空行不显示 &amp;：代表前面找到的内容 sed高级P：打印模式空间开端至\n内容，并追加到默认输出之前h: 把模式空间中的内容覆盖至保持空间中H：把模式空间中的内容追加至保持空间中g: 从保持空间取出数据覆盖至模式空间G：从保持空间取出内容追加至模式空间x: 把模式空间中的内容与保持空间中的内容进行互换n: 读取匹配到的行的下一行覆盖至模式空间N：读取匹配到的行的下一行追加至模式空间d: 删除模式空间中的行D：如果模式空间包含换行符，则删除直到第一个换行符的模式空间中的文本，并不会读取新的输入行，而使用合成的模式空间重新启动循环。如果模式空间不包含换行符，则会像发出d命令那样启动正常的新循环 sed -n &#39;n;p&#39; FILE sed &#39;1!G;h;$!d&#39; FILE sed‘N;D’FILE sed &#39;$!N;$!D&#39; FILE sed &#39;$!d&#39; FILE sed ‘G’ FILE sed ‘g’ FILE sed ‘/^$/d;G’ FILE sed &#39;n;d&#39; FILE sed -n &#39;1!G;h;$p&#39; FILE rpm–test: 测试安装，但不真正执行安装，即dry run模式–nodeps：忽略依赖关系–replacepkgs 强制重新安装已经安装的软件包–replacefiles 替换属于其他软件包的文件–nosignature: 不检查来源合法性 –nodigest：不检查包完整性–noscripts：不执行程序包脚本 %pre:安装前脚本 –nopre %post: 安装后脚本 –nopost %preun: 卸载前脚本 –nopreun %postun:卸载后脚本 –nopostun rpm升级upgrade：安装有旧版程序包，则“升级”如果不存在旧版程序包，则“安装” freshen：安装有旧版程序包，则“升级”如果不存在旧版程序包，则不执行升级操作 rpm -Uvh PACKAGE_FILE …rpm -Fvh PACKAGE_FILE …–oldpackage：降级 –force: 强制安装 注意：(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，可以直接安装新版本内核(2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名(FILENAME.rpmnew)后保留. 包查询-a: 所有包 -f: 查看指定的文件由哪个程序包安装生成 -p rpmfile：针对尚未安装的程序包文件做查询操作 –whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供 –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖rpm2cpio 包文件|cpio –itv 预览包内文件rpm2cpio 包文件|cpio –id &quot;\*.conf&quot; 释放包内文件 –changelog：查询rpm包的changelog -c: 查询程序的配置文件 -d: 查询程序的文档 -i: information -l: 查看指定的程序包安装后生成的所有文件 –scripts：程序包自带的脚本 –provides: 列出指定程序包所提供的CAPABILITY -R: 查询指定的程序包所依赖的CAPABILITY 包校验#rpm -V 已安装的包名选项：-V 校验指定RPM包中的文件。(verify) [root@Tiger ~]#rpm -V httpdS.5….T. c /etc/httpd/conf/httpd.conf验证内容中的8个信息的具体内容如下： S：文件大小是否改变； M：文件的类型或文件的权限(r w x)是否被改变； 5：文件MD5校验和是否改变(可以看成文件的内容是否改变)； D：设备的主，从设备号是否改变； L：文件路径是否改变； U：文件的属主(所有者)是否改变； G：文件的属组是否改变； T：文件的修改时间是否改变；文件类型： c :配置文件(config file) d :普通文档(documentation) g :”鬼”文件(ghost file),很少见，就是该文件不应该被这个RPM包包含 l :授权文件(license file) r :描述文件(read me) 秘钥包来源合法性验正及完整性验证完整性验证：SHA256来源合法性验证：RSA公钥加密对称加密：加密、解密使用同一密钥非对称加密：密钥是成对儿的public key: 公钥，公开所有人secret key: 私钥, 不能公开导入所需要公钥rpm -K|checksig rpmfile 检查包的完整性和签名rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 CentOS 7发行版光盘提供：RPM-GPG-KEY-CentOS-7rpm -qa &quot;gpg-pubkey*&quot; 检查系统公钥 rpm -qa &quot;gpg-pubkey*&quot;[root@centos7 Packages]# rpm --import /mnt/RPM-GPG-KEY-CentOS-7[root@centos7 Packages]# rpm -K tree-1.6.0-10.el7.x86_64.rpm 数据库数据库重建：/var/lib/rpmrpm {–initdb|–rebuilddb} initdb: 初始化如果事先不存在数据库，则新建之否则，不执行任何操作rebuilddb：重建已安装的包头的数据库索引目录 centos6 内核救援rpm -e kernel –nodeps 忽略依赖卸载内核修复:进入centos6光盘救援模式dfmkdir /mnt/cdrommount /dev/sr0 /mnt/cdromdf -hrpm -ivh /mnt/cdrom/Pack…… –root=/mnt/sysimage/ 告诉系统真根在/mnt/sysimage这个目录里面命令执行后，会没有启动菜单，进单用户编辑一个两行命令输完后，boot 回车 yumyum repolist 查看仓库信息仓库的元数据[root@centos7 ~]# cd /var/cache/yum/x86_64/7/yum history 查看yum安装历史yum history info 2 查看历史中的第二项 [epel] name=EPEL baseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/$releasever/$basearch gpgcheck=0 yum客户端配置文件：/etc/yum.conf：为所有仓库提供公共配置/etc/yum.repos.d/*.repo：为仓库的指向提供配置仓库指向的定义：[repositoryID]name=Some name for this repositorybaseurl=url://path/to/repository/enabled={1|0}gpgcheck={1|0}gpgkey=URLenablegroups={1|0}failovermethod={roundrobin|priority}roundrobin：意为随机挑选，默认值priority:按顺序访问cost= 默认为1000 yum的repo配置文件中可用的变量：$releasever: 当前OS的发行版的主版本号$arch: 平台，i386,i486,i586,x86_64等$basearch：基础平台；i386, x86_64$YUM0-$YUM9:自定义变量实例: http://server/centos/$releasever/$basearch/ http://server/centos/7/x86_64 http://server/centos/6/i384 实验基于httpd搭建的yum服务器：yum install -y httpd mkdir -pv centos/{6,7}/os/x86_64 html/ └── centos ├── 6 │ └── os │ └── x86_64 └── 7 └── os └── x86_64 ├── EFI │ └── BOOT │ └── fonts ├── images │ └── pxeboot ├── isolinux ├── LiveOS ├── Packages └── repodata mount /dev/sr0 html/centos/7/os/x86_64/ [base] name=Centos \#baseurl=file:///run/media/pan/CentOS\ 7\ x86_64/ baseurl=http://192.168.134.138/centos/$releasever/os/$basearch gpgcheck=0 yum 调用文件路径：`mirrorlist=http://192.168.134.138/list.txt[root@centos7 html]# lscentos list.txt[root@centos7 html]# cat list.txtfile:///var/www/html/centos/7/os/x86_64baseurl=http://192.168.134.138/centos/$releasever/os/$basearch``` 源码编译yum groupinstall &quot;development tools&quot; tar xf cmatrix-1.2a.tar.gz cd cmatrix-1.2a ./configure --prefix=/app/cmatrix make &amp;&amp; make install yum install -y ncurses-devel(缺的包) make &amp;&amp; make install cd /app/cmtrix/bin ./cmatrix 写入PATH echo &#39;PATH=/app/httpd/bin:$PATH&#39; &gt; /etc/profile.d/httpd.sh . /etc/profile.d/httpd.sh centos7:支持神奇目录：rpm -q autofssystemctl enabled autofssystemctl start autofs 建立仓库元数据：createrepo /data/repodbyum仓库必须要仓库元数据才能使用. centos 防火墙cnetos7:下次开机不启用 systemctl disable firewalld现在马上关掉：systemctl stop firewalld centos6:chkconfig iptables offservice iptables stop hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[style]]></title>
    <url>%2F2018%2F08%2F28%2F%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文章写作样式 样式详情请转下方原文地址 且不问结果如何，尽自己之所能，积极的面对。 Content (md partial supported) defaultprimarysuccessinfowarningdanger 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 背景文字 站点配置文件 主题配置文件 站点配置文件 主题配置文件 下载按钮 Download Now 点击访问博客 GA17 YouTube ghost.me 文字 字体图标居中引用 1.数字块定义 区域5.命令历史相关环境变量 本文旨在介绍样式的使用规则。 本文旨在介绍样式的使用规则。 本文旨在介绍样式的使用规则。 文字居中I heard the echo, from the valleys and the heartOpen to the lonely soul of sickle harvestingRepeat outrightly, but also repeat the well-being ofEventually swaying in the desert oasisI believe I amBorn as the bright summer flowersDo not withered undefeated fiery demon ruleHeart rate and breathing to bear the load of the cumbersomeBored GA17 1GA17 2GA17 3GA17 4逝者如斯夫，不舍昼夜我是一个怪物，来自我也不知道的地方f你觉得你死了，还有有人记得你吗 以上来源原文地址:https://qianling.pw/style/#TOC%E6%95%B0%E5%AD%97%E5%9D%97 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[document]]></title>
    <url>%2F2018%2F08%2F28%2Fdocument%2F</url>
    <content type="text"><![CDATA[Linux 文档 用户和用户组管理/etc/passwd:用户信息文件user1:x:500:500::/home/user1:/bin/bash第一字段:用户名称；第二字段:密码标志；第三字段:UID(用户ID)； 0：超级用户； 1-499：系统用户(伪用户)； 500-65535:普通用户；第4字段：GID(用户初始组ID)第5字段：用户说明第6字段：家目录 普通用户：/home/用户名/ 超级用户：/root/第7字段：登录之后的Shell 影子文件:/etc/shadow第1字段：用户名第2字符：加密密码 加密算法升级为SHA512散列加密算法 如果密码位是“ ！”或“ * ”代表没有密码，不能登录。第3字段：密码最后一次修改日期：使用1970年1月1号作为标准时间，每过一天时间戳加1。第4字段：两次密码的修改间隔时间(和第3字段相比)间隔多少时间后才可以修改密码。第5字段：密码有效期(和第3字段相比)第6字段：密码修改到期前的警告天数(和第5字段相比)第7字段：密码过期后的宽限天数(和第5字段相比) 0：代表密码过期后立即失效。 -1：则代表密码永远不会失效。第8字段：账号失效时间，要用时间戳表示第9字段：保留把时间戳换算为日期：date -d &quot;1970-01-01 17740 days&quot;把日期换算为时间戳：echo $(($(date --date=&quot;2018/07/28&quot; +%s)/86400+1)) 组信息文件/etc/group第一字段：组名第二字段：组密码标志第三字段：GID第四字段：组中附加用户 组密码文件/etc/gshadow第一字段：组名第二字段：组密码第三字段：组管理员用户名第四字段：组中附加用户 用户的家目录 普通用户：/home/用户名/,所有者和所属者都是此用户，权限是700 超级用户：/root/,所有者和所属者都是root用户，权限是550。 用户的邮箱：/var/spool/mail/用户名/ 用户模板目录：/etc/skel:创建用户时，用户的家目录会自动创建一些隐藏文件，这些文件是从/etc/skel/ 过去的。想要每个新添加用户时家目录自动出现共享文件可在此目录添加。 linux的特殊权限特殊权限： SUID,SGID,STICKY 1.进程以某用户的身份运行；进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作；2.权限匹配模型：(1)判断进程的属主，是否为被访问的文件属 主 ；如果是，则应用属主的权限；否则进入第2步；(2)判断进程的属主，是否属于被访问的文件属 组 ；如果是，则应用属组的权限；否则进入第3步;(3)应用other的权限； SUIDSetUID的功能:1、只有可以执行的二进制程序才能设定SUID权限。2、命令执行者要对该程序拥有X(执行)权限3、命令执行者在执行该程序时获得该程序文件属主的身份4、SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效。 SUID :默认情况下:用户发起的进程，进程的属主是其发起者；因此，其以发起者的身份运行； SUID 的功用：用户运行某程序时，如果此程序拥有SUID的权限，那么程序运行为进程时，进程的属主不是发起者，而程序文件自己的属主;管理文件的SUID权限： chmod u+|-s FILe 展示位置：属主的执行权限位。 #chomod 4644 filename取消suid权限：#chmod 644 filename 大写S为报错,检查是否有x权限. SGID用户在执行程序时候，组身份变为该程序文件的属组与SUID类似。 管理文件的 SGID 的权限： chmod g+|-s FILE SGID : 功用：当目录属组有写的权限，且SGID权限时，当你给一个目录添加了sgid之后，后面不管谁来这个目录下创建文件，文件的所属组都会继承目录的所属组展示位置：属组的执行权限位如果属组原本有执行权限，则显示为小写s;否则，显示为大写S; #ll /usr/bin/locate #ll /var/lib/mlocate/mlocate.db STICKY sticky :t权限只能给目录添加，当你给一个目录添加了t权限之后，后面所有人在这个目录下不能删除其他人的文件,只能删除自己的文件； 管理文件的Sticky权限： chmod o+|-t FILE 展示位置：其他用户的执行权限位 如果其他用户原本有执行权限，显示为小写t;否则为大写T。 系统上的/tmp和/var/tmp目录下默认均有Sticky权限 基于八进制方式赋权时，可于默认的三位八进制数字左侧再加一位八进制数字； chmod 1777 中的 1 表示特殊权限 . faclfacl:file access control lists 文件访问控制列表文件的额外赋权机制：在原有的u,g,o之外，另一层让普通用户控制赋权给另外的用户或组的赋权机制；查看分区ACL权限是否开启dumpe2fs -h /dev/sda3dumpe2fs命令是查询指定分区详细文件系统信息的命令.选项： -h 仅显示超级块中的信息，而不显示磁盘块组的详细信息 临时开启分区ACL权限： mount -o remount,acl / 重新挂载根分区，并挂载加入acl权限。 永久开启分区ACL权限#vi /etc/fstab UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 dufaults,acl 1 1 加入ACLmount -o remount /:重新挂载文件系统或重启动系统，使修改生效。getfacl filename:查看文件额外的权限setfacl命令： setfacl -m u:username:rw filename 赋权给用户： setfacl -m u:USERNAME:MODE file 赋权给组： serfacl -m g:GROUPNAME:MODE file 撤销赋权:serfacl -x u:USERNAME file serfacl -x g:USERNAME file 递归ACL权限：#setfacl -m u:用户名:权限 -R 目录名 默认ACL权限:默认acl权限的作用是如果给父目录设定了默认的ACL权限，那么父目录中所有新建的子文件都会继承父目录ACL的权限。#setfacl -m d:u:用户名:权限 文件名 setfacl 选项 文件名选项： -m :设定ACL权限 -x :删除指定的ACL权限 -b :删除文件所有的ACL权限 -d :设定默认ACL权限 -k :删除默认ACL权限 -R :递归设定ACL权限 最大有效权限maskmask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限”相与”才能得到用户的真正权限。 A B and r r r r - - - r - - - - 修改最大有效权限：#setfacl -m m:rx filename 设定mask权限为r-x。使用“m:权限”格式。 mask值只能添加ACL权限之后后期更改，当更改mask值以后再添加ACL权限，mask值就会变为777. 文件系统属性chattr权限#chattr [+-=] [选项] 文件或目录名+：增加权限-：删除权限=：等于权限 选项：-i:如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据还可以cp，但不允许建立和删除文件 -a:如果对文件设置a属性，那么只能在文件中增加数据(只能用echo增加数据，不能用vim)，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。chattr +i a.txtlsattr -a a.txt----i--------e- a.txt e:代表此文件在ext4文件系统下建立的。查看文件系统属性：lsattr 选项 文件名 -a显示所有文件和目录 -d若目标是目录，仅列出目录本身的属性，而不是子文件。 sudo权限root把本来只能超级用户执行的命令赋予普通用户执行。sudo的操作对象是系统命令 whereis 命令 查看命令的绝对路径visudo 实际修改的是/etc/sudoers文件root ALL=(ALL) ALL用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径) 被管理的主机地址可写成主机ip和ALL%wheel ALL=(ALL) ALL组名 被管理的主机地址=(可使用的身份) 授权命令(绝对路径) root ALL=(ALL) ALLst 192.168.81.137=/sbin/shutdown -r now 添加内容 st ALL=/usr/bin/vim 危险操作su - st:切换用户sudo -l:查看可用的sudo命令sudo /sbin/shutdown -r now 普通用户执行sudo赋予的命令 linux下查看帮助命令 whatis :用于查询一个命令执行什么功能，并将查询结果打印到终端上whatis ls man :Linux提供了丰富的帮助手册，当你需要查看某个命令的参数时不必到处上网查找，只要man一下即可 man command linux根目录结构和文件系统进程的类型： 终端:硬件设备，关联一个用户接口。 与终端相关:通过终端启动。 与终端无关:操作引导启动过程中自动启动操作系统的组成: 静态:kernel,application 文件系统:层级结构FHS: Filesystem Hierarchy Standard /bin:所有用户可用的基本命令程序文件； /sbin:供系统管理使用的工具程序； /boot:引导加载器必须用到的各种静态文件：Kernel,initramfs(initrd),grub等； /dev:存储特殊文件或设备文件； 设备有两种类型：字符设备(线性设备)、块设备(随机设备)； /etc:系统程序的配置文件，只能为静态： /home：普通的家目录的集中位置：一般每个普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME； /lib:为系统启动或根文件系统上的应用程序（/bin,/sbin）等提供共享库，以及为内核提供内核模块 libc.so.*:动态链接的C库； ld*:运行时链接器/加载器； modules:用于存储内核模块的目录； /lib64:64位系统特有的存放64位共享的路径； /media:便携式设备挂载点，cdrom,floppy等； /mnt:其他文件系统的临时挂载点； /opt：附加应用程序的安装位置：可选路径； /srv:当前主机为服务提供的数据； /tmp:为那些会产生临时文件的程序提供的用于临时文件的目录：可供所用户执行写入操作：有特殊权限； /usr:usr Hierarchy,全局共享的只读数据路径： bin,lib64 include:C程序头文件； share:命令手册页和自带文档等架构特有的文件的存储位置 local:另一个层级目录； X11R6:X-widow程序的安装位置 src:程序源代码文件的存储位置 多命令顺序执行多命令执行符格式作用&amp;&amp;命令1 &amp;&amp; 命令2逻辑与,当命令1正确执行,则命令2才会执行。当命令1执行不正确,则命令2不会执行||命令1 || 命令2逻辑或,当命令1执行不正确,则命令才会执行。当命令1正确执行,则命令2不会执行 通配符通配符作用?匹配一个任意字符*匹配0个或任意多个字符，也就是可以匹配任何内容[]匹配括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者a,或者b,或者c。[^]逻辑非，表示不匹配中括号内的任意一个字符。例如:[^0-9]代表匹配一个不是数字的字符。 Bash中其他特殊符号 符号作用&#39;&#39;单引号。在单引号中所有的特殊符号，如$,`(反引号)都没有特殊含义。&quot;&quot;双引号。在双引号中特殊符号都没有特殊含义，但是$,和\是例外,拥有&quot;调用变量的值&quot; `反引号引用命令,和&quot;转义符&quot;的特殊含义&quot;``反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。$()和反引号作用一样，用来引用系统命令。#在shell脚本中，#开头的行代表注释。$用于调用变量的值,如需要调用变量name的值时，需要用$name的方式得到变量的值时，需要用$name的方式得到变量的值。\转义符,跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出$符号，而不当做是变量引用。. [root@Tiger ~]# name=test [root@Tiger ~]# echo &#39;$name&#39; $name [root@Tiger ~]# echo &quot;$name&quot; test [root@Tiger ~]# abc=`date` [root@Tiger ~]# echo `date` 2018年 09月 09日 星期日 13:10:57 CST [root@Tiger ~]# echo $abc 2018年 09月 09日 星期日 13:10:49 CST [root@Tiger ~]# abc=$(date) [root@Tiger ~]# echo $abc 2018年 09月 09日 星期日 13:12:44 CST [root@Tiger ~]# echo &quot;abc&quot; abc [root@Tiger ~]# echo &quot;$abc&quot; 2018年 09月 09日 星期日 13:12:44 CST 反引号和$ #echo `ls` #echo $(date) Bash 变量什么是变量：变量是计算机内存单元，其中存放的值可以改变。当Shell脚本需要保存一些信息时，如一个文件名或一个数字,就把它存放在一个变量中，每个变量有一个名字，所以很容易引用它，使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。变量设置规则：explanation 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是”2name”则是错误的。 在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。 变量用等号连接值，等号左右两侧不能有空格。 变量的值如果有空格，需要使用单引号或双引号包括。 在变量的值中，可以使用”\”转义符。 如果需要增加变量的值，那么可以进行变量值的叠加，不过变量需要用双引号包含”$变量名”或用${变量名}包含。 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。 环境变量名建议大写，便于区分。变量的分类 用户自定义变量 环境变量:这种变量中主要保存的是和系统操作环境相关的数据。 位置参数变量:这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。 预定义变量:是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定好的。 本地变量变量定义：#name=&quot;bianliang&quot;变量叠加： #aa=123 #aa=$aa456 #aa=${aa}789变量调用：echo $name变量查看：set变量删除：&gt;unset name 环境变量环境变量是什么:用户自定义变量只在当前的Shell中生效，而环境变量会在当前Shell和这个Shell的所有子Shell当中生效。如果把环境变量写入相应的配置文件,那么这个环境变量就会在所有Shell中生效。 pstree:查看进程数,查看当前shell设置环境变量：export 变量名=变量值申明变量:env :查询变量,专门查看环境变量。set:查看所有变量unset 变量名 #删除变量 name=sc 本地变量export age=18 环境变量sex=man 本地变量。把已经定义好的本地变量变成环境变量，只需要：export sex 系统常见环境变量PATH:系统查找命令的路径 #echo $PATH/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/binPATH变量叠加：PATH=&quot;$PATH&quot;:/root/sh(脚本保存目录) ps1:定义系统提示符的变量：\d:显示日期，格式为”星期 月 日”\h:显示简写主机名。如默认主机名”localhost”\t:显示24小时制时间，格式为”HH:MM:SS”\T:显示12小时制时间，格式为”HH:MM:SS”\A:显示12小时制时间，格式为”HH:MM”\u:显示当前用户名\w:显示当前所在目录的完整名称\W:显示当前所在目录的最后一个目录#:执行的第几个命令\$:提示符。如果为root用户会显示提示符为”#”,如果普通用户会显示提示符为”$”。\@:时间 上下午 echo $PS1 :查看提示符[root@Tiger ~]# PS1=&#39;[\u@\t \w]\$ &#39;这里的空格生成以后,提示符后会有一个SPACE的距离。[root@16:10:52 ~]#cd /usr/local/src/[root@16:11:08 /usr/local/src]# #PS1=&#39;[\u@\@]\$&#39;[root@04:13 下午]#PS1=&#39;[\u@\@ \h]\$&#39;[root@04:17 下午 Tiger]#PS1=&#39;[\u \@@]\$&#39;[root 04:18 下午@]#^ 位置参数变量位置参数变量作用$nn为数字,$0代表命令本身,$1-$9代表第一到第九个参数,十以上的参数需要用大括号包含,如${10}$这个变量代表命令行中所有的参数,$把所有的参数看成一个整体$@这个变量也代表命令行中所有的参数,不过$@把每个参数区别对待$#这个变量代表命令行中所有参数的个数位置参数变量的名称和作用是固定的，他是为了接受用户向程序传入不同的值。 vim ceshi.sh #!/bin/bash echo $0 echo $1 echo $2 echo $3 :wq chmod 755 ceshi.sh ./ceshi.sh ./ceshi.sh 输出结果是本身 ./ceshi.sh 11 22 33 ./ceshi.sh 输 11 出 22 接 33 果 #!/bin/bash num1=$1 num2=$2 sum=$(($num1 + $num2)) //变量sum的和是num1加num2 echo $sum //打印sum的值 chmod 755 ceshi.sh ./ceshi.sh 11 22 #!/bin/bash echo $# echo $* echo $@ chmod 755 ceshi.sh ./ceshi.sh 11 22 33 44 55 66 6 11 22 33 44 55 66 11 22 33 44 55 66 预定义变量预定义变量作用$?最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行;如果这个变量的值非0(具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确了。$$当前进程的进程号(PID)$!后台运行的最后一个进程的进程号(PID)/td&gt;在Linux里面输入一条命令正确执行以后，输入echo $? ，默认输出 0当输出一条错误的命令以后，会系统报错，输入echo $? ，默认输出 127 #!/bin/bash echo &quot;$$&quot; find /root -name hello.sh $ // $符号的作用是把程序放在后台 echo &quot;$!&quot; chmod 755 ceshi.sh ./ceshi.sh 27888 27888 接受键盘输入read [选项][变量名] -p&quot;提示信息&quot;:在等待read输入时,输出提示信息 -t 秒数:read命令会一直等待用户输入，使用此选项可以指定等待时间。 -n 字符数:read命令只接受指定的字符数，就会执行 -s:隐藏输入的数据，适用于机密信息输入。 数值运算与运算符declare声明变量类型declare [+/-][选项] 变量名 -:给变量设定类型属性 +取消变量的类型属性 -i:将变量声明为整数型(integer) -x:将变量声明为环境变量 -p:显示指定变量的被声明的类型数值运算方法1: [root@Tiger data]#aa=11 [root@Tiger data]#bb=22给变量aa和bb赋值 [root@Tiger data]#declare -i cc=$aa+$bb方法2:expr或let数值运算工具 [root@Tiger data]#aa=11[root@Tiger data]#bb=22给变量aa和变量bb赋值 [root@Tiger data]#dd=$(expr $aa + $bb)$dd的值是aa和bb的和,注意”+”号左右两侧必须有空格方法3:$((运算式))或$[运算式] aa=11bb=22gg=$(($aa+$bb))ff=$[$aa+$bb] 运算优先级 优先级从上到下优先级运算符说明13-，+单目负,单目正12!，~逻辑非，按位取反或补码11*，/，%乘、除、取余10+，-加、减9&lt;&lt;，&gt;&gt;按位左移、按位右移8&lt;=，&gt;=，&lt;，&gt;小于或等于、大于或等于、小于、大于7==，!==等于、不等于6&amp;按位与5^按位异或4|按位或3&amp;&amp;逻辑与2||逻辑或1=，+=，-=， ，*=，/=，%=，&amp;=，^=，|=，&lt;&lt;=，&gt;&gt;=赋值、运算且赋值. 变量测试与内容替换 [root@Tiger ~]# unset y [root@Tiger ~]# x=${y-new} [root@Tiger ~]# echo $y [root@Tiger ~]# echo $x new [root@Tiger ~]# y=&quot;&quot; [root@Tiger ~]# x=${y-new} [root@Tiger ~]# echo $x [root@Tiger ~]# y=old [root@Tiger ~]# x=${y-new} [root@Tiger ~]# echo $x old [root@Tiger ~]# 环境变量配置文件source 配置文件 或 调用文件的命令 . 配置文件 环境变量配置文件简介：环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如PATH,HISTSIZE,PS1,HOSTNAME等默认环境变量。环境变量配置文件:①/etc/profile②/etc/profile.d/*.sh *是通配符，代表这个目录下所有以.sh结尾的文件。③~/.bash_profile④~/.bashrc⑤/etc/bashrc其中3个在/etc/下面的变量配置文件是对所有登录Linux用户生效。另外两个是用户家目录下的隐藏文件只对当前用户生效。 其他的配置文件和登录信息 注销时生效的环境变量配置文件：~/.bash_logout :这个文件默认是空的，如果想要每次登录比如清空历史命令或者把自己的环境变量清空等，写入后，注销时他会自动执行 ~/bash_history :保存的历史命令，但是有一些他还保存在内存当中，除非是手工写入history -w或者注销登录才会把内存中的命令转移到这个文件中去。 Shell登录信息 本地终端欢迎信息:/etc/issue只对本地登录有显示效果 转义符作用\d显示当前系统日期\s显示操作系统名称\l显示登录的终端号,这个比较常用\m显示硬件体系结构,如i386、i686等\n显示主机名\o显示域名\r显示内核版本\t显示当前系统时间\u显示当前登录用户的序列号 远程终端欢迎信息: /etc/issue.net (上图的转义符本文件不能使用,只能使用纯文本信息)转义符在/etc/issue.net文件中不能使用是否显示此欢迎信息,由ssh的配置文件 /etc/ssh/sshd_config决定，加入&quot;Banner /etc/issue.net&quot;行才能显示(记得重启SSH服务) 登录后显示 欢迎信息: /etc/motd 不管是本地登录,还是远程登录,都可以显示此欢迎信息.直接写入此文件即可 正则表达式与通配符正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配。grep、awk、sed等命令可以支持正则表达式。 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配。 元字符 作用*前一个字符匹配0次或任意多次.匹配除了换行字符外任意一个字符^匹配行首。例如：^hello 会匹配以hello开头的行。$匹配行尾。例如：hello$ 会匹配以hello结尾的行[]匹配中括号中指定的任意一个字符，只匹配一个字符。例如：[aeiou]匹配任意一个元音字母，[0-9]匹配任意一位数字，[a-z][0-9]匹配小写字母和一位数字构成的两位字符[^]匹配除中括号的字符以外的任意一个字符。例如：[^0-9]匹配任意一位非数字字符，[^a-z]表示任意一位非小写字母。\转义符。用于取消将特殊符号的含义取消。\{n\}表示其前面的字符恰好出现n次。例如：[0-9]\{4\}匹配4为数字，[1][3-8][0-9]\{9\}匹配手机号码\{n,\}表示其前面的字符出现不小于n次。例如：[0-9]\{2,\}表示两位及以上的数字\{n,m\}表示其前面的字符至少出现n次，最多出现m次。例如：[a-z]\{6,8\}匹配6到8位的小写字母 *前一个字符匹配0次，或任意多次grep &quot;a*&quot; ceshi.txt 匹配所有内容，包括空白行grep &quot;aa*&quot; ceshi.txt 匹配至少包含有一个a的行grep &quot;aaa*&quot; ceshi.txt 匹配最少包含两个连续a的字符串grep &quot;aaaaa&quot; a.txt 则会匹配最少包含四个连续的a的字符串. 匹配除了换行符外任意一个字符grep &quot;s..d&quot; a.txt s..d会匹配s和d这两个字符之间一定有两个字符的单词grep &quot;s.*d&quot; a.txt 匹配在s和d字母之间有任意字符grep &quot;.*&quot; a.txt 匹配所有内容^ 匹配行首，$匹配行尾grep &quot;^M&quot; a.txt 匹配以大写M开头的行grep &quot;n$&quot; a.txt 匹配以小写n结尾的行grep -n &quot;^$&quot; a.txt 会匹配空白行,-n 显示行号[] 匹配中括号中指定的任意一个字符，只匹配一个字符grep &quot;s[ao]id&quot; a.txt 匹配s和i字母中，要么是a要么是ogep &quot;[0-9]&quot; a.txt 匹配任意一个数字grep &quot;^[a-z] a.txt 匹配用小写字母开头的行grep &quot;^[a-z]&quot; a.txt 匹配用小写字母开头的行 ^ 匹配除中括号的字符以外的任意一个字符grep &quot;^[^a-z]&quot; a.txt 匹配不用小写字母开头的行grep &quot;^[^a-zA-Z]&quot; a.txt 匹配不多字母开头的行\ 转义符grep &quot;\.$&quot; a.txt 匹配使用.结尾的行\{n\} 表示其前面的字符恰好出现n次grep &quot;a\{3\}&quot; a.txt 匹配a字母连续出现三次的字符串grep &quot;[0-9]\{3\}&quot; a.txt 匹配包含连续的三个数字的字符串{n,\} 表示其前面的字符出现不小于n次grep &quot;^[0-9]\{3,\}&quot; a.txt 匹配最少用连续三个数字开头的行\{n,m} 匹配其前面的字符至少出现n次，最多出现m次grep &quot;sa\{1,3\}i&quot; a.txt 匹配在字母s和字母i之前有最少一个a,最多三个a 字符截取命令cut 字段提取命令printf 命令 (严格意义上讲他不属于字符截取命令，因为awk要用到，在这里提出)awk 命令sed 命令cut [选项][文件名] -f 列号: 提取第几列 -d 分隔符: 按照指定分隔符分割列.他的默认分隔符是Tabcut -f &quot;:&quot; -f 1,3 /etc/passwd [root@Tiger data]# vim b.txt 这里的空格是Tab键 1 ID NAME gender mark 2 1 liming M 86 3 2 sc M 90 4 3 cao M 83 [root@Tiger data]# cut -f 2 b.txt NAME liming sc cao [root@Tiger data]# cut -f 2,4 b.txt NAME mark liming 86 sc 90 cao 83 cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1 常和grep结合使用，查看用户文件，查找普通用户，过滤root，提取用户名称 cut命令的局限df -h | grep /dev/sda3 | cut -d &quot; &quot; -f 5 df命令使用的是空格分隔符，这条命令不能使用，cut对空格使用不友好 printf &#39;输出类型输出格式&#39; 输出内容输出类型:%ns：输出字符串。n是数字指代输出几个字符%ni：输出整数。n是数字指代输出几个数字%m.nf：输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2是小数，6位是整数。 输出格式作用\a输出警告音\b输出退格键，也就是Backspace键\f清除屏幕\n换行\r回车，也就是Enter键\t水平输出退格键，也就是Tab键\v垂直输出退格键，也就是Tab键 [root@Tiger data]# printf %s 1 2 3 4 5 6 123456[root@Tiger data]# [root@Tiger data]# printf %s %s %s 1 2 3 4 5 6 %s%s123456[root@Tiger data]# [root@Tiger data]# printf &#39;%s %s %s&#39; 1 2 3 4 5 6 1 2 34 5 6[root@Tiger data]# [root@Tiger data]# printf &#39;%s %s %s\n&#39; 1 2 3 4 5 6 1 2 3 4 5 6 [root@Tiger data]# printf输出文件内容格式：printf &#39;%s\n&#39; $(cat a.txt) [root@Tiger data]# printf &#39;%s\t %s\t %s\t %s\n&#39; $(cat b.txt) 调整格式输出 ID NAME gender mark 1 liming M 86 2 sc M 90 3 cao M 83 [root@Tiger data]# 在awk命令的输出中支持print和printf命令print：print会在每个输出之后自动加入一个换行符(linux 默认没有print命令)printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工换行符。 awkawk ‘条件1{动作1} 条件2{动作2}…’ 文件名条件：一般使用关系表达式作为条件x &gt; 10 判断变量x是否大于10x &gt;= 10 大于等于x &lt;= 10 小于等于动作：格式化输出流程控制语句df -h | awk &#39;{print $1 &quot;\t&quot; $5 &quot;\t&quot; $6}&#39; print 自动加入换行符 [root@Tiger data]# df -h | grep sda3 | awk &#39;{print $5}&#39; | awk -F &#39;%&#39; &#39;{print $1}&#39; 62 [root@Tiger data]# df -h | grep sda3 | awk &#39;{print $5}&#39; | cut -d &quot;%&quot; -f 1 62 BEGIN END awk &#39;BEGIN {printf &quot;打印这里的文字\n&quot;}{printf $2 &quot;\t&quot; $6 &quot;\n&quot;}&#39; a.txt 打印这里的文字 NAME gender liming M sc M cao M awk &#39;{FS=&quot;:&quot;}{print $1 &quot;\t&quot; $3}&#39; /etc/passwd 这样执行的话第一条会无法分割，所以可以在awk &#39;BEGIN{FS=&quot;:&quot;}{print $1 &quot;\t&quot; $3}&#39; /etc/passwd, awk是先读取一行在再执行命令，这样文件的第一行会来不及执行默认空格换行打印出。But但是可以直接用awk -F &quot;:&quot; &#39;{print $2 &quot;\t&quot; $3}&#39; /etc/passwdawk -F &quot;:&quot; &#39;END{print &quot;所有的命令执行完以后再执行&quot;&quot;}{print $2 &quot;\t&quot; $3}&#39; /etc/passwd关系运算符 [root@Tiger data]# cat b.txt ID NAME gender mark 1 liming M 86 2 sc M 90 3 cao M 83 [root@Tiger data]# cat b.txt | grep -v NAME | awk &#39;$3 &gt;= 87 {print $2}&#39; liming sc cao [root@Tiger data]# sedsed 是一种几乎包括在所有UNIX平台(包括linux)的轻量级流量编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。vi 只能修改文件，但是vi不能修改命令的输出，他只能先把命令的输出保存在文件中，然后修改文件的输出。但是sed可以修改命令的输出结果，结合管道符。sed [选项] &#39;[动作]&#39;文件名-n :一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。 -e :允许对输入数据应用多条sed命令编辑-i :用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出。 动作作用a\追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用\代表数据未完结c\行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用\代表数据未完结i\插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用\代表数据未完结d删除，删除指定的行p打印，输出指定的行s字符替换，用一个字符串替换另外一个字符串。格式为行范围s/旧字符串/新字符串/g(和vim中的替换格式类似). [root@Tiger data]# cat a.txt 例: ID name PHP Linux Mysql Average 1 Liming 82 95 86 87.66 2 Sc 74 96 87 85.66 3 Gao 99 83 93 91.66 行操作查看文件的第二行 [root@Tiger data]# sed &#39;2p&#39; a.txt ID name PHP Linux Mysql Average 1 Liming 82 95 86 87.66 1 Liming 82 95 86 87.66 2 Sc 74 96 87 85.66 3 Gao 99 83 93 91.66 [root@Tiger data]# sed -n &#39;2p&#39; a.txt 1 Liming 82 95 86 87.66 删除文件第2行到第4行，可以看到没有对文件本身造成影响 [root@Tiger data]# sed &#39;2,4d&#39; a.txt ID name PHP Linux Mysql Average [root@Tiger data]# cat a.txt ID name PHP Linux Mysql Average 1 Liming 82 95 86 87.66 2 Sc 74 96 87 85.66 3 Gao 99 83 93 91.66 在第二行后追加hello sed &#39;2a hello&#39; a.txt 在第二行前插入两行数据 sed &#39;2i hello\ world&#39; a.txt 修改第四行文件。将第四行的99替换成55 [root@Tiger data]# sed &#39;4c no file&#39; a.txt ID name PHP Linux Mysql Average 1 Liming 82 95 86 87.66 2 Sc 74 96 87 85.66 no file [root@Tiger data]# sed &#39;4s/99/55/g&#39; a.txt ID name PHP Linux Mysql Average 1 Liming 82 95 86 87.66 2 Sc 74 96 87 85.66 3 Gao 55 83 93 91.66 字符替换 sed &#39;s/旧字符/新字符/g&#39; 文件名在第3行中，把74换成99 sed &#39;3s/74/99/g&#39; a.txt sed操作的数据直接写入文件 sed -i &#39;3s/74/99/g a.txt&#39; 同时把linux和Gao替换为空 sed -e &#39;s/Linux//g;s/Gao//g/a.txt&#39; 前面没有加行号代表整篇文档 字符处理命令统计命令 wc -l :只统计行数 -w :只统计单词数 -m :只统计字符数 sort见command 条件判断按照文件类型判断测试选型作用-b 文件判断该文件是否存在，并且是否为块设备文件(是块设备文件为真)-c 文件判断该文件是否存在，并且是否为字符设备文件(是字符设备文件为真)-d 文件判断该文件是否存在，并且是否为目录文件(是目录为真)-e 文件判断该文件是否存在，(存在为真)-f 文件判断该文件是否存在，并且是否为普通文件(是普通文件为真)-L 文件判断该文件是否存在，并且是否为符号链接文件(是符号链接文件为真)-p 文件判断文件是否存在，并且是否为管道文件(是管道文件为真)-s 文件判断该文件是否存在，并且是否为非空(非空为真)-S 文件判断该文件是否存在，并且是否为套接字文件(是套接字文件为真) 判断文件是否存在(两种格式)test -e /root/install.log-e /root/install.log]第一个判断命令如果正确执行，则打印”yes”，否则打印”no”[ -d /root ] &amp;&amp; echo &quot;yes&quot; || &quot;no&quot;注意空格 按照文件权限进行判断测试选项作用-r 文件判断该文件是否存在，并且是否该文件拥有读权限(有读权限为真)-w 文件判断该文件是否存在，并且是否该文件拥有写权限-x 文件判断该文件是否存在，并且是否该文件拥有执行权限(有执行权限为真)-u 文件判断该文件是否存在，并且是否该文件拥有SUID权限(有SUID权限为真)-g 文件判断该文件是否存在，并且是否该文件拥有SGID权限(有SGID权限为真)-k 文件判断该文件是否存在，并且是否该文件拥有SBit权限(有SBit权限为真). test -w /data/a.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 他只要UGO只要有一个有写权限就会执行出来 两个文件之间进行比较测试选项作用文件1 -nt 文件2判断文件1的修改时间是否比文件2的新(如果新则为真)文件1 -ot 文件2判断文件1的修改时间是否比文件2的旧(如果旧则为真)文件1 -ef 文件2判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法比较硬链接的文件Inode号 test a.txt -ef /tmp/a1.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 两个整数之间比较测试选项作用整数1 -eq 整数2判断整数1是否和整数2相等 (相等为真)整数1 -ne 整数2判断整数1是否和整数2不相等 (不相等为真)整数1 -gt 整数2判断整数1 是否大于整数2 (大于为真)整数1 -lt 整数2判断整数1是否小于整数2 (小于为真)整数1 -ge 整数2判断整数1是否大于等于整数2 (大于等于为真)整数1 -le 整数2判断整数1是否小于等于整数2 (小于等于真) [ 23 -gt 22 ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot; 注意[]左右的空格 字符串的判断测试选项作用-z 字符串判断字符串是否为空(为空返回真)-n 字符串判断字符串是否为非空(非空返回真)子串1 == 子串2判断子串1是否和子串2相等(相等返回真)子串1 ！= 子串2判断字符串1是否和字符串2不相等(不相等为真). [root@Tiger data]# name=sc You have new mail in /var/spool/mail/root [root@Tiger data]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot; N [root@Tiger data]# aa=abc [root@Tiger data]# bb=abc [root@Tiger data]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;y&quot; || echo &quot;N&quot; y 多重条件判断测试选项作用判断1 -a 判断2逻辑与，判断1和判断2都成立，最终的结果才为真判断1 -o 判断2逻辑或，判断1和判断2有一个成立，最终的结果就为真! 判断逻辑非，使原始的判断式取反 [root@Tiger data]# aa=24 [root@Tiger data]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot; yes [root@Tiger data]# [ -z &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot; NO 流程控制语句if单分支if条件语句： if [ 条件判断 ] ;then 程序 fi 或者 if [ 条件判断 ] then 程序 fi 单分支条件语句需要注意几个点if语句使用fi结尾,和一般语言使用大括号结尾不同[ 条件判断 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格then后面跟符合条件之后执行的程序，可以放在[]之后，用:分割，也可以换行写入，就不需要；了. 判断用户输入的是什么文件 #!/bin/bash read -p &quot;Please input a filename: &quot; file if [ -z $file ] then echo &quot;Error please input a filenmae&quot; exit 1 1 elif [ ! -e $file ] then echo &quot;Your input is not file!&quot; elif [ -f $file ] then echo &quot;$file is a reguare file&quot; elif [ -d $file ] then echo &quot;$file is a directory file!&quot; else echo &quot;$file is a other file&quot; fi 备份/etc/目录 #!/bin/bash date=$(date +%F) size=$(du -sh /home) if [ -d /tmp/date ] then echo &quot;date is:$date&quot; &gt; /tmp/date/a.txt echo &quot;size is:$date&quot; &gt;&gt; /tmp/date/a.txt cd /tmp/date tar -zcf home_$date.tar.gz /home a.txt &amp;&gt;/dev/null rm -fr /tmp/date/a.txt else mkdir /tmp/date echo &quot;date is:$date&quot; &gt; /tmp/date/a.txt echo &quot;size is:$date&quot; &gt;&gt; /tmp/date/a.txt cd /tmp/date tar -zcf home_$date.tar.gz /home a.txt &amp;&gt;/dev/null rm -fr /tmp/date/a.txt fi nmap -sT ip地址：-sT作用扫描指定服务器查找的开放端口 判断sshd服务是否开启 #!/bin/bash port=$(nmap -sT 192.168.100.136 | grep ssh | awk &#39;{print $2}&#39;) if [ $port == &quot;open&quot; ] then echo &quot;$(date) sshd is ok!!&quot; &gt;&gt; /tmp/sshd_acc.log else /etc/rc.d/init.d/sshd restart &amp; &gt;/dev/null echo &quot;$(date) sshd reboot!!&quot; &gt;&gt; /tmp/sshd_err.log fi case语句多分支case条件语句 case语句和if…elif…else语句一样，都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。 1 #!/bin/bash 2 echo &#39;shanghai please input &quot;dddd&quot;&#39; 3 echo &#39;guangzhou please input &quot;2&quot;&#39; 4 echo &#39;chengdu please input &quot;3&quot;&#39; 5 read -t 30 -p &quot;Please input your weizhi: &quot; u 6 case $u in 7 &quot;dddd&quot;) 8 echo &quot;shanghai de &quot; 9 ;; 10 &quot;2&quot;) 11 echo &quot;guangzhou&quot; 12 ;; 13 &quot;3&quot;) 14 echo &quot;chengdu&quot; 15 ;; 16 *) 17 echo &quot;error 1/2/3&quot; 18 esac for循环语法一：for 变量 in 值1 值2 值3 do 程序 done 查看当前目录有多少.sh结尾的文件。 #!/bin/bash 2 cd /home/ceshi.sh 3 ls *.sh &gt; ls.log 4 y=1 5 for i in $(cat ls.log) 6 do 7 echo $y 8 y=$(( $y + 1)) 9 done 语法二：for((初始值；循环控制条件；变量变化)) do 程序 done 从1加到100 #!/bin/bash 2 s=0 3 for (( i=1;i&lt;=100;i=i+1 )) 4 do 5 s=$(( $s+$i )) 6 done 7 echo $s while循环while循环是不定循环，也称作条件循环。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和for的固定循环不太一样了。 while [ 条件判断式 ] do 程序 done 1 #!/bin/bash 2 i=1 3 s=0 4 while [ $i -le 100 ] 5 do 6 s=$(( $s+$i )) 7 i=$(( $i+1 )) 8 done 9 echo $s until循环until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。 #!/bin/bash i=1 s=0 until [ $i -gt 100 ] do s=$(( $s+$i )) i=$(( $i+1 )) done echo $s 服务的简介与分类启动与自启动 服务器启动: 就是在当前系统中让服务运行，并提供功能。 服务自启动: 自启动是指让服务在系统开机重启动之后，随着系统的启动而自动启动服务。rpm包安装的服务：chkconfig --list :查看服务自启动状态，可以看到所有RPM包安装的服务源码包安装的服务：查看服务安装位置，一般是/usr/local下RPM安装服务和源码包安装服务的区别： 就是安装位置的不同 源码包安装包安装在指定位置，一般是/usr/local/RPM包安装在默认位置中service 不能用于源码包，因为service默认搜索的是/etc/rc.d/init.d/这个路径，也就是RPM包安装的路径RPM包的一般存放的默认位置：/etc/init.d/ :启动脚本位置/etc/sysconfig/ :初始化环境配置文件位置/etc/ :配置文件位置/etc/xinted.conf ：xinetd配置文件/etc/xinetd.d/ :基于xinetd服务的启动脚本/var/lib/ :服务产生的数据放在这里/var/Log/ :日志 独立服务的启动：/etc/init.d/独立服务名 start|stop|status|restartservice 独立服务名 start|stop|status|restart status 查询服务的状态 service 红帽专有命令 service –status-all 列出系统所有已经安装的RPM包服务的状态 独立服务的自启动chkconfig命令 （详见command）修改/etc/rc.d/rc.local文件使用ntsysv命令管理自启动(红帽专有命令) 基于xinetd服务 yum -y install xinetd这是可以用chkconfig –list 查看服务可以看到基于xinetd的服务 yum -y install telnet-server 安装telnet服务端chkconfig –list 查看安装的服务Telnet的默认端口是23，netstat -tlun telnet服务还没有开启xinetd服务的启动：vim /etc/xinetd.d/telnet 修改文件service xinetd restart 重启xinetd服务 基于xinetd服务的自启动chkconfig telnet onntsysv 基于xinetd 服务的启动与自启动区别不明显，若关闭telnet(chkconfig telnet off)的自启动会将运行的telnet一并关闭，配置文件也会显示关闭状态。 . 源码包安装服务的启动使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。源码包服务的自启动：vi /etc/rc.d/rc.local 开机自启文件，加入下面的标准启动命令/usr/local/apache2/bin/apachectl start 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动vi /etc/init.d/apache# chkconfig: 35 86 76指定httpd脚本可以被chkconfig命令管理。格式是:chkconfig: 运行级别 启动顺序 关闭顺序#descriptaion:source package apache 说明，内容随意 启动顺序和关闭顺序不能和系统中现有服务的启动关闭顺序一样在/etc/rc.d/可以看到各个启动级别的服务启动关闭文件。例/etc/rc.d/rc3.d里面的文件S01表示依次启动，K01表示依次关闭。不能存在一样的启动关闭级别。 服务的总结： 进程管理进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源. body{ background-image:url(https://ws1.sinaimg.cn/large/005RRiqRly1fvyygdfzt6j31hc0u0138.jpg); background-position:center; background-repeat:repeat-y； }]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[command]]></title>
    <url>%2F2018%2F08%2F28%2Flinux%20command%2F</url>
    <content type="text"><![CDATA[linux 常用命令集合: 须知本博客样式是本人写博客一步一步完善，由于此前文章用了大量样式，导致样式混乱，后期由于篇幅过大无法更改，请见谅。 写在前面[root@pan ~]# root:登录的用户 @分隔符 pan主机名 ~当前路径\:newline echo $PATHctrl+r:在历史命令中搜索。 ctrl+s:暂停屏幕输出。 ctrl+q:恢复屏幕输出。&quot;&amp;&quot; &quot;||&quot; &quot;!&quot;只用普通用户登录Shell是/bin/bash catcat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ -n 显示的时候，顺道输出行号！ -A:查询所有的内容包括隐藏字符 ls-F:在每个输出项后追加文件的类型标识符，具体含义：“*“表示具有可执行权限的普通文件“/“表示目录 “@”表示符号链接“|”表示命令管道FIFO“=”表示sockets套接字当文件为普通文件时，不输出任何标识符drwxr-xr-x. 3 root root 24 May 11 23:29 Music这里的3: 如果是普通文件就表示链接次数，如果是目录文件就表示目录下的一级子目录数。ls -s:表示在每个文件前面显示出大小 echo#echo [选项][输出内容] echo -e &quot;\e[1;31m abcd \e[0m&quot; 输出颜色=30m 黑色，=31m 红色，=32m 绿色，=33m 黄色，=34m 蓝色，=35m 洋红，=36m 青色，=37m 白色。&quot;echo -e ab\bc&quot; 控制字符在末尾可能不执行。-e:支持反斜线控制的字符转换 控制字符 作用 \ 输出\本身 \a 输出警告音 \b \退格键，也就是向左删除键 \c 取消输出行末的换行符，和“-n”选项一致 \e ESCAPE键 \f 换页符 \n 换行符 \r 回车键 \t 制表符，也就是Tab键 \v 垂直制表符 \0nm 按照八进制ASCII码输出字符，其中0为数字零，nnn是三位八进制数 \xhh 按照十六进制ASCII码表输出字符。其中hh是两位十六进制数。 I/o redirection输出重定向:命令 &gt; 文件 2&gt;&amp;1 :以覆盖的方式，把正确输出和错误输出都保存在一个文件当中。命令 &amp;&gt;文件 :以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。 &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。1&gt;&amp;2 意思是把标准输出重定向到标准错误.2&gt;&amp;1 意思是把标准错误输出重定向到标准输出&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中 输入重定向：命令 &lt;文件wc [选项] [文件名]默认行，单词，字节数选项： -c :统计字节数 -w :统计单词数 -l :统计行数wc &lt; filename wc &lt;&lt; filename wc &lt;&lt; a.txt 注意a.txt &gt; dshi &gt; jdiosjfh &gt; diosjfiojd &gt; fdiojsoifj &gt; hello 4 4 36 sortsort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，不加参数时依次按ASCII码值进行比较，最后将他们按升序输出 -n :依照数值的从小到大排序; -f ：忽略大小写 -r :以相反的顺序来排序; -u :忽略相同行使用-u选项或者uniq 文件名 -t &lt;分隔符&gt;：指定排序时所用的栏位分隔字符； -k n[,m]是按照指定的字段范围排序，从第n字段开始，m字段结束(默认到行尾)（字母按ASCII排序，数字按从小到大。先数字后字母） [root@mail text]# sort -nrk 3 -t: sort.txt 将CC列数字从大到小顺序排列：eee:40:5.4eee:60:5.1ddd:20:4.2ccc:50:3.3bbb:10:2.5aaa:30:1.6AAA:BB:CC 列 指定分隔符是:，用第三字段开头，第三字段结尾排序，就是只用第三字段排序 [root@Tiger data]# sort -n -t &quot;:&quot; -k 3,3 /etc/passwd 但是这样排序会以字符串排序需要以数字排序 sort -n -t &quot;:&quot; -k 3,3 /etc/passwd awk awk &#39;{print $1}&#39; 文件名 $1第一列，$2第二列，$NF最后一列.$(NF-1)倒数第二列）。 现在是以文件的空格为分隔符这样打印 awk-F&quot;:&quot;&#39;{print $1}&#39; /etc/passwd -F指定分隔符，并打印文件第一列 多列打印#awk -F &quot;:&quot; &#39;{print $2 $3}&#39; /etc/passwd 这样打印$2 $3之间是没有分隔符 要加分隔符就是 awk -F &quot;:&quot; &#39;{print $2 &quot;\t&quot; $3}&#39; /etc/passwd $0表示整个文件 df文件系统查看命令 -a:显示所有的文件系统信息信息，包括特殊文件系统，如，/proc,/sysfs -h:使用习惯单位显示容量，如KB,MB或GB等。 -T:显示文件系统类型 -m: 以MB为单位显示容量。 -k:以KB为单位显示容量，默认就是以KB为单位显示容量。 du命令和df命令的区别df:命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间(最常见的就是文件已经删除，但是程序并没有释放空间) du: 命令是面向文件的，只会计算计算机文件或目录占用的空间. du是通过搜索文件来计算每个文件的大小然后累加，du能看到的文件只是一些当前存在的，没有被删除的。他计算的大小就是当前他认为存在的所有文件大小的累加和 -h : 以K，M，G为单位，提高信息的可读性。 -s : 统计总占用量，而不列出子目录和子文件的占用量。ls -h是目录下文件名占用大小 du -h 是目录下所有文件的大小 -k : 以KB(1024bytes)为单位输出。 -m : 以MB为单位输出。 -a显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量。 dddd(磁盘对拷命令)命令用于复制文件并对原文件的内容进行转换和格式化处理 [root@localhost]# dd if=输入文件 of=输出文件 bs=字节数 count=个数选项：if=输入文件 指定源文件或源设备of=输出文件 指定目标文件或目标设备bs=字节数 指定一次输入/输出多少字节，即把这些字节看做一个数据块count=个数 指定输入/输出多少个数据块 date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000(100M) ; data。 fsck文件系统修复命令fsck [选项] 分区设备文件名 -a:不显示用户提示，自动修复文件系统 -y:自动修复。和-a作用一致，不过有些文件系统只支持-y dumpe2fs显示磁盘状态命令 #dumpe2fs 分区设备名 rpmrpm是Linux标准基础（LSB）兼容发行版所使用的一种软件包管理器，用来对软件包进行低级处理rpm可以查询、安装、检验、升级和卸载软件包，它多数用于基于Fedora的系统，比如RHEL和CentOS 只有安装和升级要加包全名。 -ivh: -i:安装，-v:显示详细信息，-h:显示进度，–nodeps：不检测依赖性。 -Uvh包全名：RPM包升级. -q :接软件包名字 #查询软件是否已经安装 -q(查询query) -qa :#查询所有已经安装的RPM包。-a(所有all) -qi :包名字#查询软件包详细信息 -i :显示软件包的相关信息 -ql 包名:查询软件包安装位置 -l :显示套件的文件列表。 -qf +系统文件名。查看一个文件是由哪个包安装的 -qip 包全名:查询未安装软件包信息，必须在软件包目录进行查询。 -qR :查询软件包的依赖性。 -qRp :查询未安装软件包的依赖性必须在Packages目录查询。 -e 包名:卸载软件。rpm -qf `which 程序名` #返回软件包的全名 已安装的软件包rpm -qif `which 程序名` #返回软件包的有关信息rpm -qlf `which 程序名` #返回软件包的文件列表 RPM校验#rpm -V 已安装的包名选项：-V 校验指定RPM包中的文件。(verify) [root@Tiger ~]#rpm -V httpdS.5….T. c /etc/httpd/conf/httpd.conf验证内容中的8个信息的具体内容如下： S：文件大小是否改变； M：文件的类型或文件的权限(r w x)是否被改变； 5：文件MD5校验和是否改变(可以看成文件的内容是否改变)； D：设备的主，从设备号是否改变； L：文件路径是否改变； U：文件的属主(所有者)是否改变； G：文件的属组是否改变； T：文件的修改时间是否改变；文件类型： c :配置文件(config file) d :普通文档(documentation) g :”鬼”文件(ghost file),很少见，就是该文件不应该被这个RPM包包含 l :授权文件(license file) r :描述文件(read me) RPM包中文件提取#rpm2cpio 包全名 | \ cpio -idv .文件绝对路径 反斜杠：换行的作用。rpm2cpio:将rpm包转换为cpio格式的命令。cpio:是一个标准工具，他用于创建软件档案文件和从档案文件中提取文件。 #cpio 选项 &lt; [文件|设备]选项： -i:copy-in模式，还原 -d:还原时自动新建目录 -v：显示还原过程 rpm -qf /bin/ls 查询ls命令属于哪个软件包mv /bin/ls /tmp 造成ls命令误删除的假象rpm2cpio /mnt/Packages/coreutils-8.4-37.el6.x86_64.rpm | cpio -idv ./bin/ls提取RPM包中ls命令到当前目录的/bin/ls下 cp /root/bin/ls /bin 把ls命令复制到/bin目录，修复文件丢失。 源码包与RPM包的区别安装在指定位置当中，一般是/usr/local/软件名/。RPM包安装的服务可以使用系统服务管理命令(service)来管理，例如RPM包安装apache的启动方法是:/etc/rc.d/init.d/httpd start: 绝对路径启动服务。service httpd start源代码保存位置：/usr/local/src/软件安装位置：/usr/local/如何确定安装过程报错：安装过程停止；并出现error、warning或no的提示。源码包安装过程：下载源码包；解压缩下载的源码包；进入解压缩目录。 CRT中sftp里面要设置远程的路径和本地的路径:cd 1 进入远程连接到的Linux的1目录lcd \text 本地的c盘text目录get abc.c 从远程目录得到文件abc.c放入本地目录textput a11.txt 从Windows上将文件a11.txt传入linux 源码包配置./configure软件配置与检查 定义需要的功能选择。 检测系统环境是否符合安装需求。 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。./configure –prefix=/usr/local/apache2安装路径详情参考INSTALL 源码包的卸载：不需要卸载命令，直接删除安装目录即可，不会遗留任何垃圾文件。 脚本安装包：脚本安装包并不是独立的软件包类型，常见安装的是源码包。是人们把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。非常类似于Windows下软件的安装方式。 yum能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。remove :删除指定的rpm软件包； yum -y remove 软件包名yum update +包名 :升级。 禁用yum grouplist:列出所有可用的软件组列表；yum groupinstall 软件组名:安装指定的软件组，组名可以由goruplist查询出来；yum groupremove:卸载指定软件组； 配置yum仓库: [base] name=centos baseurl=file:///mnt/ enabled=1 gpgcheck=0 yum clean all 清除缓存，使最新的yum配置生效。yum list 列出所有可安装的软件包列表，包含已安装和未安装的 headhead 用来显示档案的开头至标准输出中,默认head命令打印其相应文件的开头10行 -n:显示文件的前n行 head -n 5 a.txt 显示文件的前5行 -c显示文件前n个字节 &gt;head -c 20 a.txt head -c -32 log2014.log文件的除了最后n个字节以外的内容head -n -6 log2014.log 输出文件除了最后n行的全部内容 . tail主要用来从指定点开始将文件写到标准输出。很多人喜欢使用tail -f 来监控日志文件。 -f该参数用于监视文件的增长 tail -f filename监视filename文件的尾部内容（默认10行，相当于增加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。 -n从指定行位置读取指定文件。 tail -n 20 filename 显示filename最后20行 -c显示文件最后n个字节 tail -c 20 a.txt chmod chmod命令用来变更文件或目录的权限，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件 -f :若该文件权限无法被更改也不要显示错误讯息 -R :对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)r=读取属性 值＝4 w=写入属性 值＝2 x=执行属性 值＝1 chown改变某个文件或目录的所有者和所属的组chown USER:GROUP 对象chown USER 对象 chown :group 对象 systemctlsystemctl命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起 chkconfig1.服务概述:在linux操作系统下，经常需要创建一些服务，这些服务被做成shell脚本，这些服务需要在系统启动的时候自动启动，关闭的时候自动关闭。将需要自动启动的脚本/etc/rc.d/init.d目录下，然后用命令chkconfig –add filename将自动注册开机启动和关机关闭。实质就是在rc0.d-rc6.d目录下生成一些文件连接，这些链接连接到/etc/rc.d /init.d目录下指定文件的shell脚本。 --list :列出所有系统服务 --add httpd:增加httpd服务。 --del httpd:删除httpd服务。 --list mysqld:列出mysqld服务设置情况 --level 35 mysqld on:设定mysqld在等级3和5为开机运行服务，–level 35表示操作只在等级3和5执行，on表示启动，off表示关闭。 chkconfig mysqld on:设定mysqld在各等级为on，“各等级”包括2、3、4、5等级。 chkconfig 设置是当前不生效，linux重启后才生效.service 设置是即时生效，linux关机重启后设置失效. mount查询与自动挂载(Auto Mount) mount [-l] 查询系统中已经挂载的设备，-l会显示卷标名称mount -a 依据配置文件/etc/fstab的内容，自动挂载 挂载命令格式 mount [-t 文件系统] [-L卷标名] [-o特殊选项] 设备文件名 挂载点-t 文件系统:加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统 -L 卷标名:挂载指定卷标的分区，而不是安装设备文件名挂载 -o 特殊选项:可以指定挂载的额外选项。 mount -o remount,noexec /home这里的/home是df可以查看到的分区重新挂载/home分区，并使用noexec权限 #cd /home #vi hello.sh#!/bin/bashecho “i love you”#chmod 755 #./hello.sh 会显示没有权限执行 #mount -o remount,exec /home 记得改回来，要不然会影响系统启动的。 挂载光盘mkdir /mnt/cdrom 建立挂载点mount -t iso9660 /dev/cdrom /mnt/cdrom 挂载光盘mount /dev/sr0 /mnt/cdrom 卸载光盘#umount设备文件名或挂载点umount /mnt/cdrom 挂载U盘fat32格式:fdisk -l 查看U盘设备文件名mount -t vfat /dev/sdb1 /mnt/usb/注意：fat16分区识别为fat,fat32分区识别为vft。linux默认是不支持NTFS文件系统的. NTFS u盘支持下载NTFS-3G插件https://www.tuxera.com/community/open-source-ntfs-3g/ 解压 tar -zxvf filename 安装 ./configure &amp;&amp; make &amp;&amp; make installfdisk -l查看linux的U盘分区：sdc1mount -t ntfs-3g /dev/sdc1 /mnt/usb/mkfs -t ext4 /dev/sdb1/ 格式化分区,扩展分区不可格式mkdir /disk1 建立挂载点mount /dev/sdb1 /disk1 挂载 swap新增swap空间:free查看swap大小新增一个分区，改分区号82，保存退出格式化：mkswap /dev/sdb6 加入swap分区：swapon /dev/sdb6取消swap分区：swapoff /dev/sdb6 但是每次开机都要手动挂载一遍，可以写入fatab开机自动挂载vi /etc/fstab/dev/sdb6 swap swap defaults 0 0 free显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。 -b ：以Byte为单位显示内存使用情况； -k ：以KB为单位显示内存使用情况； -m ：以MB为单位显示内存使用情况； total:去掉为硬件和操作系统保留的内存后剩余的内存总量。许多人奇怪自己的电脑安装了一共8G的内存，但是显示总共只有七点几G的，现在应该没什么疑惑了把，不管Linux还是Windows都会有部分内存是保留给硬件和操作系统的！ userd：当前已使用的内存总量。 free：空闲的或可以使用的内存总量 shared：共享内存大小，主要用于进程间通信 buff(buffers):缓冲，主要用于块设备数据缓冲(磁盘缓存大小)，例如记录文件系统的metadata（目录、权限等等信息）。是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减小了磁盘碎片和硬盘反复寻道，加速了数据的写入过程。 cache:缓存，主要用于文件内容缓冲,是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程。 available:可以使用的内存总量. Compression 压缩 commandgzipgzip filename压缩 *.gz :”后缀名”gzip -d filename.gz gunzip filename.gz 解压缩不解压查看：zcat filename.gz bz2bzip2 filename压缩 *.bzip2:”后缀名”bzip2 -k filename 保存源文件压缩bzip2 -d filename.bz2 bunzip2 filename.bz2解压缩不解压查看：bcat filename.bz2 xzxz filename压缩 .xz:”后缀名”xz -d filename.xz 解压缩unxz -k filename.xz 保存源文件解压-J：使用xz归档压缩 zipzip默认保存源文件，可以压缩目录解压：unzip FileName.zip压缩：zip FileName.zip DirName -r ：递归处理，将指定目录下的所有文件和子目录一并处理； tar-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的 tar cf file.tar files 将一个或多个文件、目录打包到tar包。tar rf file.tar file 将文件file添加到tar包中。tar uf file.tar file 将文件file更新tar包中相应的文件。tar tf file.tar 查看tar内容。tar xf file.tar 解压tar包。 -z:有gzip属性,即需要用 gzip 压缩 -j:有bz2属性,即需要用 bzip2 压缩 -v:显示处理过程 -C:指定解压输出目录 tar zxvf test.tar.gz -C test-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 -Z：有compress属性的 -O：将文件解开到标准输出 格式：tar Zcf file.tar.Z files 将一个或多个文件、目录压缩到file.tar.Z中。需要安装了ncompress软件包才行。解压.tar.Z文件。格式：tar Zxf file.tar.Z 归档并压缩：使用时间格式打包数据：tar zcf etc-$(date +%F).tar.gz /etc tar zcf etc-`date +%F`.tar.gz /etc *.tar.gz归档并调用gzip压缩 tar -zcf 新文件名.tar.gz /etc/passwd /var/log/messagages调用gzip解压缩并展开归档 tar -zxvf filename.tar.gz *.tar.bz2归档并调用bzip2压缩 tar -jcf 新文件名.tar.bz2 /etc/passwd /var/log/messages调用bzip解压缩并展开归档 tar -jxf filename.tar.bz2不解压缩查看：tar -tvf home_2018-10-14.tar.gz locate其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。 所以你要知道： locate的速度比find快，因为它并不是真的查找文件，而是查数据库locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护升级数据库命令：locate -- u CentOS系统找不到locate命令，原因是系统中没有安装 mlocate 这个包，然后更新数据库: updatedb -c :只显示找到条目的号码 -b :匹配唯一的路径名称的基本文件名 -r :基于基本正则表达式进行匹配操作 find实时查找工具，通过遍历指定起始路径下文件系统层级结构完成文件查找： 根据文件名查找： -name “pattern” -iname “pattern” 支持glob风格的通配符: \*,?,[],[^] i忽略大小写 -regex pattern :基于正则表达式查找文件，匹配整个路径而非其名； 根据文件从属关系查找：-user USERNAME:查找属主指定用户的所有文件； -goup GROUPNAME:查找属组指定组的所有文件； -uid UID:查找属主指定的UID的所有文件； -gid GID:查找属组指定的GID的所有文件； -nouser :查找没有属主的文件； -nogroup :查找没有属组的文件； 根据文件的类型查找：-type TYPE :按type查找f:普通文件 d:目录 l:符号链接文件 b:块设备文件 c:字符设备文件p:管道文件 s：套接字文件 【 ./可执行文件 】组合测试： 与：-a,默认组合逻辑而且的意思; -o 是或者的意思； -not,!：非(相反) find ./ -size -1M -a -type f #寻找当前目录下文件大于1M的文件或者是目录。 find ./ -size +1M -o -type d #寻找当前目录下文件小于1M并且文件类型是一般文件的文件。 !A -a !B =!(A -o B) !A -o !B =!(A -a B) 查找tmp目录下不包含“fstab”的字符文件 find /tmp -not -iname &quot;*fstab\*&quot; 根据文件的大小查找： -size [+|-]#UNIT 常用单位：K,M,G size 10K filename,大小表示 (#-1,#] 9K&lt;filename&lt;10K; size -10K filename,大小表示[0-UNIT-1]; size +10K filename,大小表示(#,∞); 根据时间戳查找以“天”为单位： # [#,#-1]距现在为止过去几天前访问过文件。-#:(0,#) 几天内访问过文件。+#(oo, #-1] 几天前至-oo访问过的所有文件 -atime:显示的是文件中的数据最后被访问的时间，比如系统的进程直接使用或通过一些命令和脚本间接使用。 -mtime:显示的是文件内容被修改的最后时间，比如用vi编辑就会发生改变。 -ctime:显示的是文件的权限、拥有者、所属的组、链接数发生改变时的时间。当然当内容改变时也会随之改变。以“分钟”为单位: -amin -mmin -cmin 同上 根据权限来查找 -perm [/|-]mode find ./ -perm 644mode:精确权限匹配； /mode :任何一类用户(u,g,o)的权限中的任何一位(r,w,x)符合条件即满足 9位权限之间存在“或”关系； -mode :每一类用户(u,g,o)的权限中的每一位(r,w,x)同时符合条件即满足 9位权限之间存在”与”关系；440属于/666有读的权限 find./ -perm /666 符合这一查找 处理动作：-print:输出至标准输出:默认的动作;-ls:类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息-delete:删除找到的文件-fls:/PATH/TO/SOMEFILE:把查找到的所有文件的长格式信息保存至指定文件中；-ok COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认；-exec COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令； 查找/var目录下属主为root，且属组为mail的所有文件或目录；find /var -user root -a -group mail -ls 查找/usr目录下不属于root,bin或hadoop的所有文件或目录；用两种方法find /usr -not -user root -a -not -user bin -a -not -user hadoopfind /usr -not \( -user root -o -user bin -o -user hadoop \) -ls 查找/etc目录下最近一周内其内容修改过，且属主不是root也不是hadoop用户的文件或目录；find /etc -mtime -7 -a -not -user root -a -not -user hadoopfind /etc -mtime -7 -a -not \(-user root -o -user hadoop\) -ls 查找当前系统上没有属主或属组，且最近一周内曾今被访问过的文件或目录；find ./ -nouser -o -nogroup -ls 如果有文件属于可查找项，但是加ls选项最后会无法输出显示 加了-o（或条件）和ls后只会对后一半生效。 需要find ./ \( -nouser -o -nogroup\) -atime -7 -ls 查找/etc目录下大于1M且类型为普通文件的所有文件；find /etc -size +1M -lsfind /etc -size +1M -type f -exec ls -lh {} \; 查找/etc目录下所有用户都没有写权限的文件；find /etc -not -perm /222 -type f -ls 至少有一个用户 有 查找/etc目录至少有一类用户没有执行权限的文件；find /etc -not -perm -type f -111 查找/etc/init.d目录下，所有用户都有执行权限，且其他用户有写权限的所有文件；find /etc -perm -111 -a -perm -002 -lsfind /etc -perm -113 -ls -type f historyhistory [选项][历史命令保存文件]-c:清空历史命令 -w:把缓存中的历史命令写入历史命令保存文件 ~/.bash_history 历史命令默认保存1000条，可以在环境变量配置文件/etc/profile中修改历史命令的调用： 使用上、下箭头调用以前的历史命令 使用”!n”重复执行第n条历史命令 使用”!!”重复执行上一条命令 使用”!字符串”重复执行最后一条以该字符串开头的命令。 使用ctrl+r 搜索历史命令 alias命令别名#alias 别名=&#39;原命令&#39; alias:查询命令别名。 命令执行时顺序： 第一顺位执行时用绝对路径或相对路径执行的命令。 第二顺位执行别名。 第三顺位执行Bash的内部命令。 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。让别名永久生效：vim /root/.bashrc删除别名：unalias 别名. vim:.,$y复制当前行到末尾行:! 调用系统命令，可临时执行 使vim设置永久生效:vim /etc/vimrc 把设置写到这个文件的最后，对所有账户生效set nu 显示行号 set nonu 取消行号set ic 不区分大小写 set noic 取消不区分大小写set ts=4 设置tab键长度set sw=4 设置自动缩进的tab键长度 vim /root/.vimrc 也可以把设置写到此文件，只对root生效 vim字符替换:%s/this/that 每一行的第一个this被替换成that:%s/this/that/g 将文本中所有的this替换成that %从每一行的开头到结尾 s表示替换:1,5 s/old/new/g #替换第一行到第5行中所有匹配的内容. 字符操作u撤销上一步i当前插入，I行首插入。a当前字符插入(光标后一位插入)，A行尾插入。o表示：本行回车到下一行插入，O上一行插入。x删除光标所在字符，X向前删除一个字符。dd删除光标所在的行，dG删除光标所在开始行到文件尾的所有字符。J合并两行。行操作：home 键或^键行首，$或end行尾dd删除一行Ndd(删除本行与下一行)。yy复制一行，Nyy复制n行，p将复制行粘贴，p向光标下一行粘。(N表示数字) 词操作:dw删除一个词，y+$复制至行尾。y+^复制至行首。yw复制一个词。:.,$y 复制当前行到末尾 v模式:编程的时候需要进行多行注释： （删除是要将光标移到这个词的行首，如果光标不在行首则删除光标之后的字母。）块操作：D或d+$删除至行尾 d+^删除至行首1、注释：ctrl+v进入列编辑模式2、向下或向上移动光标 （ctrl L 向下全部选中）3、把需要注释的行开头的开头标记起来4、然后按大写的I5、再插入注释符，比如“#”6、再按Esc，就会全部注释了删除多行注释：按ctrl+v进入列编辑模式;向下或向上移动光标；选中注释部 分然后按d,就会删除注释符号。 vim编辑器： :wq 可以保存外 :w +路径+文件名直接保存在某个位置和重命名:w 路径/文件名ZZ 保存退出 :x 保存退出 :!命令:!ifconfigvi的行定位功能:ctrl+f 向前卷动一个屏幕ctrl+b 向后卷动一个屏幕G 到文件最后一行行首:$ 到文件最后一行行尾mG 到指定行，m为目标行数 或者mggset nu 显示行号/内容 查找指定内容n 查找下一个N 回到前一个？ 寻找上一个 /^字符串 查找以字符串开始的行/字符串$ 查找以字符串结尾的行/a.b 查找字符串a任意字符b vim替换r 替换当前光标字符:r 文件名 在光标当前位置载入另一个文件. useradduseradd命令用来建立用户帐号和创建用户的起始目录，使用权限是终极用户. -u :uid指定用户ID -d:指定用户登入时的启始目录。 -g:指定用户所属的群组 -G:指定用户所属的附加群组。tom 用户的登陆 shell 为非交互式 shell useradd –s /sbin/nologin tom -e :指定账号的有效期限，缺省表示永久有效 useradd user1——创建用户user1;useradd –e 12/30/2009 user2——创建user2,指定有效期2009-12-30到期 -c:用户说明，手工指定用户的说明，添加说明有Spacebar时要加“ “。 用户默认值文件：/etc/defalut/useradd1.GROUP=100 :用户默认组ID (公有模式)2.HOME=/home :用户家目录3.INACTIVE=-1 :密码过期宽限天数(shadow文件7字段)4.EXPIRE=no value :密码失效时间(8字段)5.SHELL=/bin/bash :默认的shell6.SKEL=/etc/skel :模板目录7.CREATE_MAIL_SPOOL=yes :是否建立邮箱 /etc/login.defsPASS_MAX_DAYS 999 :密码有效期(5字段)PASS_MIN_DAYS 0 :密码修改间隔(4字段)PASS_MIN_LEN 5 :密码最小5位(PAM)PASS_WARN_AGE 7 :密码到期警告(6)UID_MIN 500 :最小和最大UID范围GID_MIX 60000ENCRYPT_METHOD SHA512 :加密模式. userdel删除用户userdel [-r] 用户名 -r:删除用户的同时删除用户家目录 id查看用户id：#id 用户名查询用户的UID,初始组ID,附加群组ID usermodusermod命令用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user id，必须确认这名user没在电脑上执行任何程序. -g &lt;群组&gt; 修改用户所属的原始群组。usermod -g root username -G &lt;群组&gt; 修改户所属的附加群组 -a -G 无限增加到附加组，可拥有多个附加组.将a1添加附加组user3 usermod -a -G user3 a1-c:修改用户的说明usermod -c &quot;test user&quot; username 当某一用户拥有多个附加组之后，使用usemod -G会修改附加组，则多个组消失掉变成唯一当前修改的附加组1.将 newuser2 添加到附加组 staff usermod -G staff newuser2 -l &lt;帐号名称&gt; 修改用户帐号名称。2.修改 newuser 的用户名为 newuser1 usermod -l newuser1 newuser-L 锁定用户密码，使密码无效。 -U 解除密码锁定。3.锁定账号 newuser1 usermod -L newuser14.解除对 newuser1 的锁定 usermod -U newuser1 -d 改变用户家目录,常与-m结合使用 -m 将主目录的内容移动到新目录usermod -m -d /home/user2 -uid username若使用报错使用以下命令：cat /dev/null &gt; /var/run/utmp 清空此文件。utmp是一个文件，除了utmp程序你不能编辑这个文件，删掉他的话，当前登陆信息都会丢失。它就好比系统开启后它会把系统成员的信息迅速的记录下来，过一段时间它就不再记录，确认系统的用户配置就是这样了，这个文件在每次机器reboot起来后都会重新创建。. groupadd-g GID: 修改组ID -n 新组名: 修改组名 susu: [选项] 用户名 -:选项只使用”-“代表连带用户的环境变量一起切换。可使用env命令查看-c:仅执行一次命令，而不切换用户身份su - root -c &quot;useradd user3&quot;不切换成root,但是执行useradd命令添加user1用户。 chage修改用户密码状态chagechage [选项] 用户名 -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期(shadow3字段) -m 天数:两次密码修改间隔(4字段) -M 天数:密码有效期(5字段) -W 天数:密码过期前警告天数(7字段) -I 天数:密码过后宽限天数(7字段) -E 日期:账号失效时间(8字段)chage -d 0 username这个命令其实是把密码修改日期归0了(shadow第3字段)，这样用户只要一登录就要修改密码。第三字段是指密码最后一次修改时间的日期。1970年1月1号到现在修改密码的时间戳。如果第3字段改为0，系统会认为用户没有修改过操作密码，那么当此用户一旦登录系统就会提示要修改密码，才可正常使用。. passwd-S:查询用户密码的密码状态，仅root用户可用。 -l:暂时锁定用户。仅root用户可用。 -u:解锁用户。仅root用户可用。 –stdin:可以通过管道符输出的数据作为用户的密码。echo &quot;123&quot; | passwd --stdin user gpasswd -d :从组删除用户 gpasswd -d username groupadd -a :添加用户到组(附加组),同时保留以前的组 添加用户到某一个组可以使用 usermod -G groupB userA 这个命令可以添加一个用户到指定的组，但是以前添加的组就会清空掉.所以想要添加一个用户到一个组，同时保留以前添加的组时，请使用gpasswd这个命令来添加操作用户 -A :指定组内管理员 gpasswd -A username groupname groups groups username 显示linux用户所属的组 datedate 根据给定格式显示日期或设置系统日期时间。print or set the system date and time 指令所在路径：/bin/date date &quot;+%Y-%m-%d %H:%M:%S&quot; -d:显示字符串所指的日期与时间。字符串前后必须加上双引号 date -d now date -d &#39;next monday&#39; date -d yesterday +%Y-%m-%d -r:显示文件最后修改时间 -s:设置系统时间 date -s &quot;2018-11-11 00 00 00&quot; 在使用date -s这个命令修改时间后，系统重启后就失效了，因此为了将这个时间永久生效，需要将修改的时间写入CMOS，查看CMOS的时间:clock –r将当前系统时间写入CMOS中去clock –w 在生产环境中常使用时间格式打包数据：tar zcvf etc-$(date +%F).tar.gz /etctar zcvf etc-`date +%F`.tar.gz /etc date:2018/9/23 hwclock查看硬件时间设置硬件时间hwclock --set --date=&quot;07/07/06 10:19&quot; （月/日/年 时:分:秒）硬件时间和系统时间的同步：重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需要用hwclock命令实现同步。硬件时钟与系统时钟同步：hwclock --hctosys（hc代表硬件时间，sys代表系统时间）系统时钟和硬件时钟同步:（让系统的时间同步到硬件时钟)hwclock –-systohc. lnln：链接命令硬链接：复制并同步 ln /etc/passwd /tmp/password 软链接：类似windows下的快捷方式 ln -s /etc/passwd /tmp password软链接和硬链接的区别:1.创建命令不同:ln -s /root/ruan.txt /root/桌面/ ln /root/ying.txt /root/桌面/2.软链接创建时必须使用绝对路径(链接和源文件在同一目录下,可以相对路径)硬链接创建时可以绝对路径也可相对路径3.软链接的源文件不可以剪切,重命名,删除 硬链接的源文件可以剪切,重命名,删除4.软链接的链接文件权限永远是777，即使将链接文件的权限进行了修改，也不会发生变化，变得是源文件的权限 硬链接的链接文件权限永远和源文件相同5.软链接的链接文件的inode号和源文件不同硬链接的链接文件的inode号和源文件相同6.软链接可以对目录操作硬链接不支持对目录操作，是针对于上层来说，底层是可以针对于目录做硬链接的，通过代码就可以实现7.软链接可以跨文件系统硬链接不可以跨文件系统，因为硬链接是存放在源文件的同一个block上面的 SElinux安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则） DAChttp://blog.51cto.com/zhaotianyu/1795178：在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：某个资源是否拥有对应用户的权限（读、写、执行）。只要访问这个资源的进程符合以上的条件就可以被访问。而最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问。这种权限管理机制的主体是用户，也称为自主访问控制（DAC）。 MAChttp://baijiahao.baidu.com/s?id=1590170088632157084&amp;wfr=spider&amp;for=pc：在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限。这样一来，即使进程是以 root 身份运行的，也需要判断这个进程的类型以及允许访问的资源类型才能决定是否允许访问某个资源。进程的活动空间也可以被压缩到最小。即使是以 root 身份运行的服务进程，一般也只能访问到它所需要的资源。即使程序出了漏洞，影响范围也只有在其允许访问的资源范围内。安全性大大增加。这种权限管理机制的主体是进程，也称为强制访问控制（MAC）。getenforce命令是单词get（获取）和enforce(执行)连写，可查看selinux状态setenforce 命令则是单词set（设置）和enforce(执行)连写，用于设置selinux防火墙状态，如： setenforce 0用于关闭selinux防火墙，但重启后失效。 SELinux status：selinux防火墙的状态，enabled表示启用selinux防火墙关闭SElinux:临时关闭 :setenforce 0用于关闭selinux防火墙，但重启后失效永久关闭：修改selinux的配置文件：vim /etc/selinux/config将SELINUX=enforcing改为SELINUX=disabled，保存后退出，此时获取当前selinux防火墙的安全策略仍为Enforcing，配置文件并未生效。重启后验证。SELinux 有三种工作模式，分别是：1.enforcing：强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中。2.permissive：宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用。3.disabled：关闭 SELinux crontab1.Crontab是一个用于设置周期性执行任务的工具；2.周期性执行的任务我们称为Cron Job；3.周期性执行的任务列表我们称为Cron Tablecrontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下: * * * * * command minute hour day month week command 顺序:分 时 日 月 周 minute： 表示分钟，可以是从0到59之间的任何整数。hour：表示小时，可以是从0到23之间的任何整数。day：表示日期，可以是从1到31之间的任何整数。month：表示月份，可以是从1到12之间的任何整数。week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件 -u:编辑某个用户的cron，只用root可以使用此参数为别的用户设置cron服务。也可用于给用户指定crontab文件。 -l: 列出当前用户的crontab。 -r: 删除当前用户的crontab。 -e: 编辑当前用户的crontab，默认使用vi，或者是由 VISUAL或EDITOR环境变量指定的编辑器。 -i与-r 一起使用，用来询问用户是否直接删除crontab安装cronyum install vixie-cronyum install crontabs检查crontab工具是否安装：crontab -l检查crond服务是否启动：service crond status检查crontab服务状态：service crond status 每晚的21:30重启apache30 21 * * * service httpd restart 每月1,10,22日的4:45重启apache45 4 1,10,22 * * service httpd restart 每月1-10日的4:45重启apache45 4 1-10 * * service httpd restart 每天18:00-23:00之间每隔30分钟重启apache0,30 18-23 * * * service httpd restart0-59/30 18-23 * * * service httpd restart 每晚11-早上7点之间，每隔一个小时重启apache* 23-7/1 * * * service httpd restart 每隔两分钟重启apache */2 * * * * service httpd restart 1-59/2 * * * * service httpd restart(奇数分钟重启) 0-58/2 * * * * service httpd restart(偶数分钟重启) 小结：*表示任何时候都匹配；可以用”A,B,C”表示A或者B或者C时执行命令可以用”A-B”表示A到B之间时执行命令可以用”*/A”表示每A分钟(小时等)执行一次命令*/1 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP时间同步: fdiskfdisk命令操作磁盘详解–添加、删除、转换分区等主分区和扩展分区(扩展分区不能直接使用)(1-4),扩展分区下面再分逻辑分区(5开始)。 fdisk /dev/sda 分区保存报错需要重启时，强制读取分区表信息#partprobeyum install -y parted grepgrep [选项] “搜索内容” 文件名 -i 忽略大小写 -n 输出行号 -v 反向查找 --color=auto把搜索出的关键字用颜色显示 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Entertainment video]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[As long as it starts it will not end！网络样式问题请翻越长城查看！ body{ background-image:url(https://ws1.sinaimg.cn/large/005RRiqRly1fvw1bz9he2j33dc28w4qu.jpg); background-position:center; background-repeat:repeat-y； } 魔术剪辑届 “巫男” 的创意新作《魔术》本文作分享，请勿用于商业用途。 【派大星的独白】一个关于正常人的故事]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F28%2F%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目归档 描述linux目录结构以及目录结构命名规定所有的目录都是按照一定的类别有规律的组织和命名的.FHS（目录层次结构）是Linux的目录规范标准.不要使用特殊字符来命令目录名。和glob字符或许会有冲突FHS（目录层次结构）: http://www.pathname.com/fhs/总结流程图:http://naotu.baidu.com/file/90bbd454b261551260c4e75ca6564f0d 显示/etc目录下，所有以.d结尾的文件或目录ls -d /etc/*.d -d 只显示当前文件夹 显示/etc目录下，所有.conf结尾，且以m,n,r,p开头的文件或目录ls /etc/[mnrp]*.conf 创建/app/rootdir目录，并复制/root下所有文件到该目录内， 要求保留原有权限[root@centos7 /]# mkdir -p /app/rootdir [root@centos7 /]# cp -a /root/ !$ cp -a /root/ /app/rootdir [root@centos7 /]# ls /app/rootdir/ root 使用命令行展开功能，创建/tmp/a1, /tmp/a2, /tmp/a1/a, /tmp/a1/b，在/tmp目录下创建目录：x_y, x_z, q_y, q_zmkdir {x,q}_{y,z} 总结用户、用户组管理命令并演示命令以及常见用法useradd 创建用户 http://holyghost.me/2018/08/28/linux%20command/-u 指定UID -g 指定所属组或gid -c “文字” 用户的注释信息 -d 指定家目录 -s 指定用户的默认登录的shell,可用列表在/etc/shells文件中 -G 指定用户的附加组，要先创建useradd -u 678 -g pan -c &quot;测试&quot; -d /data -s /bin/sh aaauserdel -r username 删除用户及所属的家目录和邮件groups username 显示linux用户所属的组groupadd groupname 创建组usermod -g root username将用户username的组修改为root组usermod -a -G-a -G 无限增加到附加组，可拥有多个附加组.将a1添加附加组user3 usermod -a -G user3 a1 某一用户拥有多个附加组之后，使用usemod -G会修改附加组，则多个组消失掉变成唯一当前修改的附加组 文件权限，属主属组管理命令有哪些，并演示命令以及用法chmod 更改文件权限：chmod 777 a http://holyghost.me/2018/08/28/linux%20command/chown 更改文件拥有者和所属组：chown USER:GROUP 对象 chown USER 对象 chown :group 对象chgrp 改变文件或目录所属的组: chgrp - R book /opt/local /book 改变/opt/local /book/及其子目录下的所有文件的属组为book 创建用户gentoo，附加组为bin和root，默认shell为/bin/csh，注释信息为 “Gentoo Distribution”useradd -G bin,root -s /bin/sh -c &quot;Gentoo Distribution&quot; gentoo 1、总结vim命令行模式常见快捷方式，以及vim查找，替换的方法:.,$y复制当前行到末尾行:! 调用系统命令，可临时执行 使vim设置永久生效:vim /etc/vimrc 把设置写到这个文件的最后，对所有账户生效set nu 显示行号 set nonu 取消行号set ic 不区分大小写 set noic 取消不区分大小写set ts=4 设置tab键长度set sw=4 设置自动缩进的tab键长度 vim /root/.vimrc 也可以把设置写到此文件，只对root生效 vim字符替换:%s/this/that 每一行的第一个this被替换成that:%s/this/that/g 将文本中所有的this替换成that %从每一行的开头到结尾 s表示替换:1,5 s/old/new/g #替换第一行到第5行中所有匹配的内容. ：s/a/b/ 替换当前行第一个a为b ：s/a/b/g 替换当前行所有a为b ：%s/a/b/ 替换每一行的第一个a为b ：%s/a/b/g 替换每一行中所有a为b 字符操作u撤销上一步i当前插入，I行首插入。a当前字符插入(光标后一位插入)，A行尾插入。o表示：本行回车到下一行插入，O上一行插入。x删除光标所在字符，X向前删除一个字符。dd删除光标所在的行，dG删除光标所在开始行到文件尾的所有字符。J合并两行。行操作：home 键或^键行首，$或end行尾dd删除一行Ndd(删除本行与下一行)。yy复制一行，Nyy复制n行，p将复制行粘贴，p向光标下一行粘。(N表示数字) 词操作:dw删除一个词，y+$复制至行尾。y+^复制至行首。yw复制一个词。:.,$y 复制当前行到末尾 v模式:编程的时候需要进行多行注释： （删除是要将光标移到这个词的行首，如果光标不在行首则删除光标之后的字母。）块操作：D或d+$删除至行尾 d+^删除至行首1、注释：ctrl+v进入列编辑模式2、向下或向上移动光标 （ctrl L 向下全部选中）3、把需要注释的行开头的开头标记起来4、然后按大写的I5、再插入注释符，比如“#”6、再按Esc，就会全部注释了删除多行注释：按ctrl+v进入列编辑模式;向下或向上移动光标；选中注释部 分然后按d,就会删除注释符号。 vim编辑器： :wq 可以保存外 :w +路径+文件名直接保存在某个位置和重命名:w 路径/文件名ZZ 保存退出 :x 保存退出 :!命令:!ifconfigvi的行定位功能:ctrl+f 向前卷动一个屏幕ctrl+b 向后卷动一个屏幕G 到文件最后一行行首:$ 到文件最后一行行尾mG 到指定行，m为目标行数 或者mggset nu 显示行号/内容 查找指定内容n 查找下一个N 回到前一个？ 寻找上一个 /^字符串 查找以字符串开始的行/字符串$ 查找以字符串结尾的行/a.b 查找字符串a任意字符b vim替换r 替换当前光标字符:r 文件名 在光标当前位置载入另一个文件. 2、总结脚本中运算符、逻辑运算以及用法按照文件类型判断 测试选型作用-b 文件判断该文件是否存在，并且是否为块设备文件(是块设备文件为真)-c 文件判断该文件是否存在，并且是否为字符设备文件(是字符设备文件为真)-d 文件判断该文件是否存在，并且是否为目录文件(是目录为真)-e 文件判断该文件是否存在，(存在为真)-f 文件判断该文件是否存在，并且是否为普通文件(是普通文件为真)-L 文件判断该文件是否存在，并且是否为符号链接文件(是符号链接文件为真)-p 文件判断文件是否存在，并且是否为管道文件(是管道文件为真)-s 文件判断该文件是否存在，并且是否为非空(非空为真)-S 文件判断该文件是否存在，并且是否为套接字文件(是套接字文件为真) 判断文件是否存在(两种格式)test -e /root/install.log-e /root/install.log]第一个判断命令如果正确执行，则打印”yes”，否则打印”no”[ -d /root ] &amp;&amp; echo &quot;yes&quot; || &quot;no&quot;注意空格 按照文件权限进行判断测试选项作用-r 文件判断该文件是否存在，并且是否该文件拥有读权限(有读权限为真)-w 文件判断该文件是否存在，并且是否该文件拥有写权限-x 文件判断该文件是否存在，并且是否该文件拥有执行权限(有执行权限为真)-u 文件判断该文件是否存在，并且是否该文件拥有SUID权限(有SUID权限为真)-g 文件判断该文件是否存在，并且是否该文件拥有SGID权限(有SGID权限为真)-k 文件判断该文件是否存在，并且是否该文件拥有SBit权限(有SBit权限为真). test -w /data/a.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 他只要UGO只要有一个有写权限就会执行出来 两个文件之间进行比较测试选项作用文件1 -nt 文件2判断文件1的修改时间是否比文件2的新(如果新则为真)文件1 -ot 文件2判断文件1的修改时间是否比文件2的旧(如果旧则为真)文件1 -ef 文件2判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法比较硬链接的文件Inode号 test a.txt -ef /tmp/a1.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 两个整数之间比较测试选项作用整数1 -eq 整数2判断整数1是否和整数2相等 (相等为真)整数1 -ne 整数2判断整数1是否和整数2不相等 (不相等为真)整数1 -gt 整数2判断整数1 是否大于整数2 (大于为真)整数1 -lt 整数2判断整数1是否小于整数2 (小于为真)整数1 -ge 整数2判断整数1是否大于等于整数2 (大于等于为真)整数1 -le 整数2判断整数1是否小于等于整数2 (小于等于真) [ 23 -gt 22 ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot; 注意[]左右的空格 字符串的判断测试选项作用-z 字符串判断字符串是否为空(为空返回真)-n 字符串判断字符串是否为非空(非空返回真)子串1 == 子串2判断子串1是否和子串2相等(相等返回真)子串1 ！= 子串2判断字符串1是否和字符串2不相等(不相等为真). [root@Tiger data]# name=sc You have new mail in /var/spool/mail/root [root@Tiger data]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot; N [root@Tiger data]# aa=abc [root@Tiger data]# bb=abc [root@Tiger data]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;y&quot; || echo &quot;N&quot; y 多重条件判断测试选项作用判断1 -a 判断2逻辑与，判断1和判断2都成立，最终的结果才为真判断1 -o 判断2逻辑或，判断1和判断2有一个成立，最终的结果就为真! 判断逻辑非，使原始的判断式取反 [root@Tiger data]# aa=24 [root@Tiger data]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot; yes [root@Tiger data]# [ -z &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot; NO 3、编写脚本/root/bin/backup.sh，可实现每日将/etc/目录备份到 /root/etcYYYY-mm-dd中#!/bin/bash echo &quot;Start Backup&quot; sleep 5 cp -av /etc/ /root/data/etc`date +%F` echo &quot;backup is finished&quot; 4、编写脚本/root/bin/nologin.sh和login.sh,实现禁止和充许普通用户登录系统禁止普通用户登录系统 #!/bin/bash read -p &quot;请输入禁止登陆用户名: user uid=$(id $user | sed -r -n &#39;s/.*=([0-9]{3,}).*$/\1/p&#39;) [ $uid -ge 500 ] &amp;&amp; usermod -s /bin/nologin $user || echo &quot;该用户为系统用户，无法禁止&quot; echo &quot;该用户已经禁止登陆&quot; 允许普通用户登录系统 #!/bin/bash read -p &quot;请输入允许登录的用户： user uid=$( id $user | sed -r -n &#39;s/.*=([0-9]{3,}).*$/\1/p&#39; ) [ $uid -ge 500 ] &amp;&amp; usermod -s /bin/bash $user || echo &#39;该用户为系统用户&#39; echo &#39;该用户已允许登陆&#39; 5、编写脚本/root/bin/disk.sh,显示当前硬盘分区中空间利用率最大的值df | grep /dev/sd | grep -o &#39;[0-9]\+%&#39; | sort -nr | head -1 3 1.查找/var/目录下不属于root、lp、gdm的所有文件find /var/ -not -user root -a -not -user lp -a -not -user gdm; 2.统计/etc/init.d/functions文件中每个单词的出现次数，并排序(用grep和sed两种方法分别实现)$ cat /etc/init.d/functions|tr -c &#39;[:alpha:]&#39; &#39;\n&#39;|tr -s &#39;\n&#39; | sort | uniq -c | sort -nr $ sed -nre &#39;s/[^[:alnum:]]+/\n/g&#39; -e &#39;s/[0-9]/\n/gp&#39; /etc/init.d/functions|sort|uniq -c|sort -n $ grep -Eo &quot;\&lt;[[:alpha:]]+[[:alnum:]]+\&gt;&quot; /etc/init.d/functions | sort | uniq -c | sort -n [:alpha:] 表示任何大小写字母tr -c, 用集合1中的字符串替换，要求字符集为ASCII -s, 即将重复出现字符串压缩为一个字符串[:alnum:] 任意字符sort 将文本文件内容加以排序 -n 依照数值的从小到大排序。 -r 以相反的顺序来排序。uniq -c或–count 在每列旁边显示该行重复出现的次数[:alnum:] 表示字母和数字\&lt; #锚定单词的开始，如:&#39;\&lt;\grep&#39;匹配包含以grep开头的单词的行&#39; 3.利用sed取出ifconfig命令本机的IPV4地址ifconfig | sed -nr &#39;2s/.*t (.*) net.*/\1/p&#39; 4.总结yum的配置和使用，包括yum仓库的创建yum repolist 查看仓库信息仓库的元数据yum history 查看yum安装历史yum history info 2 查看历史中的第二项yum客户端配置文件：/etc/yum.conf：为所有仓库提供公共配置/etc/yum.repos.d/*.repo：为仓库的指向提供配置仓库指向的定义：[repositoryID]name=Some name for this repositorybaseurl=url://path/to/repository/enabled={1|0}gpgcheck={1|0}gpgkey=URLenablegroups={1|0} 5.编写系统初始化脚本reset.sh,包括别名，提示符颜色，yum仓库配置文件#!/bin/bash c=&quot;alias cdnet=&#39;cd /etc/sysconfig/network-scripts&#39;&quot; a=&quot;alias ednet=&#39;vim /etc/sysconfig/network-scripts/ifcfg-ens33&#39;&quot; echo $c &gt;&gt; /root/.bashrc echo $a &gt;&gt; /root/.bashrc source /root/.bashrc echo -e &quot;PS1=\&quot;\e[33m[\u@\h \W]\$\e[m\&quot;&quot; &gt; /etc/profile.d/env.sh source /etc/profile.d/env.sh echo &#39;PATH=/data/bin:$PATH&#39; &gt; /etc/profile.d/input.sh source /etc/profile.d/input.sh chmod +x /etc/profile.d/* mkdir /data/base mount /dev/sr0 /data/base [ -d /etc/yum.repos.d/bak ] &amp;&amp; echo &quot;yes&quot; exit || mkdir /etc/yum.repos.d/bak mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak touch /etc/yum.repos.d/base.repo echo -e &quot;[base]\nname=cdrom\nbaseurl=file:///data/base\ngpgcheck=0&quot; &gt;&gt;/etc/yum.repos.d/base/repo 6.安装tree,lftp,telnet等包yum install tree ftp lftp telnet 7.在centos7上编译安装apache2.4源码包，并启动此服务yum groupinstall “development tools” 使用组包安装tar -xf httpd-2.4.39.tar.gzcd httpd-2.4.39/通过./configure –指定软件总目录，二进制目录和其他功能make 使用make命令创建make文档文档中存放着各种文件路径make install 讲各文件复制到所对应的目录systemctl start apache 启动服务 4 1、磁盘lvm管理，完成下面要求，并写出详细过程： 1) 创建一个至少有两个PV组成的大小为20G的名为testvg的VG;要求PE大小 为16MB, 而后在卷组中创建大小为5G的逻辑卷testlv;挂载至/users目录 [root@centos7 ~]# pvcreate /dev/sd{b1,c} fdisk新的分区之后，t类型转换为8e为LINUX LVM [root@centos7 ~]# pvs PV VG Fmt Attr PSize PFree /dev/sdb1 lvm2 --- 10.00g 10.00g /dev/sdc lvm2 --- 10.00g 10.00g [root@centos7 ~]# vgcreate -s 16M testvg /dev/sd{b1,c} -s用来指定PE的大小 Volume group &quot;testvg&quot; successfully created [root@centos7 ~]# lvcreate -L 5G -n testlv testvg [root@centos7 ~]# mkfs.ext4 /dev/testvg/testlv [root@centos7 ~]# mkdir /users [root@centos7 ~]# mount /dev/testvg/testlv /users/ (2) 扩展testlv至7G，要求archlinux用户的文件不能丢失 [root@centos7 ~]# lvextend -L +2G /dev/testvg/testlv [root@centos7 ~]# lvs 查看大小 [root@centos7 ~]# resize2fs /dev/testvg/testlv (3) 收缩testlv至3G，要求archlinux用户的文件不能丢失 [root@centos7 ~]# umount /dev/testvg/testlv [root@centos7 ~]# resize2fs /dev/testvg/testlv 3G 先缩减文件系统 [root@centos7 ~]# lvreduce -L 3G /dev/testvg/testlv (4) 对testlv创建快照，并尝试基于快照备份数据，验证快照的功能lvcreate -L 1G -s -n kuaizhao -p r /dev/testvg/testlvmount /dev/vg0/kuaizaho /kuaizhao 此时快照目录与源目录中的文件一样当修改源lv目录中的文件时，快照目录文件不会发生变化 2、创建一个可用空间为1G的RAID1设备，文件系统为ext4，有一个空闲盘，开机可自动挂载至/backup目录mdadm -C /dev/md0 -l 1 -n 2 /dev/sdb{1,2} -x 1 /dev/sdb3-C：创建模式专属选项包括：-n #:指定使用#个块设备来创建此RAID；-l #:指定要创建的RAID的级别；-a {yes|no}:指定是否自动创建目标RAID设备的设备文件；-c CHUNK_SIZE:指定块大小；-x #:指定空闲盘的个数； 创建挂载点与文件系统 cd mkdir /backup mkfs.ext /dev/md0 设置挂载 vim /etc/fstab blkid UUID=7b6dcdd4-a061-4417-8cbc-f3e9db4e7082 /backup ext4 defaults 0 0 mount -a 3、简述TCP链接建立和断开过程 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我。 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:我已经收到你的请求了,你可以传输数据了;你要用哪个序列号作为起始数据段来回应我。 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:我已收到回复,我现在要开始传输实际数据了 4、简述TCP和UDP的区别UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息。优点：UDP速度快、操作简单、要求系统资源较少，由于通讯不需要连接，可以实现广播发送缺点：UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，也不重复发送，不可靠。TCP是面向连接的通讯协议，通过三次握手建立连接，通讯完成时四次挥手优点：TCP在数据传递时，有确认、窗口、重传、阻塞等控制机制，能保证数据正确性，较为可靠。缺点：TCP相对于UDP速度慢一点，要求系统资源较多。 6 1、总结IP地址规划IP地址分五大类A类地址: 1-127B类地址: 128-191C类地址: 192-223D类地址: 240-245E类地址: 保留 2、总结常见网络管理命令ping 用来测试网络是否互通ifconfig 查看IP网卡netstat 命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况 -netstat -a //列出所有端口 -netstat -at //列出所有tcp端口 -netstat -au //列出所有udp端口 3、给定IP地址167.77.88.99和掩码255.255.255.192，子网号是什么？广播地址是什么？有效IP地址是什么？10100111.01001101.01011000.01100011 167.77.88.9911111111.11111111.11111111.11000000 255.255.2555.192子网号=ip地址与子网掩码相与得到: 10100111.01001101.01011000.01000000 167.77.88.64/26 广播地址:主机位全为0是一个网络地址是一个网段，主机位全为1是一个广播地址由子网掩码可知网络位是前26位，主机位是后6位,所以将ip地址的后六位全部置为1可得到10100111.01001101.01011000.01111111 167.77.88.127 有效IP地址: 网络号+1——广播地址减1 167.77.88.65——167.77.88.126 4、添加IP地址192.168.2.2/24到eth0网卡上ifconfig eth0 192.168.2.2/24 5、top,iostat,vmstat命令总结top 动态查看进程状况P：以占据的CPU百分比,%CPUM：占据内存百分比,%MEMT：累积占据CPU时长,TIME+iostat 工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况vmstat用来显示Linux系统虚拟内存状态，也可以报告关于进程、内存、I/O等系统整体运行状态 6、找出CPU占用最多的前10个进程ps aux | sort -nrk 3 | moresort -n: 按照数值大小从小到大排列-r:执行反方向（由上至下）整理-k:使用第3列来排序 7、crontab实现，在12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 /usr/bin/backup0 6-12/3 * 12 * /usr/bin/backup 7 1.编写脚本实现传入进程pid,查看对应进程/proc下CPU、内存指标#!/bin/bash read -p &quot;please input PID to Mematy&amp;CPU infos: &quot; pid checkpid=`ps aux | sed -nr &quot;1! p&quot; | tr -s &quot; &quot; | cut -d &quot; &quot; -f 2 | grep $pid` if [ ! $checkpid ];then echo &quot;NO error &quot; else echo &quot;Memory info: &quot; echo &quot;`cat /proc/$pid/status | grep ^Vm`&quot; echo &quot;Cpu info: &quot; echo &quot;`cat /proc/$pid/status | grep ^Cpu`&quot; echo &quot;%cpu is `ps -p $pid -o pcpu | sed -nr &quot;2p&quot;`&quot; fi 2.编写脚本实现每分钟检查一个主机端口是否存活(提示使用nmap),如果检查端口不在线，sleep 10s,如果三次都不存在，记录到日志#!/bin/bash read -p &quot;Please input a ip address: &quot; ip_addr read -p &quot;Please input a port: &quot; port port_stat=`nmap $ip_addr -p $port | grep &quot;^[0-9]&quot; | cut -d &quot; &quot; -f 2` i=1 while [ $i -le 3 ];do #判断整数1是否小于等于整数2 (小于等于真) if [ &quot;$port_stat&quot; != &quot;open&quot; ];then sleep 10s else break fi let i++ if [ $i -eq 3 ];then #判断整数1是否和整数2相等 (相等为真) echo &quot;host:$ip_addr port:$port is not open&quot; &gt;&gt; /var/log/host_port.log fi done 3.编写脚本/root/bin/excute.sh，判断参数文件是否为sh后缀的普通文件，如果是，添加所有人可执行权限，否则提示用户非脚本文件#!/bin/bash read -p &quot;please input filename: &quot; file if [[ $file =~ .*sh$ ]];then if [ -f $file ];then chmod a+x $file fi else echo &quot;非脚本文件&quot; fi 4.编写脚本/root/bin/nologin.sh和login.sh实现禁止和允许普通用户登录系统#!/bin/bash read -p &quot;please input user: &quot; user uid=`id $user | sed -nr &quot;s/.*=([[:digit:]]+)\(.*$/\1/p&quot;` if [[ $uid -ge 500 ]];then usermod -s /bin/nologin $user echo &quot;该用户已禁止登陆&quot; else echo &quot;该用户为系统用户无法禁止&quot; fi 5.编写脚本/root/bin/sumid.sh,计算/etc/passwd文件中的第10个用户和第20用户的ID之和。#!/bin/bash a=`cat /etc/passwd | head -10 | tail -1 | cut -d &quot;:&quot; -f 3` b=`cat /etc/passwd | head -20 | tail -1 | cut -d &quot;:&quot; -f 3` let c=a+b echo &quot;$c&quot; unset a b 8 1、用shell脚本实现自动登录机器#!/usr/bin/expect spawn ssh root@192.168.152.131 expect { &quot;yes/no&quot; { send &quot;yes\n&quot;;} &quot;password&quot; {send &quot;123456\n&quot;} } interact #interact：允许用户交互 2、shell 判断一个值bone是否在数组arrayZ=( one two three four five five )中#!/bin/bash arrayz=( &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;bone&quot; ) for i in `seq 0 $[${#arrayz[@]}-1]`;do j=0 if [ ${arrayz[$i]} == bone ];then echo &quot;arrayz in bone&quot; else let j++ fi done echo $j from arrayz is not bone unset arrayz 3、用命令或者脚本实现 0057AF051EFF 变为 00:57:AF:05:1E:FF 。a=0057AF051EFF;echo ${a:0:2}:${a:2:2}:${a:4:2}:${a:6:2}:${a:8:2}:${a:10:2} 字符处理 或 #!/bin/bash a=0057AF051EFF for (( i=2;i&lt;${#a};i=i+2 ));do if [ &quot;$i&quot; -lt &quot;${#a}&quot; ];then #-lt 小于等于 echo -n &quot;${a:$((i-2)):2}:&quot; else # echo &quot;${a:$((i-2)):2}&quot; exit fi done echo -e &quot;\r&quot; 4、a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 56 7 8 9 0 ! \@ # \$ \% \^ \&amp; * ( ) - _ \= + \ \/ \’ \” \; \: [ ] { } \, . \?用以上字符，结合数组，实现一个随机生成20位密码的脚本 #!/bin/bash declare -a a a=( a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0 \! \@ \# \$ \% \^ \&amp; \* \( \) \- \_ \= \+ \\ \/ \&#39; \&quot; \; \: \[ \] \{ \} \, \. \? ) i=`echo ${#a[*]}` for (( j=1;j&lt;=20;j++ ));do k=$[RANDOM%i] echo -n &quot;${a[$k]}&quot; done echo #换行 5、详细叙述centos7开机流程① POST加电自检(BIOS或UEFI进行硬件)② MBR引导(自检没有问题后，BIOS将会直接去找硬盘的第一个扇区，找到前446字节，将MBR加载到内存中，MBR将告诉程序下一阶段去哪里找系统grub引导。此阶段属于grub的第一阶段。)③ GRUB引导：grub的1.5和第2阶段，信息默认存放在扇区中，如果使用grub-install生成的文件是存放在/boot分区中的。为了加载内核系统,需要加载/boot分区，而加载/boot分区，又需要/boot分区的驱动，/boot分区的驱动是放在/boot分区中的，这里就进行了一个死循环。——就grub来说，为了打破在MBR中只有446Bytes用于存放bootloader这一限制，所以这一步的实现是这样的：grub是通过分成三个阶段来实现加载内核这一功能的，这三个阶段分别是：stage1, stage1.5以及stage2。其中： stage1：存放于MBR的前446Bytes，用于加载stage1.5阶段，目的是为了识别并驱动stage2(或者/boot)所在分区的文件系统； stage1.5：存放于MBR之后的扇区，加载stage2所在分区的文件系统驱动，让stage1中的bootloader(引导加载程序)能识别stage2所在分区的文件系统； stage2：存放于磁盘分区之上，具体存放于/boot/grub目录之下，主要用于加载内核文件(vmlinuz-VERSION-RELEASE)以及ramdisk这个临时根文件系统(initrd-VERSION-RELEASE.img或initramfs-VERSION-RELEASE.img)。 概述：假如要启动的是硬盘设备，首先我们的硬件平台主板BIOS必须能够识别硬盘，然后BIOS才能加载硬盘中的bootloader，而bootloader自身加载后就能够直接识别当前主机上的硬盘设备了；不过，能够识别硬盘设备不代表能够识别硬盘设备中的文件系统，因为文件系统是额外附加的一层软件组织的文件结构，所以要对接一种文件系统，就必须要有对应的能够识别和理解这种文件系统的驱动，这种驱动就称为文件系统驱动。而stage1.5就是向grub提供文件系统驱动的，这样stage1就能访问stage2及内核所在的分区(/boot)了注意：kernel和initramfs的文件路径均以grub的”根”作为起始目录，且存放于stage2所在分区上；需要注意的是，stage2、内核以及ramdisk文件通常放置于一个基本磁盘分区之上，因为grub无法驱动lvm、高级软raid等复杂逻辑设备，除非提供一个复杂的驱动接口，否则如果stage2及内核等文件都存放在lvm等复杂逻辑设备上将无法被stage1所识别，更别说加载了！④Kernel自身初始化Kerenl在得到系统控制权之后，首先要进行自身初始化，而初始化的主要作用是： (1)探测可识别到的所有硬件设备； bootloader将系统控制权移交给内核就好比如后朝推翻前朝，统治者(内核)当权之后，首先要检查一下有哪些是前朝所留下的，例如有哪些领土、人力、财力、兵力可用等等。 (2)加载硬件驱动程序，即加载真正的根文件系统所在设备的驱动程序（有可能会借助于ramdisk加载驱动）；这就像统治者(内核)在得知底下存在的人力、财力之后，开始将可以“为我所用”的人力纳入麾下，听自己使唤，而不听使唤的杀掉； (3)以只读方式挂载根文件系统；如果有借助于ramdisk这个临时文件系统（虚根），则在这一步之后会执行根切换；否则不执行根切换。 (4)运行用户空间的第一个应用程序：/sbin/init.到这里内核空间的启动流程就结束了，而接下来是用户空间完成后续的系统启动流程。 注意：ramdisk和内核是由bootloader一同加载到内存当中的，ramdisk是用于实现系统初始化的、基于内存的磁盘设备，即加载至内存（的某一段空间）后把内存当磁盘使用，并在内存中作为临时根文件系统提供给内核使用，帮助内核挂载真正的根文件系统。而之所以能够帮助内核挂载根文件系统是因为在ramdisk这个临时文件系统的/lib/modules目录下有真正的根文件系统所在设备的驱动程序；除此之外，这个临时文件系统也遵循FHS，例如有这些固定目录结构：/bin, /sbin, /lib, /lib64, /etc, /mnt, /media, …因为Linux内核有一个特性就是通过使用缓冲/缓存来达到加速对磁盘上文件的访问的目的，而ramdisk是加载到内存并模拟成磁盘来使用的，所以Linux就会为内存中的“磁盘”再使用一层缓冲/缓存，但是我们的ramdisk本来就是内存，它只不过被当成硬盘来使用罢了，这就造成双缓冲/缓存了，而且不会起到提速效果，甚至影响了访问性能；CentOS 5系列以及之前版本的ramdisk文件为initrd-VERSION-RELEASE.img，就会出现上述所说到的问题；而为了解决一问题，CentOS 6/7系列版本就将其改为initramfs-VERSION-RELEASE.img，使用文件系统的方式就可以避免双缓冲/缓存了，我们可以说这是一种提速机制。需要注意的是，系统发行商为了适应于各个不同的硬件接口，因此将各个不同的硬件接口的驱动组装打包起来，例如在用户第一次使用光盘安装完系统之后，会动态探测当前主机上的硬件设备并调用与之对应的设备驱动再做成ramdisk文件的。所以，ramdisk文件并非必须的，如果只是为了将Linux安装于特定硬件平台上，就可以直接把对应的驱动编译进内核即可，而不需要去使用ramdisk文件了。⑤init管理用户空间服务进程init可以理解成是内核派来管理用户空间的使者。虽然CentOS 5、CentOS 6以及CentOS 7的init配置 文件各不相同，但总体的启动流程是不变的。这一步的流程是：/sbin/init –&gt; 根据init配置文件设置默认运行级别 –&gt; 运行系统初始化脚本/etc/rc.d/rc.sysinit，完成系统初始化 –&gt; 关闭或启动用户选定的默认运行级别所对应的服务 –&gt; 启动终端，打印登录提示符grub中默认指定init=/sbin/init程序，可以在grub.conf中kernel行自定义执行程序init=/bin/bash,此时可以绕过下面步骤直接进入bash界面。init启动的顺序，/sbin/init-&gt;/etc/init-&gt;/bin/init-&gt;/bin/sh,(1)根据init配置文件设置默认运行级别对于CentOS 5来说，初始化程序init是SysV init，其配置文件为：/etc/inittab；对于CentOS 6来说，初始化程序init是upstart，其配置文件为：/etc/inittab， /etc/init/*.conf，也就是upstart将配置文件拆分成多个，在/etc/init/目录下以conf结尾的都是upstart风格的配置文件，而/etc/inittab仅用于设置默认运行级别；对于CentOS 7来说，初始化程序init是systemd，其配置文件为：/usr/lib/system/systemd/*, /etc/systemd/system/*； 详情请见原文：https://www.cnblogs.com/FengGeBlog/p/10392191.htmlhttps://blog.csdn.net/qq_27754983/article/details/75212666 6、编写Nginx的systemd配置文件， 实现nginx进程开机启动1、判断UID是否大于等于500，如果为真就显示为普通用户，如果为假就显示为系统或管理用户2、显示用户id为奇数的用户。3、统计web服务访问日志中的ip访问量4、简述加密类型以及数据加密解密过程5、搭建私有CA并实现证书颁发 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[two]]></title>
    <url>%2F2018%2F08%2F28%2F%E9%A9%AC%E5%93%A5%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[linux 培训文档 uptime08:21:34 up 36 min, 2 users, load average: 0.00, 0.00, 0.00当前服务器时间： 08:21:34当前服务器运行时长 36 min当前用户数 2 users当前的负载均衡 load average 0.00, 0.00, 0.00，分别取1min,5min,15min的均值 分区两种分区方式：MBR，GPTMBR: Master Boot Record，1982年，使用32位表示扇区数，分区不超过2T如何分区：按柱面0磁道0扇区：512bytes 446bytes: boot loader 64bytes：分区表，其中每16bytes标识一个分区 2bytes: 55AA4个主分区；3主分区+1扩展(N个逻辑分区)dos代表MBR分区 管理分区列出块设备• lsblk创建分区使用：• fdisk 创建MBR分区• gdisk 创建GPT分区• parted 高级分区操作重新设置内存中的内核分区表版本也就是同步分区表• partprobe或者：ls /dev/sdb* , cat /proc/partitionsblkid /dev/sdb1 查看分区的文件格式和UUID,也可以不跟分区 同步分区表查看内核是否已经识别新的分区cat /proc/partationscentos6通知内核重新读取硬盘分区表新增分区用partx -a /dev/DEVICE kpartx -a /dev/DEVICE -f: force删除分区用partx -d –nr M-N /dev/DEVICECentOS 5，7: 使用partprobe partprobe [/dev/DEVICE] centos6: partx -a /dev/sda -a增加partx -d –nr 6 /dev/sda -d删除第6个分区 Linux不重启识别硬盘[root@centos6 ~]# echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host0/scan [root@centos6 ~]# echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host1/scan [root@centos6 ~]# echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host2/scan parted分区命令parted的操作都是实时生效的，小心使用用法：parted [选项]… [设备 [命令 [参数]…]…] parted /dev/sdb mklabel gpt|msdos parted /dev/sdb print parted /dev/sdb mkpart primary 1 200 （默认M） parted /dev/sdb rm 1 parted –l 列出分区信息 创建文件系统mkfs命令：(1) mkfs.FS_TYPE /dev/DEVICE ext4xfs btrfs vfat(2) mkfs -t FS_TYPE /dev/DEVICE-L ‘LABEL’ 设定卷标 创建ext文件系统mke2fs：ext系列文件系统专用管理工具-t {ext2|ext3|ext4} 指定文件系统类型-b {1024|2048|4096} 指定块大小-L ‘LABEL’ 设置卷标-j 相当于 -t ext3mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3-i # 为数据空间中每多少个字节创建一个inode；不应该小于block大小-N # 指定分区中创建多少个inode-I 一个inode记录占用的磁盘空间大小，128—4096-m # 默认5%,为管理人员预留空间占总空间的百分比-O FEATURE[,…] 启用指定特性-O ^FEATURE 关闭指定特性 文件系统标签指向设备的另一种方法与设备无关blkid：块设备属性信息查看 blkid [OPTION]… [DEVICE]-U UUID 根据指定的UUID来查找对应的设备-L LABEL 根据指定的LABEL来查找对应的设备e2label：管理ext系列文件系统的LABEL e2label DEVICE [LABEL]findfs ：查找分区findfs [options] LABEL= tune2fstune2fs：重新设定ext系列文件系统可调整参数的值 -l 查看指定文件系统超级块信息；super block -L ‘LABEL‘ 修改卷标 -m # 修预留给管理员的空间百分比 -j 将ext2升级为ext3 -O 文件系统属性启用或禁用, –O ^has_journal -o 调整文件系统的默认挂载选项，–o ^acl -U UUID 修改UUID号dumpe2fs： 块分组管理，32768块 -h：查看超级块信息，不显示分组信息tune2fs -l /dev/sdb1 查看ext文件系统的工具不支持xfs格式Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file 这里没有日志功能，如果有会有journal表示日志Reserved block count: 13107 保留块，默认5% Block count: 262144 Reserved block count: 13107 就用13107/262144 大约5% tune2fs -o has_journal /dev/sdb1 加入日志功能tune2fs -o ^acl /dev/sdb1 取消acl权限tune2fs -o +acl /dev/sdb1 加入acl权限 只查询UUID是哪一个分区 [root@centos7 ~]# blkid -U `sed -r-n &#39;s#^UUID=(.*) / .*#\1#p&#39; /etc/fstab` /dev/sda2 e2label -L /mnt/sdb1 /dev/sdb1 加入卷标:/mnt/sdb1,查看卷标：blkid,e2label 用mount命令挂载文件系统 挂载方法：mount DEVICE MOUNT_POINTmount：通过查看/etc/mtab文件显示当前已挂载的所有设备mount [-fnrsvw] [-t vfstype] [-o options] device dir device：指明要挂载的设备； (1) 设备文件：例如/dev/sda5 (2) 卷标：-L ‘LABEL’, 例如 -L ‘MYDATA’ (3) UUID, -U ‘UUID’：例如 -U ‘0c50523c-43f1-45e7-85c0-a126711d406e’ (4) 伪文件系统名称：proc, sysfs, devtmpfs, configfs dir：挂载点 事先存在；建议使用空目录 进程正在使用中的设备无法被卸载补充：用UUID形式挂载目录mount -U UUID /mnt/sdb1查看某个目录是否有人使用：lsof /data 或者fuser -v /bootfuser -km /mnt/sdb1 此命令将把使用此目录的人全部杀掉，退出终端。 mount常用命令选项-t vsftype指定要挂载的设备上的文件系统类型-r readonly，只读挂载-w read and write, 读写挂载-n 不更新/etc/mtab，mount不可见。可查看这个文件，看的非常全cat /proc/mounts-a 自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中，且挂载选项中有auto功能)-L ‘LABEL’以卷标指定挂载设备-U ‘UUID’以UUID指定要挂载的设备-B, –bind 绑定目录到另一个目录上mount /boot /mnt/boot --bind 目录挂目录查看内核追踪到的已挂载的所有设备 cat /proc/mounts -o options：(挂载文件系统的选项)，多个选项使用逗号分隔 async 异步模式sync 同步模式,内存更改时，同时写磁盘atime/noatime 包含目录和文件diratime/nodiratime 目录的访问时间戳auto/noauto 是否支持自动挂载,是否支持-a选项exec/noexec 是否支持将文件系统上运行应用程序mount -o noexec /dev/sdb1 /mnt/sdb1 此时可执行权限不可执行mount -o remount,exec /mnt/sdb1 恢复执行mount -o remount,acl /mnt/sdb1 加入acl权限dev/nodev 是否支持在此文件系统上使用设备文件suid/nosuid 是否支持suid和sgid权限remount 重新挂载ro只读 rw读写user/nouser 是否允许普通用户挂载此设备，/etc/fstab使用acl 启用此文件系统上的acl功能loop 使用loop设备用文件作为 文件系统 然后可以实现挂载 centos6要加mount -o -loop /data/ext4file /mnt/ext4 centos 6上面默认只有lop0-lop7,需要更多的就必须修改内核参数：在kernel 这行加上max_loop=100defaults：相当于rw, suid, dev, exec, auto, nouser, async 卸载命令查看挂载情况， findmnt MOUNT_POINT|devicefindmnt /mnt 查看文件夹是否为挂载点查看正在访问指定文件系统的进程 lsof MOUNT_POINT fuser -km MOUNT_POINT终止所有在正访问指定的文件系统的进程卸载 umount DEVICE umount MOUNT_POINT 挂载点和/etc/fstab配置文件系统体系被mount、fsck和其它程序使用系统重启时保留文件系统体系可以在设备栏使用文件系统卷标使用mount -a 命令挂载/etc/fstab中的所有文件系统cat /var/log/boot.log 查看内核启动日志 swapswap分区改完相对应的文件系统83以后，mkswap /dev/sdd1然后加到/etc/fstabswapon -s查看当前生效的swap设备swapon -a 让swap设备生效 最后一个表示优先级，数值越大优先级越高，可在/etc/fatab 修改优先级default 这个位置，替换掉pri=10swapoff /dev/sdb4 禁用后启用swapon -a 才生效: 自动启动所有SWAP装置 用文件来当做swap分区dd if=/dev/zero of=/swapfile bs=2G count=1mkswap /swapfileblkid /swapfileswapon -s :-s | –summary 按设备显示交换用途摘要，等价于cat /proc/swaps 如果要移动这个swap文件,要先禁用swapoff /swapfile查看swapon -s移动：mv /swapfile /data/swapon -p 5 /data/swapfile 设置优先级要先禁用swapoff 将文件制作成iso文件，注意iso文件是只读的。mkisofs -r -o /data/etc.iso /etc/ 交换分区是系统RAM的补充基本设置包括 创建交换分区或者文件 使用mkswap写入特殊签名 在/etc/fstab文件中添加适当的条目 使用swapon -a 激活交换空间挂载交换分区 启用：swapon swapon [OPTION]… [DEVICE] -a：激活所有的交换分区 -p PRIORITY：指定优先级 /etc/fstab:pri=value 禁用：swapoff [OPTION]… [DEVICE] 文件系统空间占用等信息的查看工具：df [OPTION]… [FILE]… -H 以1000为单位 -T 文件系统类型 -h: human-readable -i：inodes instead of blocks -P: 以Posix兼容的格式输出查看某目录总体空间占用状态: du [OPTION]… DIR -h: human-readable -s: summary –max-depth 工具dd dd命令：convert and copy a file用法：dd if=/PATH/FROM/SRC of=/PATH/TO/DESTbs=#：block size, 复制单元大小count=#：复制多少个bsof=file 写到所命名的文件而不是到标准输出if=file 从所命名文件读取而不是从标准输入bs=size 指定块大小（既是是ibs也是obs)ibs=size 一次读size个byteobs=size 一次写size个bytecbs=size 一次转化size个byteskip=blocks 从开头忽略blocks个ibs大小的块 seek=blocks 从开头忽略blocks个obs大小的块count=n 只拷贝n个记录 工具ddconv=conversion[,conversion…] 用指定的参数转换文件转换参数:ascii 转换 EBCDIC 为 ASCIIebcdic 转换 ASCII 为 EBCDIClcase 把大写字符转换为小写字符ucase 把小写字符转换为大写字符dd if=/etc/fstab conv=ucasenocreat 不创建输出文件noerror 出错时不停止notrunc 不截短输出文件sync 把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐Fdatasync 写完成前，物理写入输出文件 skip=3 跳过原文件的前三个读2个seek=跳过f1四个 [root@centos7 text]# cat f1;cat f2 abcefghi 123456 [root@centos7 text]# dd if=f2 of=f1 bs=1 count=2 skip=3 seek=4 2+0 records in 2+0 records out 2 bytes (2 B) copied, 0.000231085 s, 8.7 kB/s [root@centos7 text]# cat f1 abce45[root@centos7 text]# [root@centos7 text]# cat f1;cat f2 abcefghi 123456 [root@centos7 text]# dd if=f2 of=f1 bs=1 count=2 skip=3 seek=4 conv=notrunc 2+0 records in 2+0 records out 2 bytes (2 B) copied, 0.000266614 s, 7.5 kB/s [root@centos7 text]# cat f1 abce45hi [root@centos7 text]# 工具dd备份MBRdd if=/dev/sda of=/tmp/mbr.bak bs=512 count=1破坏MBR中的bootloaderdd if=/dev/zero of=/dev/sda bs=64 count=1 seek=446有一个大与2K的二进制文件fileA。现在想从第64个字节位置开始读取，需要读取的大小是128Byts。又有fileB, 想把上面读取到的128Bytes写到第32个字节开始的位置，替换128Bytes，实现如下dd if=fileA of=fileB bs=1 count=128 skip=63 seek=31 conv=notrunc 备份：dd if=/dev/sdx of=/dev/sdy将本地的/dev/sdx整盘备份到/dev/sdydd if=/dev/sdx of=/path/to/image将/dev/sdx全盘数据备份到指定路径的image文件dd if=/dev/sdx | gzip &gt;/path/to/image.gz 备份/dev/sdx全盘数据，并利用gzip压缩，保存到指定路径 恢复：dd if=/path/to/image of=/dev/sdx将备份文件恢复到指定盘gzip -dc /path/to/image.gz | dd of=/dev/sdx将压缩的备份文件恢复到指定盘 拷贝内存资料到硬盘 dd if=/dev/mem of=/root/mem.bin bs=1024 将内存里的数据拷贝到root目录下的mem.bin文件 从光盘拷贝iso镜像 dd if=/dev/cdrom of=/root/cd.iso 拷贝光盘数据到root文件夹下，并保存为cd.iso文件 销毁磁盘数据 dd if=/dev/urandom of=/dev/sda1 利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据，执行此操作以后，/dev/sda1将无法挂载，创建和拷贝操作无法执行 破坏分区dd if=/dev/zero of=/dev/sdc bs=1 count=512 lsblk同步partx -d --nr 1-2 /dev/sdb 删除/dev/sdb 1和2分区 raid比如四个硬盘做raid5每个1G容量，可用的最后只有2G 2/3的利用率就是2G怎样做一个软raidmdadm -C -a yes /dev/md0 -l 0 -n 2 /dev/sd{b,c}1分区要进行更改类型为fd-C –create 创建阵列；-a –auto 同意创建设备，如不加此参数时必须先使用mknod 命令来创建一个RAID设备，不过推荐使用-a yes参数一次性创建；-l 阵列模式,raid级别-n 阵列中活动磁盘的数目，该数目加上备用磁盘的数目应该等于阵列中总的磁盘数目；查看raid0 状态 cat /proc/mdstat mdadm -D /dev/md0 创建文件系统mkfs.ext4 /dev/md0挂载使用mdadm -C -a yes /dev/md1 -l 5 -n 3 -x 1 -c=/dev/sd{b2,c2,d1,e1}-x 备用,指定阵列中热备盘个数，写在最后一个为备用盘-c:指定条带大小。单位KB，默认值512KB清除raid信息umount /dev/md0mdadm –zero-superblock /dev/sdc1mdadm –zero-superblock /dev/sdb1blkid 查看破坏分区dd if=/dev/zero of=/dev/sdc bs=1 count=512使其同步partx -d --nr 1-2 /dev/sdc lvmLVM基本介绍LVM：Logical Volume Manager,逻辑卷管理，是Linux下对磁盘分区进行管理的一种机制传统硬盘管理机制：1. 文件系统是基于分区的 2. 不同分区之间相对独立无法互联 3. 空间难以平衡利用，且当一个分区/文件系统已满时无法扩充，只能重分区/重建文件系统，若涉及到数据，则只能备份——&gt; 重分区/重建文件系统——&gt; 恢复数据LVM(逻辑卷管理) 1. 硬盘的多个分区由LVM统一管理 2. 可以方便的扩大和减小（ Attention ），充分利用磁盘空间 3. 文件系统建立在逻辑卷上，而逻辑卷可以根据需求随时改变大小这是LVM最值钱/最帅的功能 4. 在大型企业中，使用LVM可以在不停止服务的情况下，实现把用户数据从个旧硬盘转移到新硬盘中: 实际生产环境中，减小磁盘容量的操作十分危险，很容易危及已存在的数据，比起数据的价值，磁盘的价值简直如同草芥,所以几乎不会执行减小操作 PV、VG、LV关系详解PV(Physical Volume): 物理卷设备，基于Block Device（磁盘块设备）创建VG(Volume Group)：卷组，基于已存在的PV（物理卷设备）创建LV（Logical Volume):逻辑卷，基于已存在的VG（卷组）创建PE(Physical Extent)：物理区域，是物理卷中可用于分配的最小存储单元，可自定义，但确定之后不能更改 1. PV ：LVM系统中最底层的设备 基本管理命令：pvscan / pvs / pvdisplay / pvcreate / pvremovepvscan :在系统中搜索已存在的物理卷pvdisplay :物理卷全路径民称(pvdisplay /dev/sdc)，用于显示指定物理卷的属性信息（命令后面不加指定物理卷，默认显示所有物理卷）pvcreate :创建物理卷设备（参数位可以跟多个块设备路径，可同时创建多个PVpvcreate /dev/sd{b,a6})pvremvoe:删除物理卷 若此物理卷存在于卷组（PV）和逻辑卷（LV）中，需要先移除LV,再移除VG，最后移除PVpvremove /dev/sdb 创建分区作为逻辑卷时需要将他的ID改为8e 2. VG :卷组 基本管理命令：vgscan / vgs / vgdisplay / vgcreate / vgpremove / vgrename/vgscan,vgs:都是查看当前已存在的卷组vgdisplay:查看卷组信息（默认所有卷组信息）vgcreate:创建卷组vgcreate -s 8M vg0 /dev/sdb -s: 指定PE大小(只能是4或者4的倍数)vg0: 指定卷组名称。 后面是指定物理设备vgremove : 删除卷组 若此卷组存在于逻辑卷（LV）中，则需要先移除LV，再移除Vgvgremove vg0vgrename: 更改卷组名称 vgrname vg0 vgvv 3.LV :逻辑卷 基本管理命令: lvscan / lvs / lvdisplay / lvcreate / lvrename / lvremovelvscan,lvs:显示基本的逻辑卷信息lvdisplay:显示逻辑卷详细信息（默认所有逻辑卷，也可指定逻辑卷)lvcreate:创建逻辑卷（需指定大小-L，名称-n. 若不指定逻辑卷名称，则系统默认定义名称lvo10lvcreate -L 5G -n lv0 vg0lvrename:修改逻辑卷名称（需要提供完整路径，不能像VG修改一样只提供旧卷组名称和新卷组名称即可）lvrename /dev/testvg/testlv /dev/testvg/ttt 前面旧卷组路径 后面是新路径以及新名称lvremove:移除逻辑卷lvremove /dev/vg0/lv0 -y -y 代表默认yes，不加此选项则会提示”是否真的想要移除逻辑卷” 4.在逻辑卷上创建文件系统 当PV/VG/LV都创建完成之后，就可以在LV上创建文件系统，就可以挂载使用了，当然，这个创建的过程再赘述一下：这个过程可以理解为有三块豆腐，你想把这三块豆腐分成2块，传统的办法就是把一块切成两半，然后每一半分给余下的两块，LVM则是把三块豆拼成一大块豆腐，然后切成两半，比起之前的两块豆腐，显然更完整。格式化磁盘创建文件系统、挂载使用创建文件系统（格式化LVM）以ext4为例子:mkfs.ext4 /dev/vg0/lv0挂载文件系统: mount /dev/vg0/ 5.扩展整个系统的步骤概括如下：创建新PV——&gt;扩展VG——&gt;扩展LVPV涉及不到扩展或者缩小，因为是LVM系统中最小组成单位，所以只需要再创建即可VG扩展：vgextend(若原有的文件系统正在使用则需要先卸载，再执行扩展操作)vgexted vg0 /dev/sdc vg0是原有卷组;/dev/sdc是新添加的pvLV扩展:lvextend lvextend /dev/vg0/lv0 /dev/sdc 前面是扩展的目标逻辑卷，后面是新pv 6.快照 快照的概念：LVM中快照创建的时候，仅拷贝原始卷里数据的元数据；创建的时候，并不会有数据的物理拷贝，因此快照的创建几乎是瞬间完成的，当原始卷上有写操作执行时，快照跟踪原始卷块的改变，这个时候原始卷上将要改变的数据在改变之前被拷贝到快照预留的空间 lvcreate -L 200M -n kuaizhoa -s /dev/vg0/lv0-l 后面跟快照包含多少个PE的数量-L 后面跟快照的大小-n 快照名称-s 创建快照/dev/vg0/lv0 目标源LV-p r:只读权限命令最后记得加创建的快照的原始lv名称 现在的文件只要有变动就可以用快照恢复先卸载源:umount /lvm恢复快照功能:lvconvert --merge /dev/vg0/kuaizhao重新挂载源:mount /dev/vg0/lv0 /lvm此时/lvm目录下只有创建快照之前的文件。 LVM笔记来自51CTO博客作者奔跑小电驴的原创作品，https://blog.51cto.com/11742700/2082820 网咯七层模型applicationpersentionsessiontransportnetworkdata linkphysical集线器 物理层交换机 数据链路路由器 网络层 TCP/IPTCP/IP是一个协议栈:传输控制协议/因特网互联协议传输层：TCP可靠性 and UDP不可靠窗口大小：表示现在允许对方发送的数据量，也就是告诉对方，从本报文段的确认号开始允许对方发送的数据量，达到此值，需要ACK确认后才能再继续传送后面数据，由Window size value * Window size scaling factor（此值在三次握手阶段TCP选项Window scale协商得到）得出此值校验和：提供额外的可靠性紧急指针：标记紧急数据在数据字段中的位置选项部分：其最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，选项部分最长为：(2^4-1)*4-20=40字节常见选项：最大报文段长度：Maxium Segment Size，MSS，通常1460字节窗口扩大：Window Scale时间戳： Timestamps 端口号.TCP DNS:53 FTP:21 Telnet:23 Http:80 ssh:22 mysql-tcp:1521UDP DNS:53 TFTP:69 SNMP:161 QQ-UDP:8000 0-1023：系统端口或特权端口(仅管理员可用) ，众所周知，永久的分配给固定的系统应用使用。1024-49151：用户端口或注册端口，但要求并不严格，分配给程序注册为某应用使用。49152-65535：动态端口或私有端口，客户端程序随机使用的端口,其默认的端口范围的定义：/proc/sys/net/ipv4/ip_local_port_rangeLinux中记录应用程序的端口号文件:cat /etc/services客户端的端口是随机的 IP地址IP地址由两部分组成: 网络ID:标识网络 每个网段分配一个网络ID 主机ID:标识单个主机 由组织分配给各个设备 公式：一个网络中主机最大数=2^主机ID位数(32-网络ID位数)-2=2^(32-网络ID位数)-2网络数=2^可变网络ID位子网号(网络号)=ip地址与子网掩码相与得到子网数目:在默认掩码的基础上，网络位向主机位借的位数借了几位，就是2的几次方。有效IP地址:网络号+1——广播地址减1主机号:ip地址的二进制和子网掩码的二进制的反码(之前的0变成1,1变成0)进行与运算广播地址:在网络号的基础上，将主机号全部变为1 A1-126.X.Y.Z1600万网络ID位为高8位，主机ID位为24 可变网络位2^7=128-2=1260xxxxxxx.X.Y.Z00000000 001111111 127B128-191.x.y.z网络ID位为高16位，主机ID位为16 可变网络位2^1410xxxxxx.X.Y.Z10000000. 12810111111. 19165534C192-223.x.y.z网络ID位为高24位，主机ID位为8110xxxxx.x.y.z11000000 19211011111 223254 无类域间路由CIDR:网络id位数不确定254 252 248 242 224 192 128netmask子网掩码: 32bit 二进制,对应于网络ID位为1，对应于主机ID位为0255.255.224.0 主机数：2^13-2 网络ID相同就是在同一个网络, 网络ID就是IP地址和本地的子网掩码进行与计算得到的值，是与本机的子网掩码进行的与运算，因为查看与本机的网络是否相同。重点记住与本机的掩码进行的与运算。有坑 CIDR表示法: IP/网络ID位数 10.0.0.100/19 255.255.224.0 有19个1 题目： 203.110.200.199/22 1 主机数?1022 2^(32-22)-2 2 netmask?255.255.252.0 3 网络ID值? 11111111 11111111 11111100 00000000 /22二进制表示255.255.252.0 网络ID值203.110.200.199:二进制。网络ID为前22位，主机ID位后10位 11001011 01101110 110010 00 11000111 203.110.200.199 11111111 11111111 111111 00 00000000 255.255.252.0 11001011 01101110 110010 00 00000000 203.110.200.0/22 网络ID具体值=IP 与运算 子网掩码192.168.34.6255.255.255.0192.168.34.0/24 题目：求 100.123.199.124/20主机数：01100100 01010011 1100 0111 01111100 ip二进制11111111 11111111 1111 0000 00000000 /202^12-2=4096-2=4064子网掩码：255.255.240.0网络ID：100.123.192.0/20 1100 0111 1111 000001100100 10000100 1100 0000 00000000100.123.192.0/20最小和最大IP：100.123.192.1 ➜ 100.123.207.254通过网络ID 100.123.192.0/20,又前20位为网络位，所以只能是后面的从小到大100.123.1100 0000.00000001 ➜ 100.123.192.1100.123.1100 1111.11111110 ➜ 100.123.207.254 划分子网一个子网划分成多少个小网。网络ID位变多，主机ID位才变少，网络ID向主机ID借位。分成2^N个小子网10.0.0.1–10.255.255.254划分两个子网10.00 000000.0.0 10.00 000000.0.0 10.0.0.0/1010.01 000000.0.0 10.64.0.0/1010.10 000000.0.0 10.128.0.0/1010.11 000000.0.0 10.192.0.0/10 题目:10.0.0.0/8 给32省份划分各自子网1.子网子网掩码 255.248.0.02.最小子网，最大子网的网络ID3.每个子网主机数？2^19-24.第20个子网分给河南使用，最小ip，最大IP范围? 10.152.0.1 ➜ 10.159.255.254 1. 根据公式2^n=子网数 2^n=32 也就是借5位 8+5=13 网络位是13掩码: 255.11111000.0.0 ➜ 255.248.0.02. 10.00000 000.0.0 10.0.0.0/13 10.11111 000.0.0 10.248.0.0/133. 主机数: 2^(32-13)-2=4. 0表示第一个子网，那么19就表示第20个子网也就是”10011”(这里加起来是19)10.10011 000.0.1 ➜ 10.152.0.110.10011 111.255.254 ➜ 10.159.255.254 题目:河南省10.152.0.0/13 给15个市，划分各自子网1. 子网子网掩码：2^n&gt;=15 n&gt;=4 13+4=17位11111111.11111111.1 0000000.00000000255.255.128.02. 最小子网，最大子网的网络ID:原：10.10011 000.0.0 10.152.0.0/13现：10.10011 000.0 .0 借了4位 10.10011 000.00000000.0 ➜ 10.152.0.0/17 10.10011 111.10000000.0 ➜ 10.159.128.0/173. 每个子网主机数？2^(32-17)-24. 最大子网的最小IP,最大IP范围10.10011 111.10000000.0 最大子网10.10011 111.1 0000000.1 ➜ 10.159.128.110.10011 111.1 1111111.254 ➜ 10.159.255.254 合并超网多个小网合并成一个大网，主机ID向网络ID借位220.78.10101 000.0220.78.10101 001.0220.78.10101 111.0这几个IP前面都一样直接写 220.78.168.0/21route -n 查看路由表 路由表: 目标网络ID:目标网络所在网络ID 接口:本设备要发送数据包到目标，从哪个接口发送出来，才能到达 网关:到达目标网络，需要将数据交给下一个路口哪个接口的对应IP路由的分类优先级排列： 主机路由 网络路由 默认路由优先级:精度越高，优先级越高. DNS解析优先级： vim /etc/nsswitch.conf 网络基本配置CentOS 6网卡名称接口命名方式：CentOS 6 以太网：eth[0,1,2,…] ppp：ppp[0,1,2,…] 网络接口识别并命名相关的udev配置文件：/etc/udev/rules.d/70-persistent-net.rules 查看网卡：dmesg |grep –i ethethtool -i eth0 卸载网卡驱动：modprobe -r e1000 rmmod e1000 装载网卡驱动：modprobe e1000 route命令 路由管理命令 查看：route -n 添加：route addroute add [-net|-host] target [netmask Nm] [gw Gw] [[dev] If] 目标：192.168.1.3 网关：172.16.0.1route add -host 192.168.1.3 gw 172.16.0.1 dev eth0 目标：192.168.0.0 网关：172.16.0.1route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 dev eth0route add -net 192.168.0.0/24 gw 172.16.0.1 dev eth0 route命令 默认路由，网关：172.16.0.1route add -net 0.0.0.0 netmask 0.0.0.0 gw 172.16.0.1route add default gw 172.16.0.1 删除：route delroute del [-net|-host] target [gw Gw] [netmask Nm] [[dev] If] 目标：192.168.1.3 网关：172.16.0.1route del -host 192.168.1.3 目标：192.168.0.0 网关：172.16.0.1route del -net 192.168.0.0 netmask 255.255.255.0 netstat -ntau | sed -nr &#39;/^tcp/s/.* ([^ ]+) ?/\1/p&#39; | sort | unip -c ip设置网卡状态ip link set eth1 downip link set eth1 upip addr add 1.1.1.1/24 dev ens37ip addr del 1.1.1.1/24 dev ens37ip addr flush dev eth1 清空地址 ip route - routing table management添加路由：ip route addip route add TARGET via GW dev IFACE src SOURCE_IP TARGET:主机路由：IP网络路由：NETWORK/MASKip route add 192.168.0.0/24 via 172.16.0.1 ip route add 192.168.1.13 via 172.16.0.1添 加 网 关 ：ip route add default via GW dev IFACE ip route add default via 172.16.0.1删除路由：ip route del TARGET 显示路由：ip route show|list清空路由表：ip route flush [dev IFACE] [via PREFIX]ip route flush dev eth0 网络配置文件 /etc/sysconfig/network-scripts/route-IFACE• 注意：需service network restart生效• 两种风格：(1) TARGET via GW如 ：10.0.0.0/8 via 172.16.0.1(2) 每三行定义一条路由 ADDRESS#=TARGET NETMASK#=mask GATEWAY#=GW 创建bonding设备的配置文件/etc/sysconfig/network-scripts/ifcfg-bond0 DEVICE=bond0BOOTPROTO=noneBONDING_OPTS=”mode=1,miimon=100” 工作模式为1，后面指两个机子之间间隔100毫秒进行通讯 /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=noneMASTER=bond0SLAVE=yes 查看bond0状态：/proc/net/bonding/bond0 进程优先级进程优先级：系统优先级：数字越小，优先级越高0-139（CentOS4,5）各有140个运行队列和过期队列0-98，99（CentOS6）实时优先级: 99-0 值最大优先级最高nice值：-20到19，对应系统优先级100-139或99 Big O：时间复杂度，用时和规模的关系O(1), O(logn), O(n)线性, O(n^2)抛物线, O(2^n) 进程状态 Linux内核：抢占式多任务 进程类型：守护进程: daemon,在系统引导过程中启动的进程，和终端无关进程前台进程：跟终端相关，通过终端启动的进程注意：两者可相互转化 进程状态：运行态：running就绪态：ready睡眠态：可中断：interruptable不可中断：uninterruptable停止态：stopped,暂停于内存，但不会被调度，除非手动启动僵死态：zombie，结束进程，父进程结束前，子进程不关闭 系统管理工具进程的分类：CPU-Bound：CPU密集型，非交互IO-Bound：IO密集型，交互 Linux系统状态的查看及管理工具：pstree, ps, pidof, pgrep, top, htop, glance, pmap, vmstat, dstat, kill, pkill, job, bg,fg, nohup pstree命令：显示树状的进程关系 里面花括号代表的是线程 pstree -p 以树状图显示进程，还显示进程PID。pstree display a tree of processes ps: process stateps report a snapshot of the current processesps能看到当前进程的状态快照Linux系统各进程的相关信息均保存在/proc/PID目录下的各文件中 ps查看进程进程ps [OPTION]…支持三种选项：UNIX选项 如-A -eBSD选项 如aGNU选项 如–help• 选项：默认显示当前终端中的进程• a 选项包括所有终端中的进程• x 选项包括不链接终端的进程• u 选项显示进程所有者的信息• f 选项显示进程树,相当于 –forest• k|–sort 属性 对属性排序,属性前加- 表示倒序• o 属性… 选项显示定制的信息ps axo pid,%cpu,%mem,cmd 显示选定的选项• L 显示支持的属性列表 ps常见选项-C cmdlist 指定命令，多个命令用，分隔-L 显示线程-e: 显示所有进程，相当于-A-f: 显示完整格式程序信息-F: 显示更完整格式的进程信息-H: 以进程层级格式显示进程相关信息-u userlist 指定有效的用户ID或名称-U userlist 指定真正的用户ID或名称-g gid或groupname 指定有效的gid或组名称-G gid或groupname 指定真正的gid或组名称-p pid 显示指pid的进程–ppid pid 显示属于pid的子进程-M 显示SELinux信息，相当于Z ps输出属性VSZ: Virtual memory SiZe，虚拟内存集，线性内存RSS: ReSident Size, 常驻内存集STAT：进程状态S: interruptable sleeping 可中断休眠D: uninterruptable sleepingT: stoppedZ: zombie+: 前台进程l: 多线程进程L：内存分页并带锁N：低优先级进程 &lt;: 高优先级进程s: session leader，会话（子进程）发起者 ps ni: nice值 pri: priority 优先级 psr: processor CPU编号 rtprio: 实时优先级示例：ps axo pid,cmd,psr,ni,pri,rtprio 常用组合：aux-ef-eFH-eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,commaxo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm 例子:查询你拥有的所有进程 ps -x显示指定用户名(RUID)或用户ID的进程 ps -fU apacheps -fU 48显示指定用户名(EUID)或用户ID的进程 ps -fu wangps -fu 1000查看以root用户权限（实际和有效ID）运行的每个进程 ps -U root -u root列出某个组拥有的所有进程（实际组ID：RGID或名称） ps -fG nginx 列出有效组名称（或会话）所拥有的所有进程 ps -fg mysqlps -fg 27显示指定的进程ID对应的进程ps -fp 1234以父进程ID来显示其下所有的进程，如显示父进程为1234的所有进程 ps -f –ppid 1234显示指定PID的多个进程ps -fp 1204,1239,1263要按tty显示所属进程 ps -ft pts/0 以进程树显示系统中的进程如何相互链接 ps -e –forest以进程树显示指定的进程ps -f –forest -C sshdps -ef –forest | grep -v grep | grep sshd要显示一个进程的所有线程,将显示LWP（轻量级进程）以及NLWP（轻量级进程数）列ps -fL -C nginx要列出所有格式说明符ps L查看进程的PID，PPID，用户名和命令 ps -eo pid,ppid,user,cmd 自定义格式显示文件系统组,ni值开始时间和进程的时间 ps -p 1234 -o pid,ppid,fgroup,ni,lstart,etime使用其PID查找进程名称：ps -p 1244 -o comm=要以其名称选择特定进程，显示其所有子进程 ps -C sshd,bash查找指定进程名所有的所属PID，在编写需要从std输出或文件读取PID的脚本时这个参数很有用ps -C httpd,sshd -o pid=检查一个进程的执行时间ps -eo comm,etime,user | grep nginx 查找占用最多内存和CPU的进程ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%mem | head ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%cpu | head显示安全信息 ps -eMps –context使用以下命令以用户定义的格式显示安全信息 ps -eo euser,ruser,suser,fuser,f,comm,label使用watch实用程序执行重复的输出以实现对就程进行实时的监视，如下面的命令显示每秒钟的监视watch -n 1 ‘ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%mem | head’ 进程优先级进程优先级调整静态优先级：100-139进程默认启动时的nice值为0，优先级为120只有根用户才能降低nice值（提高优先性）nice命令nice [OPTION] [COMMAND [ARG]…]renice命令renice [-n] priority pid…查看ps axo pid,comm,ni 搜索进程最灵活：ps 选项 | 其它命令按预定义的模式：pgrep pgrep [options] pattern-u uid: effective user，生效者-U uid: real user，真正发起运行命令者-t terminal: 与指定终端相关的进程 搜索终端运行的相关进程 pgrep -t pts/0-l: 显示进程名-a: 显示完整格式的进程名-P pid: 显示指定进程的子进程 pgrep -P 5297按确切的程序名称：/sbin/pidofpidof bash 查询某个进程对应的进程编号 uptime显示当前时间，系统已启动的时间、当前上线人数，系统平均负载（1、5、10分钟的平均负载，一般不会超过1）系统平均负载:指在特定时间间隔内运行队列中的平均进程数通常每个CPU内核的当前活动进程数不大于3，那么系统的性能良好。如果每个CPU内核的任务数大于5，那么此主机的性能有严重问题如果linux主机是1个双核CPU，当Load Average 为6的时候说明机器已经被充分使用 top：有许多内置命令排序：P：以占据的CPU百分比,%CPUM：占据内存百分比,%MEMT：累积占据CPU时长,TIME+首部信息显示：uptime信息：l命令tasks及cpu信息：t命令cpu分别显示：1 (数字)memory信息：m命令退出命令：q修改刷新时间间隔：s终止指定进程：k保存文件:W栏位信息简介us：用户空间sy：内核空间ni：调整nice时间id：空闲wa：等待IO时间hi：硬中断si：软中断（模式切换）st：虚拟机偷走的时间 内存工具内存工具vmstat命令：虚拟内存信息vmstat [options] [delay [count]]vmstat 2 5procs:r：可运行（正运行或等待运行）进程的个数，和核心数有关b：处于不可中断睡眠态的进程个数(被阻塞的队列的长度)memory：swpd: 交换内存的使用总量free：空闲物理内存总量buffer：用于buffer的内存总量cache：用于cache的内存总量swap:si：从磁盘交换进内存的数据速率(kb/s)so：从内存交换至磁盘的数据速率(kb/s)io：bi：从块设备读入数据到系统的速率(kb/s)bo: 保存数据至块设备的速率 iostat:统计CPU和设备IO信息示例：iostat 1 10 每秒显示一次，显示10次pmap命令：进程对应的内存映射pmap [options] pid […]-x: 显示详细格式的信息示例：pmap 1另外一种实现cat /proc/PID/maps dstat 系统资源统计,代替vmstat,iostat-g 显示page相关统计数据-m 显示memory相关统计数据-n 显示network相关统计数据-p 显示process相关统计数据-r 显示io请求相关的统计数据-c 显示cpu相关信息-s 显示swapped相关的统计数据–top-cpu：显示最占用CPU的进程–top-io: 显示最占用io的进程–top-mem: 显示最占用内存的进程–top-latency: 显示延迟最大的进程 kill命令向进程发送控制信号，以实现对进程管理,每个信号对应一个数字，信号名称以SIG开头（可省略），不区分大小写显示当前系统可用信号： kill –l 或者 trap -l常用信号：man 7 signal1)SIGHUP 无须关闭进程而让其重读配置文件2) SIGINT 中止正在运行的进程；相当于Ctrl+c3) SIGQUIT 相当于ctrl+\9) SIGKILL 强制杀死正在运行的进程15) SIGTERM 终止正在运行的进程18) SIGCONT 继续运行19) SIGSTOP 后台休眠 指定信号的方法 : (1) 信号的数字标识：1, 2, 9 (2)信号完整名称：SIGHUP (3)信号的简写名称：HUP [root@centos7 ~]# pidof httpd pidof 查看应用程序的进程编号20108 20107 20106 20105 20104 19310 理论上应该是最小的进程标号kill -1 19310 无须关闭进程而让其重读配置文件kill 进程编号 杀死进程kill -n pid -n可加可不加kill -n 15 93808kill -0 1 -0表示进程的错误检查，然后查看返回值echo $?按名称：killall httpd killall后面跟程序名称按模式: pkill [选项] command-u uid: effective user，生效者-U uid: real user，真正发起运行命令者-t terminal: 与指定终端相关的进程-l: 显示进程名（pgrep可用）-a: 显示完整格式的进程名（pgrep可用）-P pid: 显示指定进程的子进程 ss -ntl 查看启动的服务端口 linux 作业控制ping 127.0.0.1ctrl z 调到后台停止jobs 查看当前终端所有作业bg 1 将指定进程号的程序放到后端执行fg 1 调到前台来运行后端运行到后端停止 killall -19 ping后端停止到后端运行 killall -18 pingping 127.0.0.1 &amp; 直接调到后台运行 后台作业虽然被送往后台运行，但其依然与终端相关；退出终端，将关闭后台作业。如果希望送往后台后，剥离与终端的关系nohup COMMAND &amp;&gt;/dev/null 因为nohup会默认有一个命令输出记录，所以不想看就指定路径为垃圾箱screen；COMMAND 相当于在screen这个容器里面运行，即使终端断开也不会停止。screen -ls 查看 同时运行[root@centos7 ~]# cat a.sh ping 127.0.0.1 &amp; ping 127.0.0.2 &amp; ping 127.0.0.3 &amp; { ping 127.0.0.1 &amp; ping 127.0.0.2 &amp; ping 127.0.0.3 &amp;}(ping 127.1&amp;);(ping 127.2&amp;);(ping 127.3&amp;) 两组命令同时执行{ { ping -c3 127.1;ping 127.2; }&amp; { ping -c3 127.3;ping 127.4; }&amp; }; { ping -c2 127.0.0.1 ping 127.0.0.2 }&amp; { ping -c2 127.0.0.3 ping 127.0.0.4 }&amp; 任务计划at指定时间点，执行一次性任务at命令:at [option] TIME -V 显示版本信息 -t time 时间格式 [[CC]YY]MMDDhhmm[.ss] -l 列出指定队列中等待运行的作业；相当于atq -d 删除指定的作业；相当于atrm -c 查看具体作业任务 at -c 加作业序号-f /path/file 指定的文件中读取任务 -m 当任务被完成之后，将给用户发送邮件，即使没有标准输出 注意：作业执行命令的结果中的标准输出和错误以邮件通知给相关用户 [root@centos7 \~]# at 18:00 2018-10-31 at&gt; poweroff ctrl d 结束 任务存放的路径: cat /var/spool/at/ 计划任务不要有标准输出，因为他不会在屏幕显示echo -e &#39;poweroff\ntouch /data/at.log&#39; | at 18:00 也支持这种格式echo &#39;poweroff;ntouch /data/at.log&#39; | at 18:00 at 定义时间格式at now+10minutes 表示现在的10分钟以后执行touch /testctrl d 结束HH:MM 02:00 在今日的 HH:MM 进行，若该时刻已过，则明天此时执行任务HH:MM YYYY-MM-DD 02:00 2016-09-20 规定在某年某月的某一天的特殊时刻进行该项任务HH:MM[am|pm] [Month] [Date]04pm March 1717:20 tomorrowHH:MM[am|pm] + number [minutes|hours|days|weeks]在某个时间点再加几个时间后才进行该项任务 now + 5 min02pm + 3 days 执行方式1.交互式 2.输入重定向 3.at –f 文件 at队列存放在/var/spool/at目录中/etc/at.{allow,deny}控制用户是否能执行at任务 白名单：/etc/at.allow 默认不存在，只有该文件中的用户才能执行at命令 黑名单：/etc/at.deny 默认存在，拒绝该文件中用户执行at命令，而没有在 at.deny 文件中的使用者则可执行 当一个用户去指定计划任务，系统会先看有没有白名单文件，如果白名单文件中有这个用户就可以执行。如果有白名单文件但是里面没有这个用户，那么这个用户也不能创建查看计划任务。如果没有这个白名单文件就继续看黑名单文件，有用户就会被拒绝,没有则允许创建。如果两个文件都不存在，则只有root可以执行at命令 cron周期性任务计划相关的程序包： cronie：主程序包，提供crond守护进程及相关辅助工具 cronie-anacron：cronie的补充程序，用于监控cronie任务执行状况，如cronie中的任务在过去该运行的时间点未能正常运行，则anacron会随后启动一次此任务 crontabs：包含CentOS提供系统维护任务确保crond守护处于运行状态：CentOS 7: systemctl status crondCentOS 6: service crond status计划周期性执行的任务提交给crond，到指定时间会自动运行 系统cron任务：系统维护作业 /etc/crontab用户cron任务： crontab命令日志：/var/log/cron @yearly 0 0 1 1 * 每年 特定的字符@annually 0 0 1 1 * 每年@monthly 0 0 1 * * 每月@weekly 0 0 * * 0 每周@daily 0 0 * * * 每日@hourly 0 * * * * 每小时@reboot 重启后 *表示任何时候都匹配；可以用A,B,C表示A或者B或者C时执行命令可以用A-B表示A到B之间时执行命令可以用*/A表示每A分钟(小时等)执行一次命令.vim /etc/crontab 只给root账户使用（上图的路径是另外保存的文件）普通用户用vim crontab 因为他调用的vi所有没有颜色export EDITOR=vim 使他调用vim普通用户和root里面的格式一样，只不用写用户名。创建好后文件在/var/spool/cron每个用户都有专用的cron任务文件：/var/spool/cron/USERNAMEcrontab -e -u pan 指定以pan用户的计划身份去更改(谁创建的就指定谁去更改，只有创建者才能看到创建的内容) -l 列出所有任务 -e 编辑任务 -r 移除所有任务 -i同-r 一同使用，以交互式模式移除指定任务,询问-u user 仅root可运行，指定用户管理cron任务控制用户执行计划任务:/etc/cron.{allow,deny}没有被重定向的输出会被邮寄给用户root能够修改其它用户的作业 注意：运行结果的标准输出和错误以邮件通知给相关用户(1) COMMAND &gt; /dev/null(2) COMMAND &amp;&gt; /dev/null对于cron任务来讲，%有特殊用途；如果在命令中要使用%，则需要转义，将%放置于单引号中，则可不用转义 hljs.initHighlightingOnLoad();]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[blog 本博客从2018年7月左右开始搭建,博客所有搭建过程及修改均来自于互联网。本站使用基于 Node.js 的 Hexo 博客框架，托管于 Github和coding,由 腾讯云 提供 DNS 解析服务 me逝者如斯夫 不舍昼夜 19年毕业，专业是计算机网络。现在正在一边工作，一边学习linux。 爱好:网易云音乐，写博客，改博客，美剧，动漫，switch You交友 互助，朋友请留下邮箱]]></content>
  </entry>
</search>
