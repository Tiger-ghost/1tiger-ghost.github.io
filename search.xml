<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Look]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[我在这里，你在哪里 ！]]></content>
      <tags>
        <tag>look</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[资源分享]]></title>
    <url>%2F2018%2F08%2F28%2F%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[视频插入1&lt;video poster=&quot;https://封面图.jpg&quot; src=&quot;https://cdn-video.xinpianchang.com/5b91ee632bb35.mp4&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the video tag.&lt;/video&gt; 12345678背景图片&lt;style type=&quot;text/css&quot; &gt; body&#123;background-image:url(https://ws1.sinaimg.cn/large/005RRiqRly1fvi6xtxcpwj31hc0u0kjl.jpg);background-position:center; background-repeat:repeat-y；&#125;&lt;/style&gt; 1234567891011121314百分号前面的数字就是定位在第几个tab上&#123;% tabs 选项卡, 1 %&#125; &lt;!-- tab --&gt;**这是选项卡 1** * 列表* 列表&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 2** 内容balabala2&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 测试defaultprimarysuccesswarningdanger default primary success info warning danger]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2018%2F08%2F28%2Flinux%20command%2F</url>
    <content type="text"><![CDATA[个人学习Linux所做的笔记集合: 写在前面[root@pan ~]# root:登录的用户 @分隔符 pan主机名 ~当前路径\:newline echo $PATHctrl+r:在历史命令中搜索。 ctrl+s:暂停屏幕输出。 ctrl+q:恢复屏幕输出。&quot;&amp;&quot; &quot;||&quot; &quot;!&quot; catcat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！nl 显示的时候，顺道输出行号！ -A:查询所有的内容包括隐藏字符 ls-F:在每个输出项后追加文件的类型标识符，具体含义：“*“表示具有可执行权限的普通文件“/“表示目录 “@”表示符号链接“|”表示命令管道FIFO“=”表示sockets套接字当文件为普通文件时，不输出任何标识符 echo#echo [选项][输出内容] echo -e &quot;\e[1;31m abcd \e[0m&quot; 输出颜色=30m 黑色，=31m 红色，=32m 绿色，=33m 黄色，=34m 蓝色，=35m 洋红，=36m 青色，=37m 白色。&quot;echo -e ab\bc&quot; 控制字符在末尾可能不执行。-e:支持反斜线控制的字符转换 控制字符 作用 \ 输出\本身 \a 输出警告音 \b \退格键，也就是向左删除键 \c 取消输出行末的换行符，和“-n”选项一致 \e ESCAPE键 \f 换页符 \n 换行符 \r 回车键 \t 制表符，也就是Tab键 \v 垂直制表符 \0nm 按照八进制ASCII码输出字符，其中0为数字零，nnn是三位八进制数 \xhh 按照十六进制ASCII码表输出字符。其中hh是两位十六进制数。 I/o redirection输出重定向:命令 &gt; 文件 2&gt;&amp;1 :以覆盖的方式，把正确输出和错误输出都保存在一个文件当中。命令 &amp;&gt;文件 :以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。 &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。1&gt;&amp;2 意思是把标准输出重定向到标准错误.2&gt;&amp;1 意思是把标准错误输出重定向到标&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中 输入重定向：命令 &lt;文件wc [选项] [文件名]选项： -c :统计字节数 -w :统计单词数 -l :统计行数wc &lt; filename12345678wc &lt;&lt; filename wc &lt;&lt; hello 注意hello &gt; dshi &gt; jdiosjfh &gt; diosjfiojd &gt; fdiojsoifj &gt; hello 4 4 36 sortsort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，不加参数时依次按ASCII码值进行比较，最后将他们按升序输出 -n :依照数值的从小到大排序; -r :以相反的顺序来排序; -u :忽略相同行使用-u选项或者uniq 文件名 -t &lt;分隔符&gt;：指定排序时所用的栏位分隔字符； -k 是指定需要排序的栏位（字母按ASCII排序，数字按从小到大。先数字后字母） [root@mail text]# sort -nrk 3 -t: sort.txt 将CC列数字从大到小顺序排列：eee:40:5.4eee:60:5.1ddd:20:4.2ccc:50:3.3bbb:10:2.5aaa:30:1.6AAA:BB:CC 列 awk awk &#39;{print $1}&#39; 文件名 $1第一列，$2第二列，$NF最后一列.$(NF-1)倒数第二列）。 现在是以文件的空格为分隔符这样打印 awk-F&quot;:&quot;&#39;{print $1}&#39; /etc/passwd -f指定分隔符，并打印文件第一列 多列打印#awk -F &quot;:&quot; &#39;{print $2 $3}&#39; /etc/passwd 这样打印$2 $3之间是没有分隔符 要加分隔符就是 awk -F &quot;:&quot; &#39;{print $2&quot;分隔符符号&quot;$3}&#39; /etc/passwd $0表示整个文件 df文件系统查看命令 -a:显示所有的文件系统信息信息，包括特殊文件系统，如，/proc,/sysfs -h:使用习惯单位显示容量，如KB,MB或GB等。 -T:显示文件系统类型 -m: 以MB为单位显示容量。 -k:以KB为单位显示容量，默认就是以KB为单位显示容量。 du命令和df命令的区别df:命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间(最常见的就是文件已经删除，但是程序并没有释放空间) du: 命令是面向文件的，只会计算计算机文件或目录占用的空间. du是通过搜索文件来计算每个文件的大小然后累加，du能看到的文件只是一些当前存在的，没有被删除的。他计算的大小就是当前他认为存在的所有文件大小的累加和 -h : 以K，M，G为单位，提高信息的可读性。 -s : 统计总占用量，而不列出子目录和子文件的占用量。ls -h是目录下文件名占用大小 du -h 是目录下所有文件的大小 -k : 以KB(1024bytes)为单位输出。 -m : 以MB为单位输出。 -a显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量。 dddd(磁盘对拷命令)命令用于复制文件并对原文件的内容进行转换和格式化处理 [root@localhost]# dd if=输入文件 of=输出文件 bs=字节数 count=个数选项：if=输入文件 指定源文件或源设备of=输出文件 指定目标文件或目标设备bs=字节数 指定一次输入/输出多少字节，即把这些字节看做一个数据块count=个数 指定输入/输出多少个数据块 date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000(100M) ; data。 fsck文件系统修复命令fsck [选项] 分区设备文件名 -a:不显示用户提示，自动修复文件系统 -y:自动修复。和-a作用一致，不过有些文件系统只支持-y dumpe2fs显示磁盘状态命令 #dumpe2fs 分区设备名 rpmrpm是Linux标准基础（LSB）兼容发行版所使用的一种软件包管理器，用来对软件包进行低级处理rpm可以查询、安装、检验、升级和卸载软件包，它多数用于基于Fedora的系统，比如RHEL和CentOS 只有安装和升级要加包全名。 -ivh: -i:安装，-v:显示详细信息，-h:显示进度，–nodeps：不检测依赖性。 -Uvh包全名：RPM包升级. -q :接软件包名字 #查询软件是否已经安装 -q(查询query) -qa :#查询所有已经安装的RPM包。-a(所有all) -qi :包名字#查询软件包详细信息 -i :显示软件包的相关信息 -ql 包名:查询软件包安装位置 -l :显示套件的文件列表。 -qf +系统文件名。查看一个文件是由哪个包安装的 -qip 包全名:查询未安装软件包信息，必须在软件包目录进行查询。 -qR :查询软件包的依赖性。 -qRp :查询未安装软件包的依赖性必须在Packages目录查询。 -e 包名:卸载软件。rpm -qf `which 程序名` #返回软件包的全名 已安装的软件包rpm -qif `which 程序名` #返回软件包的有关信息rpm -qlf `which 程序名` #返回软件包的文件列表 RPM校验#rpm -V 已安装的包名选项：-V 校验指定RPM包中的文件。(verify) [root@Tiger ~]#rpm -V httpdS.5….T. c /etc/httpd/conf/httpd.conf验证内容中的8个信息的具体内容如下： S：文件大小是否改变； M：文件的类型或文件的权限(r w x)是否被改变； 5：文件MD5校验和是否改变(可以看成文件的内容是否改变)； D：设备的主，从设备号是否改变； L：文件路径是否改变； U：文件的属主(所有者)是否改变； G：文件的属组是否改变； T：文件的修改时间是否改变；文件类型： c :配置文件(config file) d :普通文档(documentation) g :”鬼”文件(ghost file),很少见，就是该文件不应该被这个RPM包包含 l :授权文件(license file) r :描述文件(read me) RPM包中文件提取#rpm2cpio 包全名 | \ cpio -idv .文件绝对路径 反斜杠：换行的作用。rpm2cpio:将rpm包转换为cpio格式的命令。cpio:是一个标准工具，他用于创建软件档案文件和从档案文件中提取文件。 #cpio 选项 &lt; [文件|设备]选项： -i:copy-in模式，还原 -d:还原时自动新建目录 -v：显示还原过程 rpm -qf /bin/ls 查询ls命令属于哪个软件包mv /bin/ls /tmp 造成ls命令误删除的假象rpm2cpio /mnt/Packages/coreutils-8.4-37.el6.x86_64.rpm | cpio -idv ./bin/ls提取RPM包中ls命令到当前目录的/bin/ls下 cp /root/bin/ls /bin 把ls命令复制到/bin目录，修复文件丢失。 源码包与RPM包的区别安装在指定位置当中，一般是/usr/local/软件名/。RPM包安装的服务可以使用系统服务管理命令(service)来管理，例如RPM包安装apache的启动方法是:/etc/rc.d/init.d/httpd start: 绝对路径启动服务。service httpd start源代码保存位置：/usr/local/src/软件安装位置：/usr/local/如何确定安装过程报错：安装过程停止；并出现error、warning或no的提示。源码包安装过程：下载源码包；解压缩下载的源码包；进入解压缩目录。 CRT中sftp里面要设置远程的路径和本地的路径:cd 1 进入远程连接到的Linux的1目录lcd \text 本地的c盘text目录get abc.c 从远程目录得到文件abc.c放入本地目录textput a11.txt 从Windows上将文件a11.txt传入linux 源码包配置./configure软件配置与检查 定义需要的功能选择。 检测系统环境是否符合安装需求。 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。./configure –prefix=/usr/local/apache2安装路径详情参考INSTALL 源码包的卸载：不需要卸载命令，直接删除安装目录即可，不会遗留任何垃圾文件。 脚本安装包：脚本安装包并不是独立的软件包类型，常见安装的是源码包。是人们把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。非常类似于Windows下软件的安装方式。 yum能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。remove :删除指定的rpm软件包； yum -y remove 软件包名yum update +包名 :升级。 禁用yum grouplist:列出所有可用的软件组列表；yum groupinstall 软件组名:安装指定的软件组，组名可以由goruplist查询出来；yum groupremove:卸载指定软件组； 配置yum仓库: [base] name=centos baseurl=file:///mnt/ enabled=1 gpgcheck=0 . headhead 用来显示档案的开头至标准输出中,默认head命令打印其相应文件的开头10行 -n:显示文件的前n行 head -n 5 a.txt 显示文件的前5行 -c显示文件前n个字节 &gt;head -c 20 a.txt head -c -32 log2014.log文件的除了最后n个字节以外的内容head -n -6 log2014.log 输出文件除了最后n行的全部内容 . tail主要用来从指定点开始将文件写到标准输出。很多人喜欢使用tail -f 来监控日志文件。 -f该参数用于监视文件的增长 tail -f filename监视filename文件的尾部内容（默认10行，相当于增加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。 -n从指定行位置读取指定文件。 tail -n 20 filename 显示filename最后20行 -c显示文件最后n个字节 tail -c 20 a.txt chmod chmod命令用来变更文件或目录的权限，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件 -f :若该文件权限无法被更改也不要显示错误讯息 -R :对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)r=读取属性 值＝4 w=写入属性 值＝2 x=执行属性 值＝1 chown改变某个文件或目录的所有者和所属的组chown USER:GROUP 对象chown USER 对象 chown :group 对象 systemctlsystemctl命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起 chkconfig1.服务概述:在linux操作系统下，经常需要创建一些服务，这些服务被做成shell脚本，这些服务需要在系统启动的时候自动启动，关闭的时候自动关闭。将需要自动启动的脚本/etc/rc.d/init.d目录下，然后用命令chkconfig –add filename将自动注册开机启动和关机关闭。实质就是在rc0.d-rc6.d目录下生成一些文件连接，这些链接连接到/etc/rc.d /init.d目录下指定文件的shell脚本。 --list :列出所有系统服务 --add httpd:增加httpd服务。 --del httpd:删除httpd服务。 --list mysqld:列出mysqld服务设置情况 --level 35 mysqld on:设定mysqld在等级3和5为开机运行服务，–level 35表示操作只在等级3和5执行，on表示启动，off表示关闭。 chkconfig mysqld on:设定mysqld在各等级为on，“各等级”包括2、3、4、5等级。 chkconfig 设置是当前不生效，linux重启后才生效.service 设置是即时生效，linux关机重启后设置失效. mount查询与自动挂载(Auto Mount) mount [-l] 查询系统中已经挂载的设备，-l会显示卷标名称mount -a 依据配置文件/etc/fstab的内容，自动挂载 挂载命令格式 mount [-t 文件系统] [-L卷标名] [-o特殊选项] 设备文件名 挂载点-t 文件系统:加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统 -L 卷标名:挂载指定卷标的分区，而不是安装设备文件名挂载 -o 特殊选项:可以指定挂载的额外选项。 mount -o remount,noexec /home这里的/home是df可以查看到的分区重新挂载/home分区，并使用noexec权限 #cd /home #vi hello.sh#!/bin/bashecho “i love you”#chmod 755 #./hello.sh 会显示没有权限执行 #mount -o remount,exec /home 记得改回来，要不然会影响系统启动的。 挂载光盘mkdir /mnt/cdrom 建立挂载点mount -t iso9660 /dev/cdrom /mnt/cdrom 挂载光盘mount /dev/sr0 /mnt/cdrom 卸载光盘#umount设备文件名或挂载点umount /mnt/cdrom 挂载U盘fat32格式:fdisk -l 查看U盘设备文件名mount -t vfat /dev/sdb1 /mnt/usb/注意：fat16分区识别为fat,fat32分区识别为vft。linux默认是不支持NTFS文件系统的. NTFS u盘支持下载NTFS-3G插件https://www.tuxera.com/community/open-source-ntfs-3g/ 解压 tar -zxvf filename 安装 ./configure &amp;&amp; make &amp;&amp; make installfdisk -l查看linux的U盘分区：sdc1mount -t ntfs-3g /dev/sdc1 /mnt/usb/mkfs -t ext4 /dev/sdb1/ 格式化分区,扩展分区不可格式mkdir /disk1 建立挂载点mount /dev/sdb1 /disk1 挂载 swap新增swap空间:free查看swap大小新增一个分区，改分区号82，保存退出格式化：mkswap /dev/sdb6 加入swap分区：swapon /dev/sdb6取消swap分区：swapoff /dev/sdb6 但是每次开机都要手动挂载一遍，可以写入fatab开机自动挂载vi /etc/fstab/dev/sdb6 swap swap defaults 0 0 free显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。 -b ：以Byte为单位显示内存使用情况； -k ：以KB为单位显示内存使用情况； -m ：以MB为单位显示内存使用情况； total:去掉为硬件和操作系统保留的内存后剩余的内存总量。许多人奇怪自己的电脑安装了一共8G的内存，但是显示总共只有七点几G的，现在应该没什么疑惑了把，不管Linux还是Windows都会有部分内存是保留给硬件和操作系统的！ userd：当前已使用的内存总量。 free：空闲的或可以使用的内存总量 shared：共享内存大小，主要用于进程间通信 buff(buffers):缓冲，主要用于块设备数据缓冲(磁盘缓存大小)，例如记录文件系统的metadata（目录、权限等等信息）。是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减小了磁盘碎片和硬盘反复寻道，加速了数据的写入过程。 cache:缓存，主要用于文件内容缓冲,是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程。 available:可以使用的内存总量. Compression 压缩 commandgzipgzip filename压缩 *.gz :”后缀名”gzip -d filename.gz gunzip filename.gz 解压缩不解压查看：zcat filename.gz bz2bzip2 filename压缩 *.bzip2:”后缀名”bzip2 -k filename 保存源文件压缩bzip2 -d filename.bz2 bunzip2 filename.bz2解压缩不解压查看：bcat filename.bz2 xzxz filename压缩 .xz:”后缀名”xz -d filename.xz 解压缩unxz -k filename.xz 保存源文件解压 zipzip默认保存源文件，可以压缩目录解压：unzip FileName.zip压缩：zip FileName.zip DirName -r ：递归处理，将指定目录下的所有文件和子目录一并处理； tar-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的 tar cf file.tar files 将一个或多个文件、目录打包到tar包。tar rf file.tar file 将文件file添加到tar包中。tar uf file.tar file 将文件file更新tar包中相应的文件。tar tf file.tar 查看tar内容。tar xf file.tar 解压tar包。 -z:有gzip属性,即需要用 gzip 压缩 -j:有bz2属性,即需要用 bzip2 压缩 -v:显示处理过程 -C:指定解压输出目录 tar zxvf test.tar.gz -C test-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 -Z：有compress属性的 -O：将文件解开到标准输出 格式：tar Zcf file.tar.Z files 将一个或多个文件、目录压缩到file.tar.Z中。需要安装了ncompress软件包才行。解压.tar.Z文件。格式：tar Zxf file.tar.Z 归档并压缩：使用时间格式打包数据：tar zcf etc-$(date +%F).tar.gz /etc tar zcf etc-`date +%F`.tar.gz /etc *.tar.gz归档并调用gzip压缩 tar -zcf 新文件名.tar.gz /etc/passwd /var/log/messagages调用gzip解压缩并展开归档 tar -zxvf filename.tar.gz *.tar.bz2归档并调用bzip2压缩 tar -jcf 新文件名.tar.bz2 /etc/passwd /var/log/messages调用bzip解压缩并展开归档 tar -jxf filename.tar.bz2 locate其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。 所以你要知道： locate的速度比find快，因为它并不是真的查找文件，而是查数据库locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护升级数据库命令：locate -- u CentOS系统找不到locate命令，原因是系统中没有安装 mlocate 这个包，然后更新数据库: updatedb -c :只显示找到条目的号码 -b :匹配唯一的路径名称的基本文件名 -r :基于基本正则表达式进行匹配操作 find实时查找工具，通过遍历指定起始路径下文件系统层级结构完成文件查找： 根据文件名查找： -name “pattern” -iname “pattern” 支持glob风格的通配符: \*,?,[],[^] i忽略大小写 -regex pattern :基于正则表达式查找文件，匹配整个路径而非其名； 根据文件从属关系查找：123456-user USERNAME:查找属主指定用户的所有文件； -goup GROUPNAME:查找属组指定组的所有文件； -uid UID:查找属主指定的UID的所有文件； -gid GID:查找属组指定的GID的所有文件； -nouser :查找没有属主的文件； -nogroup :查找没有属组的文件； 根据文件的类型查找：-type TYPE :按type查找f:普通文件 d:目录 l:符号链接文件 b:块设备文件 c:字符设备文件p:管道文件 s：套接字文件 【 ./可执行文件 】组合测试：12345与：-a,默认组合逻辑而且的意思; -o 是或者的意思； -not,!：非(相反)find ./ -size -1M -a -type f#寻找当前目录下文件大于1M的文件或者是目录。find ./ -size +1M -o -type d#寻找当前目录下文件小于1M并且文件类型是一般文件的文件。 !A -a !B =!(A -o B) !A -o !B =!(A -a B) 查找tmp目录下不包含“fstab”的字符文件 find /tmp -not -iname &quot;*fstab\*&quot; 根据文件的大小查找： -size [+|-]#UNIT 常用单位：K,M,G123size 10K filename,大小表示 (#-1,#] 9K&lt;filename&lt;10K; size -10K filename,大小表示[0-UNIT-1]; size +10K filename,大小表示(#,∞); 根据时间戳查找以“天”为单位： # [#,#-1]距现在为止过去几天前访问过文件。-#:(0,#) 几天内访问过文件。+#(oo, #-1] 几天前至-oo访问过的所有文件 -atime:显示的是文件中的数据最后被访问的时间，比如系统的进程直接使用或通过一些命令和脚本间接使用。 -mtime:显示的是文件内容被修改的最后时间，比如用vi编辑就会发生改变。 -ctime:显示的是文件的权限、拥有者、所属的组、链接数发生改变时的时间。当然当内容改变时也会随之改变。以“分钟”为单位: -amin -mmin -cmin 同上 根据权限来查找 -perm [/|-]mode find ./ -perm 644mode:精确权限匹配； /mode :任何一类用户(u,g,o)的权限中的任何一位(r,w,x)符合条件即满足 9位权限之间存在“或”关系； -mode :每一类用户(u,g,o)的权限中的每一位(r,w,x)同时符合条件即满足 9位权限之间存在”与”关系；440属于/666有读的权限 find./ -perm /666 符合这一查找 处理动作：-print:输出至标准输出:默认的动作;-ls:类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息-delete:删除找到的文件-fls:/PATH/TO/SOMEFILE:把查找到的所有文件的长格式信息保存至指定文件中；-ok COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认；-exec COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令； 查找/var目录下属主为root，且属组为mail的所有文件或目录；find /var -user root -a -group mail -ls 查找/usr目录下不属于root,bin或hadoop的所有文件或目录；用两种方法find /usr -not -user root -a -not -user bin -a -not -user hadoopfind /usr -not \( -user root -o -user bin -o -user hadoop \) -ls 查找/etc目录下最近一周内其内容修改过，且属主不是root也不是hadoop用户的文件或目录；find /etc -mtime -7 -a -not -user root -a -not -user hadoopfind /etc -mtime -7 -a -not \(-user root -o -user hadoop\) -ls 查找当前系统上没有属主或属组，且最近一周内曾今被访问过的文件或目录；find ./ -nouser -o -nogroup -ls 如果有文件属于可查找项，但是加ls选项最后会无法输出显示 加了-o（或条件）和ls后只会对后一半生效。 需要find ./ \( -nouser -o -nogroup\) -atime -7 -ls 查找/etc目录下大于1M且类型为普通文件的所有文件；find /etc -size +1M -lsfind /etc -size +1M -type f -exec ls -lh {} \; 查找/etc目录下所有用户都没有写权限的文件；find /etc -not -perm /222 -type f -ls 至少有一个用户 有 查找/etc目录至少有一类用户没有执行权限的文件；find /etc -not -perm -type f -111 查找/etc/init.d目录下，所有用户都有执行权限，且其他用户有写权限的所有文件；find /etc -perm -111 -a -perm -002 -lsfind /etc -perm -113 -ls -type f historyhistory [选项][历史命令保存文件]-c:清空历史命令 -w:把缓存中的历史命令写入历史命令保存文件 ~/.bash_history 历史命令默认保存1000条，可以在环境变量配置文件/etc/profile中修改历史命令的调用： 使用上、下箭头调用以前的历史命令 使用”!n”重复执行第n条历史命令 使用”!!”重复执行上一条命令 使用”!字符串”重复执行最后一条以该字符串开头的命令。 使用ctrl+r 搜索历史命令 alias命令别名#alias 别名=&#39;原命令&#39; alias:查询命令别名。 命令执行时顺序： 第一顺位执行时用绝对路径或相对路径执行的命令。 第二顺位执行别名。 第三顺位执行Bash的内部命令。 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。让别名永久生效：vim /root/.bashrc删除别名：unalias 别名. vim:.,$y复制当前行到末尾行:! 调用系统命令，可临时执行 使vim设置永久生效:vim /etc/vimrc 把设置写到这个文件的最后，对所有账户生效set nu 显示行号 set nonu 取消行号set ic 不区分大小写 set noic 取消不区分大小写set ts=4 设置tab键长度set sw=4 设置自动缩进的tab键长度 vim /root/.vimrc 也可以把设置写到此文件，只对root生效 vim字符替换:%s/this/that 每一行的第一个this被替换成that:%s/this/that/g 将文本中所有的this替换成that %从每一行的开头到结尾 s表示替换:1,5 s/old/new/g #替换第一行到第5行中所有匹配的内容. 字符操作u撤销上一步i当前插入，I行首插入。a当前字符插入(光标后一位插入)，A行尾插入。o表示：本行回车到下一行插入，O上一行插入。x删除光标所在字符，X向前删除一个字符。dd删除光标所在的行，dG删除光标所在开始行到文件尾的所有字符。J合并两行。行操作：home 键或^键行首，$或end行尾dd删除一行Ndd(删除本行与下一行)。yy复制一行，Nyy复制n行，p将复制行粘贴，p向光标下一行粘。(N表示数字) 词操作:dw删除一个词，y+$复制至行尾。y+^复制至行首。yw复制一个词。:.,$y 复制当前行到末尾 v模式:编程的时候需要进行多行注释： （删除是要将光标移到这个词的行首，如果光标不在行首则删除光标之后的字母。）块操作：D或d+$删除至行尾 d+^删除至行首1、注释：ctrl+v进入列编辑模式2、向下或向上移动光标 （ctrl L 向下全部选中）3、把需要注释的行开头的开头标记起来4、然后按大写的I5、再插入注释符，比如“#”6、再按Esc，就会全部注释了删除多行注释：按ctrl+v进入列编辑模式;向下或向上移动光标；选中注释部 分然后按d,就会删除注释符号。 vim编辑器： :wq 可以保存外 :w +路径+文件名直接保存在某个位置和重命名:w 路径/文件名ZZ 保存退出 :x 保存退出 :!命令:!ifconfigvi的行定位功能:ctrl+f 向前卷动一个屏幕ctrl+b 向后卷动一个屏幕G 到文件最后一行行首:$ 到文件最后一行行尾mG 到指定行，m为目标行数 或者mggset nu 显示行号/内容 查找指定内容n 查找下一个N 回到前一个？ 寻找上一个 /^字符串 查找以字符串开始的行/字符串$ 查找以字符串结尾的行/a.b 查找字符串a任意字符b vim替换r 替换当前光标字符:r 文件名 在光标当前位置载入另一个文件. useradduseradd命令用来建立用户帐号和创建用户的起始目录，使用权限是终极用户. -u :uid指定用户ID -d:指定用户登入时的启始目录。 -g:指定用户所属的群组 -G:指定用户所属的附加群组。tom 用户的登陆 shell 为非交互式 shell useradd –s /sbin/nologin tom -e :指定账号的有效期限，缺省表示永久有效 useradd user1——创建用户user1;useradd –e 12/30/2009 user2——创建user2,指定有效期2009-12-30到期 -c:用户说明，手工指定用户的说明，添加说明有Spacebar时要加“ “。 用户默认值文件：/etc/defalut/useradd1.GROUP=100 :用户默认组ID (公有模式)2.HOME=/home :用户家目录3.INACTIVE=-1 :密码过期宽限天数(shadow文件7字段)4.EXPIRE=no value :密码失效时间(8字段)5.SHELL=/bin/bash :默认的shell6.SKEL=/etc/skel :模板目录7.CREATE_MAIL_SPOOL=yes :是否建立邮箱 /etc/login.defsPASS_MAX_DAYS 999 :密码有效期(5字段)PASS_MIN_DAYS 0 :密码修改间隔(4字段)PASS_MIN_LEN 5 :密码最小5位(PAM)PASS_WARN_AGE 7 :密码到期警告(6)UID_MIN 500 :最小和最大UID范围GID_MIX 60000ENCRYPT_METHOD SHA512 :加密模式. userdel删除用户userdel [-r] 用户名 -r:删除用户的同时删除用户家目录 id查看用户id：#id 用户名查询用户的UID,初始组ID,附加群组ID usermodusermod命令用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user id，必须确认这名user没在电脑上执行任何程序. -g &lt;群组&gt; 修改用户所属的原始群组。usermod -g root username -G &lt;群组&gt; 修改户所属的附加群组 -a -G 无限增加到附加组，可拥有多个附加组.将a1添加附加组user3 usermod -a -G user3 a1-c:修改用户的说明usermod -c &quot;test user&quot; username 当某一用户拥有多个附加组之后，使用usemod -G会修改附加组，则多个组消失掉变成唯一当前修改的附加组1.将 newuser2 添加到附加组 staff usermod -G staff newuser2 -l &lt;帐号名称&gt; 修改用户帐号名称。2.修改 newuser 的用户名为 newuser1 usermod -l newuser1 newuser-L 锁定用户密码，使密码无效。 -U 解除密码锁定。3.锁定账号 newuser1 usermod -L newuser14.解除对 newuser1 的锁定 usermod -U newuser1 -d 改变用户家目录,常与-m结合使用 -m 将主目录的内容移动到新目录usermod -m -d /home/user2 -uid username若使用报错使用以下命令：cat /dev/null &gt; /var/run/utmp 清空此文件。utmp是一个文件，除了utmp程序你不能编辑这个文件，删掉他的话，当前登陆信息都会丢失。它就好比系统开启后它会把系统成员的信息迅速的记录下来，过一段时间它就不再记录，确认系统的用户配置就是这样了，这个文件在每次机器reboot起来后都会重新创建。. groupadd-g GID: 修改组ID -n 新组名: 修改组名 susu: [选项] 用户名 -:选项只使用”-“代表连带用户的环境变量一起切换。可使用env命令查看-c:仅执行一次命令，而不切换用户身份su - root -c &quot;useradd user3&quot;不切换成root,但是执行useradd命令添加user1用户。 chage修改用户密码状态chagechage [选项] 用户名 -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期(shadow3字段) -m 天数:两次密码修改间隔(4字段) -M 天数:密码有效期(5字段) -W 天数:密码过期前警告天数(7字段) -I 天数:密码过后宽限天数(7字段) -E 日期:账号失效时间(8字段)chage -d 0 username这个命令其实是把密码修改日期归0了(shadow第3字段)，这样用户只要一登录就要修改密码。第三字段是指密码最后一次修改时间的日期。1970年1月1号到现在修改密码的时间戳。如果第3字段改为0，系统会认为用户没有修改过操作密码，那么当此用户一旦登录系统就会提示要修改密码，才可正常使用。. passwd-S:查询用户密码的密码状态，仅root用户可用。 -l:暂时锁定用户。仅root用户可用。 -u:解锁用户。仅root用户可用。 –stdin:可以通过管道符输出的数据作为用户的密码。echo &quot;123&quot; | passwd --stdin user gpasswd -d :从组删除用户 gpasswd -d username groupadd -a :添加用户到组(附加组),同时保留以前的组 添加用户到某一个组可以使用 usermod -G groupB userA 这个命令可以添加一个用户到指定的组，但是以前添加的组就会清空掉.所以想要添加一个用户到一个组，同时保留以前添加的组时，请使用gpasswd这个命令来添加操作用户 -A :指定组内管理员 gpasswd -A username groupname groups groups username 显示linux用户所属的组 datedate 根据给定格式显示日期或设置系统日期时间。print or set the system date and time 指令所在路径：/bin/date date &quot;+%Y-%m-%d %H:%M:%S&quot; -d:显示字符串所指的日期与时间。字符串前后必须加上双引号123date -d now date -d &apos;next monday&apos; date -d yesterday +%Y-%m-%d -r:显示文件最后修改时间 -s:设置系统时间 date -s &quot;2018-11-11 00 00 00&quot; 在使用date -s这个命令修改时间后，系统重启后就失效了，因此为了将这个时间永久生效，需要将修改的时间写入CMOS，查看CMOS的时间:clock –r将当前系统时间写入CMOS中去clock –w 在生产环境中常使用时间格式打包数据：tar zcvf etc-$(date +%F).tar.gz /etctar zcvf etc-`date +%F`.tar.gz /etc date:2018/9/23 hwclock查看硬件时间设置硬件时间hwclock --set --date=&quot;07/07/06 10:19&quot; （月/日/年 时:分:秒）硬件时间和系统时间的同步：重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需要用hwclock命令实现同步。硬件时钟与系统时钟同步：hwclock --hctosys（hc代表硬件时间，sys代表系统时间）系统时钟和硬件时钟同步:（让系统的时间同步到硬件时钟)hwclock –-systohc. lnln：链接命令硬链接：复制并同步 ln /etc/passwd /tmp/password 软链接：类似windows下的快捷方式 ln -s /etc/passwd /tmp password软链接和硬链接的区别:1.创建命令不同:ln -s /root/ruan.txt /root/桌面/ ln /root/ying.txt /root/桌面/2.软链接创建时必须使用绝对路径(链接和源文件在同一目录下,可以相对路径)硬链接创建时可以绝对路径也可相对路径3.软链接的源文件不可以剪切,重命名,删除 硬链接的源文件可以剪切,重命名,删除4.软链接的链接文件权限永远是777，即使将链接文件的权限进行了修改，也不会发生变化，变得是源文件的权限 硬链接的链接文件权限永远和源文件相同5.软链接的链接文件的inode号和源文件不同硬链接的链接文件的inode号和源文件相同6.软链接可以对目录操作硬链接不支持对目录操作，是针对于上层来说，底层是可以针对于目录做硬链接的，通过代码就可以实现7.软链接可以跨文件系统硬链接不可以跨文件系统，因为硬链接是存放在源文件的同一个block上面的 SElinux安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则） DAChttp://blog.51cto.com/zhaotianyu/1795178：在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：某个资源是否拥有对应用户的权限（读、写、执行）。只要访问这个资源的进程符合以上的条件就可以被访问。而最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问。这种权限管理机制的主体是用户，也称为自主访问控制（DAC）。 MAChttp://baijiahao.baidu.com/s?id=1590170088632157084&amp;wfr=spider&amp;for=pc：在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限。这样一来，即使进程是以 root 身份运行的，也需要判断这个进程的类型以及允许访问的资源类型才能决定是否允许访问某个资源。进程的活动空间也可以被压缩到最小。即使是以 root 身份运行的服务进程，一般也只能访问到它所需要的资源。即使程序出了漏洞，影响范围也只有在其允许访问的资源范围内。安全性大大增加。这种权限管理机制的主体是进程，也称为强制访问控制（MAC）。getenforce命令是单词get（获取）和enforce(执行)连写，可查看selinux状态setenforce 命令则是单词set（设置）和enforce(执行)连写，用于设置selinux防火墙状态，如： setenforce 0用于关闭selinux防火墙，但重启后失效。 SELinux status：selinux防火墙的状态，enabled表示启用selinux防火墙关闭SElinux:临时关闭 :setenforce 0用于关闭selinux防火墙，但重启后失效永久关闭：修改selinux的配置文件：vim /etc/selinux/config将SELINUX=enforcing改为SELINUX=disabled，保存后退出，此时获取当前selinux防火墙的安全策略仍为Enforcing，配置文件并未生效。重启后验证。SELinux 有三种工作模式，分别是：1.enforcing：强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中。2.permissive：宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用。3.disabled：关闭 SELinux crontab1.Crontab是一个用于设置周期性执行任务的工具；2.周期性执行的任务我们称为Cron Job；3.周期性执行的任务列表我们称为Cron Tablecrontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下: * * * * * command minute hour day month week command 顺序:分 时 日 月 周 minute： 表示分钟，可以是从0到59之间的任何整数。hour：表示小时，可以是从0到23之间的任何整数。day：表示日期，可以是从1到31之间的任何整数。month：表示月份，可以是从1到12之间的任何整数。week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件 -u:编辑某个用户的cron，只用root可以使用此参数为别的用户设置cron服务。也可用于给用户指定crontab文件。 -l: 列出当前用户的crontab。 -r: 删除当前用户的crontab。 -e: 编辑当前用户的crontab，默认使用vi，或者是由 VISUAL或EDITOR环境变量指定的编辑器。 -i与-r 一起使用，用来询问用户是否直接删除crontab安装cronyum install vixie-cronyum install crontabs检查crontab工具是否安装：crontab -l检查crond服务是否启动：service crond status检查crontab服务状态：service crond status 每晚的21:30重启apache30 21 * * * service httpd restart 每月1,10,22日的4:45重启apache45 4 1,10,22 * * service httpd restart 每月1-10日的4:45重启apache45 4 1-10 * * service httpd restart 每天18:00-23:00之间每隔30分钟重启apache0,30 18-23 * * * service httpd restart0-59/30 18-23 * * * service httpd restart 每晚11-早上7点之间，每隔一个小时重启apache* 23-7/1 * * * service httpd restart 每隔两分钟重启apache 123*/2 * * * * service httpd restart 1-59/2 * * * * service httpd restart(奇数分钟重启) 0-58/2 * * * * service httpd restart(偶数分钟重启) 小结：*表示任何时候都匹配；可以用”A,B,C”表示A或者B或者C时执行命令可以用”A-B”表示A到B之间时执行命令可以用”*/A”表示每A分钟(小时等)执行一次命令 */1 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP时间同步: fdiskfdisk命令操作磁盘详解–添加、删除、转换分区等主分区和扩展分区(扩展分区不能直接使用)(1-4),扩展分区下面再分逻辑分区(5开始)。 fdisk /dev/sda 分区保存报错需要重启时，强制读取分区表信息#partprobeyum install -y parted grepgrep [选项] “搜索内容” 文件名 -i 忽略大小写 -n 输出行号 -v 反向查找 --color=auto把搜索出的关键字用颜色显示]]></content>
      <categories>
        <category>Linux command</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
