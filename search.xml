<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[建立博客]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo + github搭建博客教程 为什么要搭建一个独立的博客：独立的才是自己的，自己的才是最好的Hexo:快速、简洁且高效的博客框架github:大佬都会用的网站戏称,”全球最大同性交友网站”是一个面向开源及私有软件项目的托管平台 推荐使用google浏览器 购买域名推荐上 GoDaddy 购买域名，方便快捷，可以使用支付宝。此网站有中文显示，地区选择新加坡即可。https://sg.godaddy.com/zh/这里的购买时间,大家随意。域名的价格变动较大，购买需谨慎。结算后，去「我的账户 &gt; 我的产品」，域名已经显示在你的账户了。 使用 独立域名用 DNSpod，快，免费，稳定，可直接使用微信登录注册DNSpod，添加域名，如下图设置。域名买了以后还不能使用，需要做dns解析https://www.dnspod.cn/其中 A 的两条记录指向的ip地址是 GitHub Pages 的提供的 ip,如果博客无法登录可能是GIthub的IP进行了更换，到github Pages查看最新IP即可。www 指定的记录是你在 GitHub 注册的仓库名也可以是域名。 去 GoDaddy 修改 DNS 地址如果有不清楚的地方可查看GOdaddy的帮助，DNSpod帮助。到这里域名配置完成。 安装准备软件1.Node.js: https://nodejs.org/en/2.Git: https://git-scm.com/这里的两个软件直接下载安装，直接点下一步安装完成即可。 到github新建一个仓库(新建的仓库是用来存放你的博客)：https://github.com/ 这里要注意的是:存储库的名字只能是”你自己的用户名.github.io”这个格式 我们需要让本地git项目与远程的GitHub进行绑定多以用SSH keys 在桌面右键选择git bash here打开软件检查ssh keys的设置$ cd ~/.ssh 检查本机的ssh密钥如果提示：No such file or directory 说明你是第一次使用 git。生成新的ssh key: $ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key(/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;然后系统会提示你输入密码：Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 提示：输入密码的时候屏幕没有显示最后看到这样的界面就是成功了。cd ~/.sshcat id_rsa.pub查看key并复制然后粘贴刚刚复制的内容。回到git，输入命令看看是否成功$ ssh -T git@GitHub.com正确的反馈:输入yes然后显示：还有一些信息要设置：SSH Key 配置成功。 生成你的博客新建一个文件夹右键打开git bash here安装博客框架:https://hexo.io/zh-cn/安装完成以后，文件夹会自动下载博客文件 和github建立连接回到你创建的文件夹下，使用编辑器打开箭头所指文件，然后按照下图修改。Repo后接的是你自己github创建的库的ssh地址。其他不变然后保存。 hexo g 生成静态页面hexo s 会给你一个地址等同于127.0.0.1:4000 复制到浏览器打开，这时就可以在本地查看看到自己的博客了。hexo s -i ip地址 还可以指定IP访问给手机访问，在同一个局域网内(此命令可以不操作忽略即可)hexo clean清楚缓存，每次修改完后，清理下缓存，不然容易报错。hexo g -d将本地数据与github同步。步骤为: hexo clean; hexo g -d 使用域名访问：在github中点击自己的项目到设置下方填上自己的域名 并且 在仓库里面新建一个文件写上自己的域名(每次同步以后新建的文件会覆盖，需要新建/每次同步以后必须在github里面修改这两处地方) 你已经完成了可以使用域名访问了。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ghost]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[只要开始 就不会结束！ body{background-image:url(https://ws1.sinaimg.cn/large/005RRiqRly1fvw1bz9he2j33dc28w4qu.jpg);background-position:center;background-repeat:repeat-y；} Why live]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2018%2F08%2F28%2Fdocument%2F</url>
    <content type="text"><![CDATA[Linux 文档 用户和用户组管理/etc/passwd:用户信息文件user1:x:500:500::/home/user1:/bin/bash第一字段:用户名称；第二字段:密码标志；第三字段:UID(用户ID)； 0：超级用户； 1-499：系统用户(伪用户)； 500-65535:普通用户；第4字段：GID(用户初始组ID)第5字段：用户说明第6字段：家目录 普通用户：/home/用户名/ 超级用户：/root/第7字段：登录之后的Shell 影子文件:/etc/shadow第1字段：用户名第2字符：加密密码 加密算法升级为SHA512散列加密算法 如果密码位是“ ！”或“ * ”代表没有密码，不能登录。第3字段：密码最后一次修改日期：使用1970年1月1号作为标准时间，每过一天时间戳加1。第4字段：两次密码的修改间隔时间(和第3字段相比)间隔多少时间后才可以修改密码。第5字段：密码有效期(和第3字段相比)第6字段：密码修改到期前的警告天数(和第5字段相比)第7字段：密码过期后的宽限天数(和第5字段相比) 0：代表密码过期后立即失效。 -1：则代表密码永远不会失效。第8字段：账号失效时间，要用时间戳表示第9字段：保留把时间戳换算为日期：date -d &quot;1970-01-01 17740 days&quot;把日期换算为时间戳：echo $(($(date --date=&quot;2018/07/28&quot; +%s)/86400+1)) 组信息文件/etc/group第一字段：组名第二字段：组密码标志第三字段：GID第四字段：组中附加用户 组密码文件/etc/gshadow第一字段：组名第二字段：组密码第三字段：组管理员用户名第四字段：组中附加用户 用户的家目录 普通用户：/home/用户名/,所有者和所属者都是此用户，权限是700 超级用户：/root/,所有者和所属者都是root用户，权限是550。 用户的邮箱：/var/spool/mail/用户名/ 用户模板目录：/etc/skel:创建用户时，用户的家目录会自动创建一些隐藏文件，这些文件是从/etc/skel/ 过去的。想要每个新添加用户时家目录自动出现共享文件可在此目录添加。 linux的特殊权限特殊权限： SUID,SGID,STICKY 1.进程以某用户的身份运行；进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作；2.权限匹配模型：(1)判断进程的属主，是否为被访问的文件属 主 ；如果是，则应用属主的权限；否则进入第2步；(2)判断进程的属主，是否属于被访问的文件属 组 ；如果是，则应用属组的权限；否则进入第3步;(3)应用other的权限； SUIDSetUID的功能:1、只有可以执行的二进制程序才能设定SUID权限。2、命令执行者要对该程序拥有X(执行)权限3、命令执行者在执行该程序时获得该程序文件属主的身份4、SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效。 SUID :默认情况下:用户发起的进程，进程的属主是其发起者；因此，其以发起者的身份运行； SUID 的功用：用户运行某程序时，如果此程序拥有SUID的权限，那么程序运行为进程时，进程的属主不是发起者，而程序文件自己的属主;管理文件的SUID权限： chmod u+|-s FILe 展示位置：属主的执行权限位。 #chomod 4644 filename取消suid权限：#chmod 644 filename 大写S为报错,检查是否有x权限. SGID用户在执行程序时候，组身份变为该程序文件的属组与SUID类似。 管理文件的 SGID 的权限： chmod g+|-s FILE SGID : 功用：当目录属组有写的权限，且SGID权限时，当你给一个目录添加了sgid之后，后面不管谁来这个目录下创建文件，文件的所属组都会继承目录的所属组展示位置：属组的执行权限位如果属组原本有执行权限，则显示为小写s;否则，显示为大写S; #ll /usr/bin/locate #ll /var/lib/mlocate/mlocate.db STICKY sticky :t权限只能给目录添加，当你给一个目录添加了t权限之后，后面所有人在这个目录下不能删除其他人的文件,只能删除自己的文件； 管理文件的Sticky权限： chmod o+|-t FILE 展示位置：其他用户的执行权限位 如果其他用户原本有执行权限，显示为小写t;否则为大写T。 系统上的/tmp和/var/tmp目录下默认均有Sticky权限 基于八进制方式赋权时，可于默认的三位八进制数字左侧再加一位八进制数字； chmod 1777 中的 1 表示特殊权限 . faclfacl:file access control lists 文件访问控制列表文件的额外赋权机制：在原有的u,g,o之外，另一层让普通用户控制赋权给另外的用户或组的赋权机制；查看分区ACL权限是否开启dumpe2fs -h /dev/sda3dumpe2fs命令是查询指定分区详细文件系统信息的命令.选项： -h 仅显示超级块中的信息，而不显示磁盘块组的详细信息 临时开启分区ACL权限： mount -o remount,acl / 重新挂载根分区，并挂载加入acl权限。 永久开启分区ACL权限#vi /etc/fstab UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 dufaults,acl 1 1 加入ACLmount -o remount /:重新挂载文件系统或重启动系统，使修改生效。getfacl filename:查看文件额外的权限setfacl命令： setfacl -m u:username:rw filename 赋权给用户： setfacl -m u:USERNAME:MODE file 赋权给组： serfacl -m g:GROUPNAME:MODE file 撤销赋权:serfacl -x u:USERNAME file serfacl -x g:USERNAME file 递归ACL权限：#setfacl -m u:用户名:权限 -R 目录名 默认ACL权限:默认acl权限的作用是如果给父目录设定了默认的ACL权限，那么父目录中所有新建的子文件都会继承父目录ACL的权限。#setfacl -m d:u:用户名:权限 文件名 setfacl 选项 文件名选项： -m :设定ACL权限 -x :删除指定的ACL权限 -b :删除文件所有的ACL权限 -d :设定默认ACL权限 -k :删除默认ACL权限 -R :递归设定ACL权限 最大有效权限maskmask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限”相与”才能得到用户的真正权限。 A B and r r r r - - - r - - - - 修改最大有效权限：#setfacl -m m:rx filename 设定mask权限为r-x。使用“m:权限”格式。 mask值只能添加ACL权限之后后期更改，当更改mask值以后再添加ACL权限，mask值就会变为777. 文件系统属性chattr权限#chattr [+-=] [选项] 文件或目录名+：增加权限-：删除权限=：等于权限 选项：-i:如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据还可以cp，但不允许建立和删除文件 -a:如果对文件设置a属性，那么只能在文件中增加数据(只能用echo增加数据，不能用vim)，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。chattr +i a.txtlsattr -a a.txt----i--------e- a.txt e:代表此文件在ext4文件系统下建立的。查看文件系统属性：lsattr 选项 文件名 -a显示所有文件和目录 -d若目标是目录，仅列出目录本身的属性，而不是子文件。 sudo权限root把本来只能超级用户执行的命令赋予普通用户执行。sudo的操作对象是系统命令 whereis 命令 查看命令的绝对路径visudo 实际修改的是/etc/sudoers文件root ALL=(ALL) ALL用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径) 被管理的主机地址可写成主机ip和ALL%wheel ALL=(ALL) ALL组名 被管理的主机地址=(可使用的身份) 授权命令(绝对路径) root ALL=(ALL) ALLst 192.168.81.137=/sbin/shutdown -r now 添加内容 st ALL=/usr/bin/vim 危险操作su - st:切换用户sudo -l:查看可用的sudo命令sudo /sbin/shutdown -r now 普通用户执行sudo赋予的命令 linux下查看帮助命令 whatis :用于查询一个命令执行什么功能，并将查询结果打印到终端上whatis ls man :Linux提供了丰富的帮助手册，当你需要查看某个命令的参数时不必到处上网查找，只要man一下即可 man command linux根目录结构和文件系统进程的类型： 终端:硬件设备，关联一个用户接口。 与终端相关:通过终端启动。 与终端无关:操作引导启动过程中自动启动操作系统的组成: 静态:kernel,application 文件系统:层级结构FHS: Filesystem Hierarchy Standard /bin:所有用户可用的基本命令程序文件； /sbin:供系统管理使用的工具程序； /boot:引导加载器必须用到的各种静态文件：Kernel,initramfs(initrd),grub等； /dev:存储特殊文件或设备文件； 设备有两种类型：字符设备(线性设备)、块设备(随机设备)； /etc:系统程序的配置文件，只能为静态： /home：普通的家目录的集中位置：一般每个普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME； /lib:为系统启动或根文件系统上的应用程序（/bin,/sbin）等提供共享库，以及为内核提供内核模块 libc.so.*:动态链接的C库； ld*:运行时链接器/加载器； modules:用于存储内核模块的目录； /lib64:64位系统特有的存放64位共享的路径； /media:便携式设备挂载点，cdrom,floppy等； /mnt:其他文件系统的临时挂载点； /opt：附加应用程序的安装位置：可选路径； /srv:当前主机为服务提供的数据； /tmp:为那些会产生临时文件的程序提供的用于临时文件的目录：可供所用户执行写入操作：有特殊权限； /usr:usr Hierarchy,全局共享的只读数据路径： bin,lib64 include:C程序头文件； share:命令手册页和自带文档等架构特有的文件的存储位置 local:另一个层级目录； X11R6:X-widow程序的安装位置 src:程序源代码文件的存储位置 多命令顺序执行多命令执行符格式作用&amp;&amp;命令1 &amp;&amp; 命令2逻辑与,当命令1正确执行,则命令2才会执行。当命令1执行不正确,则命令2不会执行||命令1 || 命令2逻辑或,当命令1执行不正确,则命令才会执行。当命令1正确执行,则命令2不会执行 通配符通配符作用?匹配一个任意字符*匹配0个或任意多个字符，也就是可以匹配任何内容[]匹配括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者a,或者b,或者c。[^]逻辑非，表示不匹配中括号内的任意一个字符。例如:[^0-9]代表匹配一个不是数字的字符。 Bash中其他特殊符号 符号作用&#39;&#39;单引号。在单引号中所有的特殊符号，如$,`(反引号)都没有特殊含义。&quot;&quot;双引号。在双引号中特殊符号都没有特殊含义，但是$,和\是例外,拥有&quot;调用变量的值&quot; `反引号引用命令,和&quot;转义符&quot;的特殊含义&quot;``反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。$()和反引号作用一样，用来引用系统命令。#在shell脚本中，#开头的行代表注释。$用于调用变量的值,如需要调用变量name的值时，需要用$name的方式得到变量的值时，需要用$name的方式得到变量的值。\转义符,跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出$符号，而不当做是变量引用。. 12345[root@Tiger ~]# name=test [root@Tiger ~]# echo &apos;$name&apos; $name [root@Tiger ~]# echo &quot;$name&quot; test 12345[root@Tiger ~]# abc=`date` [root@Tiger ~]# echo `date` 2018年 09月 09日 星期日 13:10:57 CST [root@Tiger ~]# echo $abc 2018年 09月 09日 星期日 13:10:49 CST 12345[root@Tiger ~]# abc=$(date) [root@Tiger ~]# echo $abc 2018年 09月 09日 星期日 13:12:44 CST [root@Tiger ~]# echo &quot;abc&quot; abc 1234[root@Tiger ~]# echo &quot;$abc&quot; 2018年 09月 09日 星期日 13:12:44 CST 反引号和$ #echo `ls` #echo $(date) Bash 变量什么是变量：变量是计算机内存单元，其中存放的值可以改变。当Shell脚本需要保存一些信息时，如一个文件名或一个数字,就把它存放在一个变量中，每个变量有一个名字，所以很容易引用它，使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。变量设置规则：explanation 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是”2name”则是错误的。 在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。 变量用等号连接值，等号左右两侧不能有空格。 变量的值如果有空格，需要使用单引号或双引号包括。 在变量的值中，可以使用”\”转义符。 如果需要增加变量的值，那么可以进行变量值的叠加，不过变量需要用双引号包含”$变量名”或用${变量名}包含。 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。 环境变量名建议大写，便于区分。变量的分类 用户自定义变量 环境变量:这种变量中主要保存的是和系统操作环境相关的数据。 位置参数变量:这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。 预定义变量:是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定好的。 本地变量变量定义：#name=&quot;bianliang&quot;变量叠加： #aa=123 #aa=$aa456 #aa=${aa}789变量调用：echo $name变量查看：set变量删除：&gt;unset name 环境变量环境变量是什么:用户自定义变量只在当前的Shell中生效，而环境变量会在当前Shell和这个Shell的所有子Shell当中生效。如果把环境变量写入相应的配置文件,那么这个环境变量就会在所有Shell中生效。 pstree:查看进程数,查看当前shell设置环境变量：export 变量名=变量值申明变量:env :查询变量,专门查看环境变量。set:查看所有变量unset 变量名 #删除变量 name=sc 本地变量export age=18 环境变量sex=man 本地变量。把已经定义好的本地变量变成环境变量，只需要：export sex 系统常见环境变量PATH:系统查找命令的路径 #echo $PATH/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/binPATH变量叠加：PATH=&quot;$PATH&quot;:/root/sh(脚本保存目录) ps1:定义系统提示符的变量：\d:显示日期，格式为”星期 月 日”\h:显示简写主机名。如默认主机名”localhost”\t:显示24小时制时间，格式为”HH:MM:SS”\T:显示12小时制时间，格式为”HH:MM:SS”\A:显示12小时制时间，格式为”HH:MM”\u:显示当前用户名\w:显示当前所在目录的完整名称\W:显示当前所在目录的最后一个目录#:执行的第几个命令\$:提示符。如果为root用户会显示提示符为”#”,如果普通用户会显示提示符为”$”。\@:时间 上下午 echo $PS1 :查看提示符[root@Tiger ~]# PS1=&#39;[\u@\t \w]\$ &#39;这里的空格生成以后,提示符后会有一个SPACE的距离。[root@16:10:52 ~]#cd /usr/local/src/[root@16:11:08 /usr/local/src]# #PS1=&#39;[\u@\@]\$&#39;[root@04:13 下午]#PS1=&#39;[\u@\@ \h]\$&#39;[root@04:17 下午 Tiger]#PS1=&#39;[\u \@@]\$&#39;[root 04:18 下午@]#^ 位置参数变量位置参数变量作用$nn为数字,$0代表命令本身,$1-$9代表第一到第九个参数,十以上的参数需要用大括号包含,如${10}$这个变量代表命令行中所有的参数,$把所有的参数看成一个整体$@这个变量也代表命令行中所有的参数,不过$@把每个参数区别对待$#这个变量代表命令行中所有参数的个数位置参数变量的名称和作用是固定的，他是为了接受用户向程序传入不同的值。 123456789101112131415vim ceshi.sh #!/bin/bash echo $0echo $1echo $2echo $3 :wqchmod 755 ceshi.sh./ceshi.sh./ceshi.sh 输出结果是本身./ceshi.sh 11 22 33./ceshi.sh 输11 出22 接33 果 1234567#!/bin/bashnum1=$1num2=$2sum=$(($num1 + $num2)) //变量sum的和是num1加num2echo $sum //打印sum的值chmod 755 ceshi.sh./ceshi.sh 11 22 123456789#!/bin/bashecho $#echo $*echo $@chmod 755 ceshi.sh./ceshi.sh 11 22 33 44 55 66 6 11 22 33 44 55 6611 22 33 44 55 66 预定义变量预定义变量作用$?最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行;如果这个变量的值非0(具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确了。$$当前进程的进程号(PID)$!后台运行的最后一个进程的进程号(PID)/td&gt;在Linux里面输入一条命令正确执行以后，输入echo $? ，默认输出 0当输出一条错误的命令以后，会系统报错，输入echo $? ，默认输出 127 123456789#!/bin/bashecho &quot;$$&quot;find /root -name hello.sh $ // $符号的作用是把程序放在后台echo &quot;$!&quot;chmod 755 ceshi.sh./ceshi.sh2788827888 接受键盘输入read [选项][变量名] -p”提示信息”:在等待read输入时,输出提示信息 -t 秒数:read命令会一直等待用户输入，使用此选项可以指定等待时间。 -n 字符数:read命令只接受指定的字符数，就会执行 -s:隐藏输入的数据，适用于机密信息输入。 数值运算与运算符declare声明变量类型declare [+/-][选项] 变量名 -:给变量设定类型属性 +取消变量的类型属性 -i:将变量声明为整数型(integer) -x:将变量声明为环境变量 -p:显示指定变量的被声明的类型数值运算方法1: [root@Tiger data]#aa=11 [root@Tiger data]#bb=22给变量aa和bb赋值 [root@Tiger data]#declare -i cc=$aa+$bb方法2:expr或let数值运算工具 [root@Tiger data]#aa=11[root@Tiger data]#bb=22给变量aa和变量bb赋值 [root@Tiger data]#dd=$(expr $aa + $bb)$dd的值是aa和bb的和,注意”+”号左右两侧必须有空格方法3:$((运算式))或$[运算式] aa=11bb=22gg=$(($aa+$bb))ff=$[$aa+$bb] 运算优先级 优先级从上到下优先级运算符说明13-，+单目负,单目正12!，~逻辑非，按位取反或补码11*，/，%乘、除、取余10+，-加、减9&lt;&lt;，&gt;&gt;按位左移、按位右移8&lt;=，&gt;=，&lt;，&gt;小于或等于、大于或等于、小于、大于7==，!==等于、不等于6&amp;按位与5^按位异或4|按位或3&amp;&amp;逻辑与2||逻辑或1=，+=，-=， ，*=，/=，%=，&amp;=，^=，|=，&lt;&lt;=，&gt;&gt;=赋值、运算且赋值. 变量测试与内容替换 123456789101112131415[root@Tiger ~]# unset y[root@Tiger ~]# x=$&#123;y-new&#125;[root@Tiger ~]# echo $y[root@Tiger ~]# echo $xnew[root@Tiger ~]# y=&quot;&quot;[root@Tiger ~]# x=$&#123;y-new&#125;[root@Tiger ~]# echo $x[root@Tiger ~]# y=old[root@Tiger ~]# x=$&#123;y-new&#125;[root@Tiger ~]# echo $xold[root@Tiger ~]# 环境变量配置文件1source 配置文件 或 调用文件的命令1. 配置文件 环境变量配置文件简介：环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如PATH,HISTSIZE,PS1,HOSTNAME等默认环境变量。环境变量配置文件:①/etc/profile②/etc/profile.d/*.sh *是通配符，代表这个目录下所有以.sh结尾的文件。③~/.bash_profile④~/.bashrc⑤/etc/bashrc其中3个在/etc/下面的变量配置文件是对所有登录Linux用户生效。另外两个是用户家目录下的隐藏文件只对当前用户生效。 其他的配置文件和登录信息 注销时生效的环境变量配置文件：~/.bash_logout :这个文件默认是空的，如果想要每次登录比如清空历史命令或者把自己的环境变量清空等，写入后，注销时他会自动执行 ~/bash_history :保存的历史命令，但是有一些他还保存在内存当中，除非是手工写入history -w或者注销登录才会把内存中的命令转移到这个文件中去。 Shell登录信息 本地终端欢迎信息:/etc/issue只对本地登录有显示效果 转义符作用\d显示当前系统日期\s显示操作系统名称\l显示登录的终端号,这个比较常用\m显示硬件体系结构,如i386、i686等\n显示主机名\o显示域名\r显示内核版本\t显示当前系统时间\u显示当前登录用户的序列号 远程终端欢迎信息: /etc/issue.net (上图的转义符本文件不能使用,只能使用纯文本信息)转义符在/etc/issue.net文件中不能使用是否显示此欢迎信息,由ssh的配置文件 /etc/ssh/sshd_config决定，加入&quot;Banner /etc/issue.net&quot;行才能显示(记得重启SSH服务) 登录后显示 欢迎信息: /etc/motd 不管是本地登录,还是远程登录,都可以显示此欢迎信息.直接写入此文件即可 正则表达式与通配符正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配。grep、awk、sed等命令可以支持正则表达式。 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配。 元字符 作用*前一个字符匹配0次或任意多次.匹配除了换行字符外任意一个字符^匹配行首。例如：^hello 会匹配以hello开头的行。$匹配行尾。例如：hello$ 会匹配以hello结尾的行[]匹配中括号中指定的任意一个字符，只匹配一个字符。例如：[aeiou]匹配任意一个元音字母，[0-9]匹配任意一位数字，[a-z][0-9]匹配小写字母和一位数字构成的两位字符[^]匹配除中括号的字符以外的任意一个字符。例如：[^0-9]匹配任意一位非数字字符，[^a-z]表示任意一位非小写字母。\转义符。用于取消将特殊符号的含义取消。\{n\}表示其前面的字符恰好出现n次。例如：[0-9]\{4\}匹配4为数字，[1][3-8][0-9]\{9\}匹配手机号码\{n,\}表示其前面的字符出现不小于n次。例如：[0-9]\{2,\}表示两位及以上的数字\{n,m\}表示其前面的字符至少出现n次，最多出现m次。例如：[a-z]\{6,8\}匹配6到8位的小写字母 *前一个字符匹配0次，或任意多次grep &quot;a*&quot; ceshi.txt 匹配所有内容，包括空白行grep &quot;aa*&quot; ceshi.txt 匹配至少包含有一个a的行grep &quot;aaa*&quot; ceshi.txt 匹配最少包含两个连续a的字符串grep &quot;aaaaa&quot; a.txt 则会匹配最少包含四个连续的a的字符串. 匹配除了换行符外任意一个字符grep &quot;s..d&quot; a.txt s..d会匹配s和d这两个字符之间一定有两个字符的单词grep &quot;s.*d&quot; a.txt 匹配在s和d字母之间有任意字符grep &quot;.*&quot; a.txt 匹配所有内容^ 匹配行首，$匹配行尾grep &quot;^M&quot; a.txt 匹配以大写M开头的行grep &quot;n$&quot; a.txt 匹配以小写n结尾的行grep -n &quot;^$&quot; a.txt 会匹配空白行,-n 显示行号[] 匹配中括号中指定的任意一个字符，只匹配一个字符grep &quot;s[ao]id&quot; a.txt 匹配s和i字母中，要么是a要么是ogep &quot;[0-9]&quot; a.txt 匹配任意一个数字grep &quot;^[a-z] a.txt 匹配用小写字母开头的行grep &quot;^[a-z]&quot; a.txt 匹配用小写字母开头的行 ^ 匹配除中括号的字符以外的任意一个字符grep &quot;^[^a-z]&quot; a.txt 匹配不用小写字母开头的行grep &quot;^[^a-zA-Z]&quot; a.txt 匹配不多字母开头的行\ 转义符grep &quot;\.$&quot; a.txt 匹配使用.结尾的行\{n\} 表示其前面的字符恰好出现n次grep &quot;a\{3\}&quot; a.txt 匹配a字母连续出现三次的字符串grep &quot;[0-9]\{3\}&quot; a.txt 匹配包含连续的三个数字的字符串{n,\} 表示其前面的字符出现不小于n次grep &quot;^[0-9]\{3,\}&quot; a.txt 匹配最少用连续三个数字开头的行\{n,m} 匹配其前面的字符至少出现n次，最多出现m次grep &quot;sa\{1,3\}i&quot; a.txt 匹配在字母s和字母i之前有最少一个a,最多三个a 字符截取命令cut 字段提取命令printf 命令 (严格意义上讲他不属于字符截取命令，因为awk要用到，在这里提出)awk 命令sed 命令cut [选项][文件名] -f 列号: 提取第几列 -d 分隔符: 按照指定分隔符分割列.他的默认分隔符是Tabcut -f &quot;:&quot; -f 1,3 /etc/passwd12345[root@Tiger data]# vim b.txt 这里的空格是Tab键 1 ID NAME gender mark 2 1 liming M 86 3 2 sc M 90 4 3 cao M 83 12345[root@Tiger data]# cut -f 2 b.txtNAMElimingsccao 12345[root@Tiger data]# cut -f 2,4 b.txt NAME markliming 86sc 90cao 83 cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1 常和grep结合使用，查看用户文件，查找普通用户，过滤root，提取用户名称 cut命令的局限df -h | grep /dev/sda3 | cut -d &quot; &quot; -f 5 df命令使用的是空格分隔符，这条命令不能使用，cut对空格使用不友好 printf &#39;输出类型输出格式&#39; 输出内容输出类型:%ns：输出字符串。n是数字指代输出几个字符%ni：输出整数。n是数字指代输出几个数字%m.nf：输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2是小数，6位是整数。 输出格式作用\a输出警告音\b输出退格键，也就是Backspace键\f清除屏幕\n换行\r回车，也就是Enter键\t水平输出退格键，也就是Tab键\v垂直输出退格键，也就是Tab键12345678910[root@Tiger data]# printf %s 1 2 3 4 5 6123456[root@Tiger data]# [root@Tiger data]# printf %s %s %s 1 2 3 4 5 6%s%s123456[root@Tiger data]# [root@Tiger data]# printf &apos;%s %s %s&apos; 1 2 3 4 5 61 2 34 5 6[root@Tiger data]# [root@Tiger data]# printf &apos;%s %s %s\n&apos; 1 2 3 4 5 61 2 34 5 6[root@Tiger data]# printf输出文件内容格式：printf &#39;%s\n&#39; $(cat a.txt)123456[root@Tiger data]# printf &apos;%s\t %s\t %s\t %s\n&apos; $(cat b.txt) 调整格式输出ID NAME gender mark1 liming M 862 sc M 903 cao M 83[root@Tiger data]# 在awk命令的输出中支持print和printf命令print：print会在每个输出之后自动加入一个换行符(linux 默认没有print命令)printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工换行符。 awkawk ‘条件1{动作1} 条件2{动作2}…’ 文件名条件：一般使用关系表达式作为条件x &gt; 10 判断变量x是否大于10x &gt;= 10 大于等于x &lt;= 10 小于等于动作：格式化输出流程控制语句df -h | awk &#39;{print $1 &quot;\t&quot; $5 &quot;\t&quot; $6}&#39; print 自动加入换行符 12[root@Tiger data]# df -h | grep sda3 | awk &apos;&#123;print $5&#125;&apos; | awk -F &apos;%&apos; &apos;&#123;print $1&#125;&apos;62 12[root@Tiger data]# df -h | grep sda3 | awk &apos;&#123;print $5&#125;&apos; | cut -d &quot;%&quot; -f 162 BEGIN END123456awk &apos;BEGIN &#123;printf &quot;打印这里的文字\n&quot;&#125;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&apos; a.txt打印这里的文字NAME genderliming Msc Mcao M awk &#39;{FS=&quot;:&quot;}{print $1 &quot;\t&quot; $3}&#39; /etc/passwd 这样执行的话第一条会无法分割，所以可以在awk &#39;BEGIN{FS=&quot;:&quot;}{print $1 &quot;\t&quot; $3}&#39; /etc/passwd, awk是先读取一行在再执行命令，这样文件的第一行会来不及执行默认空格换行打印出。But但是可以直接用awk -F &quot;:&quot; &#39;{print $2 &quot;\t&quot; $3}&#39; /etc/passwdawk -F &quot;:&quot; &#39;END{print &quot;所有的命令执行完以后再执行&quot;&quot;}{print $2 &quot;\t&quot; $3}&#39; /etc/passwd关系运算符12345678910[root@Tiger data]# cat b.txtID NAME gender mark1 liming M 862 sc M 903 cao M 83[root@Tiger data]# cat b.txt | grep -v NAME | awk &apos;$3 &gt;= 87 &#123;print $2&#125;&apos; limingsccao[root@Tiger data]# shell就是linux的命令解释器。在/etc/passwd当中，除了标准Shell是/bin/bash之外，还可以写如/sbin/nologin。 脚本执行： 赋予脚本权限，直接运行 chmod 755 hello.sh./hello.sh 通过bash调用执行脚本 bash hello.sh. body{ background-image:url(https://ws1.sinaimg.cn/large/005RRiqRly1fvyygdfzt6j31hc0u0138.jpg); background-position:center; background-repeat:repeat-y； }]]></content>
      <categories>
        <category>linux Document</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2018%2F08%2F28%2Flinux%20command%2F</url>
    <content type="text"><![CDATA[linux 常用命令集合: 写在前面[root@pan ~]# root:登录的用户 @分隔符 pan主机名 ~当前路径\:newline echo $PATHctrl+r:在历史命令中搜索。 ctrl+s:暂停屏幕输出。 ctrl+q:恢复屏幕输出。&quot;&amp;&quot; &quot;||&quot; &quot;!&quot;只用普通用户登录Shell是/bin/bash catcat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！-n’; 显示的时候，顺道输出行号！ -A:查询所有的内容包括隐藏字符 ls-F:在每个输出项后追加文件的类型标识符，具体含义：“*“表示具有可执行权限的普通文件“/“表示目录 “@”表示符号链接“|”表示命令管道FIFO“=”表示sockets套接字当文件为普通文件时，不输出任何标识符 echo#echo [选项][输出内容] echo -e &quot;\e[1;31m abcd \e[0m&quot; 输出颜色=30m 黑色，=31m 红色，=32m 绿色，=33m 黄色，=34m 蓝色，=35m 洋红，=36m 青色，=37m 白色。&quot;echo -e ab\bc&quot; 控制字符在末尾可能不执行。-e:支持反斜线控制的字符转换 控制字符 作用 \ 输出\本身 \a 输出警告音 \b \退格键，也就是向左删除键 \c 取消输出行末的换行符，和“-n”选项一致 \e ESCAPE键 \f 换页符 \n 换行符 \r 回车键 \t 制表符，也就是Tab键 \v 垂直制表符 \0nm 按照八进制ASCII码输出字符，其中0为数字零，nnn是三位八进制数 \xhh 按照十六进制ASCII码表输出字符。其中hh是两位十六进制数。 I/o redirection输出重定向:命令 &gt; 文件 2&gt;&amp;1 :以覆盖的方式，把正确输出和错误输出都保存在一个文件当中。命令 &amp;&gt;文件 :以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。 &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。1&gt;&amp;2 意思是把标准输出重定向到标准错误.2&gt;&amp;1 意思是把标准错误输出重定向到标&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中 输入重定向：命令 &lt;文件wc [选项] [文件名]选项： -c :统计字节数 -w :统计单词数 -l :统计行数wc &lt; filename12345678wc &lt;&lt; filename wc &lt;&lt; hello 注意hello &gt; dshi &gt; jdiosjfh &gt; diosjfiojd &gt; fdiojsoifj &gt; hello 4 4 36 sortsort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，不加参数时依次按ASCII码值进行比较，最后将他们按升序输出 -n :依照数值的从小到大排序; -r :以相反的顺序来排序; -u :忽略相同行使用-u选项或者uniq 文件名 -t &lt;分隔符&gt;：指定排序时所用的栏位分隔字符； -k 是指定需要排序的栏位（字母按ASCII排序，数字按从小到大。先数字后字母） [root@mail text]# sort -nrk 3 -t: sort.txt 将CC列数字从大到小顺序排列：eee:40:5.4eee:60:5.1ddd:20:4.2ccc:50:3.3bbb:10:2.5aaa:30:1.6AAA:BB:CC 列 awk awk &#39;{print $1}&#39; 文件名 $1第一列，$2第二列，$NF最后一列.$(NF-1)倒数第二列）。 现在是以文件的空格为分隔符这样打印 awk-F&quot;:&quot;&#39;{print $1}&#39; /etc/passwd -f指定分隔符，并打印文件第一列 多列打印#awk -F &quot;:&quot; &#39;{print $2 $3}&#39; /etc/passwd 这样打印$2 $3之间是没有分隔符 要加分隔符就是 awk -F &quot;:&quot; &#39;{print $2&quot;\t&quot;$3}&#39; /etc/passwd $0表示整个文件 df文件系统查看命令 -a:显示所有的文件系统信息信息，包括特殊文件系统，如，/proc,/sysfs -h:使用习惯单位显示容量，如KB,MB或GB等。 -T:显示文件系统类型 -m: 以MB为单位显示容量。 -k:以KB为单位显示容量，默认就是以KB为单位显示容量。 du命令和df命令的区别df:命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间(最常见的就是文件已经删除，但是程序并没有释放空间) du: 命令是面向文件的，只会计算计算机文件或目录占用的空间. du是通过搜索文件来计算每个文件的大小然后累加，du能看到的文件只是一些当前存在的，没有被删除的。他计算的大小就是当前他认为存在的所有文件大小的累加和 -h : 以K，M，G为单位，提高信息的可读性。 -s : 统计总占用量，而不列出子目录和子文件的占用量。ls -h是目录下文件名占用大小 du -h 是目录下所有文件的大小 -k : 以KB(1024bytes)为单位输出。 -m : 以MB为单位输出。 -a显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量。 dddd(磁盘对拷命令)命令用于复制文件并对原文件的内容进行转换和格式化处理 [root@localhost]# dd if=输入文件 of=输出文件 bs=字节数 count=个数选项：if=输入文件 指定源文件或源设备of=输出文件 指定目标文件或目标设备bs=字节数 指定一次输入/输出多少字节，即把这些字节看做一个数据块count=个数 指定输入/输出多少个数据块 date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000(100M) ; data。 fsck文件系统修复命令fsck [选项] 分区设备文件名 -a:不显示用户提示，自动修复文件系统 -y:自动修复。和-a作用一致，不过有些文件系统只支持-y dumpe2fs显示磁盘状态命令 #dumpe2fs 分区设备名 rpmrpm是Linux标准基础（LSB）兼容发行版所使用的一种软件包管理器，用来对软件包进行低级处理rpm可以查询、安装、检验、升级和卸载软件包，它多数用于基于Fedora的系统，比如RHEL和CentOS 只有安装和升级要加包全名。 -ivh: -i:安装，-v:显示详细信息，-h:显示进度，–nodeps：不检测依赖性。 -Uvh包全名：RPM包升级. -q :接软件包名字 #查询软件是否已经安装 -q(查询query) -qa :#查询所有已经安装的RPM包。-a(所有all) -qi :包名字#查询软件包详细信息 -i :显示软件包的相关信息 -ql 包名:查询软件包安装位置 -l :显示套件的文件列表。 -qf +系统文件名。查看一个文件是由哪个包安装的 -qip 包全名:查询未安装软件包信息，必须在软件包目录进行查询。 -qR :查询软件包的依赖性。 -qRp :查询未安装软件包的依赖性必须在Packages目录查询。 -e 包名:卸载软件。rpm -qf `which 程序名` #返回软件包的全名 已安装的软件包rpm -qif `which 程序名` #返回软件包的有关信息rpm -qlf `which 程序名` #返回软件包的文件列表 RPM校验#rpm -V 已安装的包名选项：-V 校验指定RPM包中的文件。(verify) [root@Tiger ~]#rpm -V httpdS.5….T. c /etc/httpd/conf/httpd.conf验证内容中的8个信息的具体内容如下： S：文件大小是否改变； M：文件的类型或文件的权限(r w x)是否被改变； 5：文件MD5校验和是否改变(可以看成文件的内容是否改变)； D：设备的主，从设备号是否改变； L：文件路径是否改变； U：文件的属主(所有者)是否改变； G：文件的属组是否改变； T：文件的修改时间是否改变；文件类型： c :配置文件(config file) d :普通文档(documentation) g :”鬼”文件(ghost file),很少见，就是该文件不应该被这个RPM包包含 l :授权文件(license file) r :描述文件(read me) RPM包中文件提取#rpm2cpio 包全名 | \ cpio -idv .文件绝对路径 反斜杠：换行的作用。rpm2cpio:将rpm包转换为cpio格式的命令。cpio:是一个标准工具，他用于创建软件档案文件和从档案文件中提取文件。 #cpio 选项 &lt; [文件|设备]选项： -i:copy-in模式，还原 -d:还原时自动新建目录 -v：显示还原过程 rpm -qf /bin/ls 查询ls命令属于哪个软件包mv /bin/ls /tmp 造成ls命令误删除的假象rpm2cpio /mnt/Packages/coreutils-8.4-37.el6.x86_64.rpm | cpio -idv ./bin/ls提取RPM包中ls命令到当前目录的/bin/ls下 cp /root/bin/ls /bin 把ls命令复制到/bin目录，修复文件丢失。 源码包与RPM包的区别安装在指定位置当中，一般是/usr/local/软件名/。RPM包安装的服务可以使用系统服务管理命令(service)来管理，例如RPM包安装apache的启动方法是:/etc/rc.d/init.d/httpd start: 绝对路径启动服务。service httpd start源代码保存位置：/usr/local/src/软件安装位置：/usr/local/如何确定安装过程报错：安装过程停止；并出现error、warning或no的提示。源码包安装过程：下载源码包；解压缩下载的源码包；进入解压缩目录。 CRT中sftp里面要设置远程的路径和本地的路径:cd 1 进入远程连接到的Linux的1目录lcd \text 本地的c盘text目录get abc.c 从远程目录得到文件abc.c放入本地目录textput a11.txt 从Windows上将文件a11.txt传入linux 源码包配置./configure软件配置与检查 定义需要的功能选择。 检测系统环境是否符合安装需求。 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。./configure –prefix=/usr/local/apache2安装路径详情参考INSTALL 源码包的卸载：不需要卸载命令，直接删除安装目录即可，不会遗留任何垃圾文件。 脚本安装包：脚本安装包并不是独立的软件包类型，常见安装的是源码包。是人们把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。非常类似于Windows下软件的安装方式。 yum能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。remove :删除指定的rpm软件包； yum -y remove 软件包名yum update +包名 :升级。 禁用yum grouplist:列出所有可用的软件组列表；yum groupinstall 软件组名:安装指定的软件组，组名可以由goruplist查询出来；yum groupremove:卸载指定软件组； 配置yum仓库: [base] name=centos baseurl=file:///mnt/ enabled=1 gpgcheck=0 . headhead 用来显示档案的开头至标准输出中,默认head命令打印其相应文件的开头10行 -n:显示文件的前n行 head -n 5 a.txt 显示文件的前5行 -c显示文件前n个字节 &gt;head -c 20 a.txt head -c -32 log2014.log文件的除了最后n个字节以外的内容head -n -6 log2014.log 输出文件除了最后n行的全部内容 . tail主要用来从指定点开始将文件写到标准输出。很多人喜欢使用tail -f 来监控日志文件。 -f该参数用于监视文件的增长 tail -f filename监视filename文件的尾部内容（默认10行，相当于增加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。 -n从指定行位置读取指定文件。 tail -n 20 filename 显示filename最后20行 -c显示文件最后n个字节 tail -c 20 a.txt chmod chmod命令用来变更文件或目录的权限，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件 -f :若该文件权限无法被更改也不要显示错误讯息 -R :对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)r=读取属性 值＝4 w=写入属性 值＝2 x=执行属性 值＝1 chown改变某个文件或目录的所有者和所属的组chown USER:GROUP 对象chown USER 对象 chown :group 对象 systemctlsystemctl命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起 chkconfig1.服务概述:在linux操作系统下，经常需要创建一些服务，这些服务被做成shell脚本，这些服务需要在系统启动的时候自动启动，关闭的时候自动关闭。将需要自动启动的脚本/etc/rc.d/init.d目录下，然后用命令chkconfig –add filename将自动注册开机启动和关机关闭。实质就是在rc0.d-rc6.d目录下生成一些文件连接，这些链接连接到/etc/rc.d /init.d目录下指定文件的shell脚本。 --list :列出所有系统服务 --add httpd:增加httpd服务。 --del httpd:删除httpd服务。 --list mysqld:列出mysqld服务设置情况 --level 35 mysqld on:设定mysqld在等级3和5为开机运行服务，–level 35表示操作只在等级3和5执行，on表示启动，off表示关闭。 chkconfig mysqld on:设定mysqld在各等级为on，“各等级”包括2、3、4、5等级。 chkconfig 设置是当前不生效，linux重启后才生效.service 设置是即时生效，linux关机重启后设置失效. mount查询与自动挂载(Auto Mount) mount [-l] 查询系统中已经挂载的设备，-l会显示卷标名称mount -a 依据配置文件/etc/fstab的内容，自动挂载 挂载命令格式 mount [-t 文件系统] [-L卷标名] [-o特殊选项] 设备文件名 挂载点-t 文件系统:加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统 -L 卷标名:挂载指定卷标的分区，而不是安装设备文件名挂载 -o 特殊选项:可以指定挂载的额外选项。 mount -o remount,noexec /home这里的/home是df可以查看到的分区重新挂载/home分区，并使用noexec权限 #cd /home #vi hello.sh#!/bin/bashecho “i love you”#chmod 755 #./hello.sh 会显示没有权限执行 #mount -o remount,exec /home 记得改回来，要不然会影响系统启动的。 挂载光盘mkdir /mnt/cdrom 建立挂载点mount -t iso9660 /dev/cdrom /mnt/cdrom 挂载光盘mount /dev/sr0 /mnt/cdrom 卸载光盘#umount设备文件名或挂载点umount /mnt/cdrom 挂载U盘fat32格式:fdisk -l 查看U盘设备文件名mount -t vfat /dev/sdb1 /mnt/usb/注意：fat16分区识别为fat,fat32分区识别为vft。linux默认是不支持NTFS文件系统的. NTFS u盘支持下载NTFS-3G插件https://www.tuxera.com/community/open-source-ntfs-3g/ 解压 tar -zxvf filename 安装 ./configure &amp;&amp; make &amp;&amp; make installfdisk -l查看linux的U盘分区：sdc1mount -t ntfs-3g /dev/sdc1 /mnt/usb/mkfs -t ext4 /dev/sdb1/ 格式化分区,扩展分区不可格式mkdir /disk1 建立挂载点mount /dev/sdb1 /disk1 挂载 swap新增swap空间:free查看swap大小新增一个分区，改分区号82，保存退出格式化：mkswap /dev/sdb6 加入swap分区：swapon /dev/sdb6取消swap分区：swapoff /dev/sdb6 但是每次开机都要手动挂载一遍，可以写入fatab开机自动挂载vi /etc/fstab/dev/sdb6 swap swap defaults 0 0 free显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。 -b ：以Byte为单位显示内存使用情况； -k ：以KB为单位显示内存使用情况； -m ：以MB为单位显示内存使用情况； total:去掉为硬件和操作系统保留的内存后剩余的内存总量。许多人奇怪自己的电脑安装了一共8G的内存，但是显示总共只有七点几G的，现在应该没什么疑惑了把，不管Linux还是Windows都会有部分内存是保留给硬件和操作系统的！ userd：当前已使用的内存总量。 free：空闲的或可以使用的内存总量 shared：共享内存大小，主要用于进程间通信 buff(buffers):缓冲，主要用于块设备数据缓冲(磁盘缓存大小)，例如记录文件系统的metadata（目录、权限等等信息）。是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减小了磁盘碎片和硬盘反复寻道，加速了数据的写入过程。 cache:缓存，主要用于文件内容缓冲,是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程。 available:可以使用的内存总量. Compression 压缩 commandgzipgzip filename压缩 *.gz :”后缀名”gzip -d filename.gz gunzip filename.gz 解压缩不解压查看：zcat filename.gz bz2bzip2 filename压缩 *.bzip2:”后缀名”bzip2 -k filename 保存源文件压缩bzip2 -d filename.bz2 bunzip2 filename.bz2解压缩不解压查看：bcat filename.bz2 xzxz filename压缩 .xz:”后缀名”xz -d filename.xz 解压缩unxz -k filename.xz 保存源文件解压 zipzip默认保存源文件，可以压缩目录解压：unzip FileName.zip压缩：zip FileName.zip DirName -r ：递归处理，将指定目录下的所有文件和子目录一并处理； tar-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的 tar cf file.tar files 将一个或多个文件、目录打包到tar包。tar rf file.tar file 将文件file添加到tar包中。tar uf file.tar file 将文件file更新tar包中相应的文件。tar tf file.tar 查看tar内容。tar xf file.tar 解压tar包。 -z:有gzip属性,即需要用 gzip 压缩 -j:有bz2属性,即需要用 bzip2 压缩 -v:显示处理过程 -C:指定解压输出目录 tar zxvf test.tar.gz -C test-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 -Z：有compress属性的 -O：将文件解开到标准输出 格式：tar Zcf file.tar.Z files 将一个或多个文件、目录压缩到file.tar.Z中。需要安装了ncompress软件包才行。解压.tar.Z文件。格式：tar Zxf file.tar.Z 归档并压缩：使用时间格式打包数据：tar zcf etc-$(date +%F).tar.gz /etc tar zcf etc-`date +%F`.tar.gz /etc *.tar.gz归档并调用gzip压缩 tar -zcf 新文件名.tar.gz /etc/passwd /var/log/messagages调用gzip解压缩并展开归档 tar -zxvf filename.tar.gz *.tar.bz2归档并调用bzip2压缩 tar -jcf 新文件名.tar.bz2 /etc/passwd /var/log/messages调用bzip解压缩并展开归档 tar -jxf filename.tar.bz2 locate其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。 所以你要知道： locate的速度比find快，因为它并不是真的查找文件，而是查数据库locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护升级数据库命令：locate -- u CentOS系统找不到locate命令，原因是系统中没有安装 mlocate 这个包，然后更新数据库: updatedb -c :只显示找到条目的号码 -b :匹配唯一的路径名称的基本文件名 -r :基于基本正则表达式进行匹配操作 find实时查找工具，通过遍历指定起始路径下文件系统层级结构完成文件查找： 根据文件名查找： -name “pattern” -iname “pattern” 支持glob风格的通配符: \*,?,[],[^] i忽略大小写 -regex pattern :基于正则表达式查找文件，匹配整个路径而非其名； 根据文件从属关系查找：123456-user USERNAME:查找属主指定用户的所有文件； -goup GROUPNAME:查找属组指定组的所有文件； -uid UID:查找属主指定的UID的所有文件； -gid GID:查找属组指定的GID的所有文件； -nouser :查找没有属主的文件； -nogroup :查找没有属组的文件； 根据文件的类型查找：-type TYPE :按type查找f:普通文件 d:目录 l:符号链接文件 b:块设备文件 c:字符设备文件p:管道文件 s：套接字文件 【 ./可执行文件 】组合测试：12345与：-a,默认组合逻辑而且的意思; -o 是或者的意思； -not,!：非(相反)find ./ -size -1M -a -type f#寻找当前目录下文件大于1M的文件或者是目录。find ./ -size +1M -o -type d#寻找当前目录下文件小于1M并且文件类型是一般文件的文件。 !A -a !B =!(A -o B) !A -o !B =!(A -a B) 查找tmp目录下不包含“fstab”的字符文件 find /tmp -not -iname &quot;*fstab\*&quot; 根据文件的大小查找： -size [+|-]#UNIT 常用单位：K,M,G123size 10K filename,大小表示 (#-1,#] 9K&lt;filename&lt;10K; size -10K filename,大小表示[0-UNIT-1]; size +10K filename,大小表示(#,∞); 根据时间戳查找以“天”为单位： # [#,#-1]距现在为止过去几天前访问过文件。-#:(0,#) 几天内访问过文件。+#(oo, #-1] 几天前至-oo访问过的所有文件 -atime:显示的是文件中的数据最后被访问的时间，比如系统的进程直接使用或通过一些命令和脚本间接使用。 -mtime:显示的是文件内容被修改的最后时间，比如用vi编辑就会发生改变。 -ctime:显示的是文件的权限、拥有者、所属的组、链接数发生改变时的时间。当然当内容改变时也会随之改变。以“分钟”为单位: -amin -mmin -cmin 同上 根据权限来查找 -perm [/|-]mode find ./ -perm 644mode:精确权限匹配； /mode :任何一类用户(u,g,o)的权限中的任何一位(r,w,x)符合条件即满足 9位权限之间存在“或”关系； -mode :每一类用户(u,g,o)的权限中的每一位(r,w,x)同时符合条件即满足 9位权限之间存在”与”关系；440属于/666有读的权限 find./ -perm /666 符合这一查找 处理动作：-print:输出至标准输出:默认的动作;-ls:类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息-delete:删除找到的文件-fls:/PATH/TO/SOMEFILE:把查找到的所有文件的长格式信息保存至指定文件中；-ok COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认；-exec COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令； 查找/var目录下属主为root，且属组为mail的所有文件或目录；find /var -user root -a -group mail -ls 查找/usr目录下不属于root,bin或hadoop的所有文件或目录；用两种方法find /usr -not -user root -a -not -user bin -a -not -user hadoopfind /usr -not \( -user root -o -user bin -o -user hadoop \) -ls 查找/etc目录下最近一周内其内容修改过，且属主不是root也不是hadoop用户的文件或目录；find /etc -mtime -7 -a -not -user root -a -not -user hadoopfind /etc -mtime -7 -a -not \(-user root -o -user hadoop\) -ls 查找当前系统上没有属主或属组，且最近一周内曾今被访问过的文件或目录；find ./ -nouser -o -nogroup -ls 如果有文件属于可查找项，但是加ls选项最后会无法输出显示 加了-o（或条件）和ls后只会对后一半生效。 需要find ./ \( -nouser -o -nogroup\) -atime -7 -ls 查找/etc目录下大于1M且类型为普通文件的所有文件；find /etc -size +1M -lsfind /etc -size +1M -type f -exec ls -lh {} \; 查找/etc目录下所有用户都没有写权限的文件；find /etc -not -perm /222 -type f -ls 至少有一个用户 有 查找/etc目录至少有一类用户没有执行权限的文件；find /etc -not -perm -type f -111 查找/etc/init.d目录下，所有用户都有执行权限，且其他用户有写权限的所有文件；find /etc -perm -111 -a -perm -002 -lsfind /etc -perm -113 -ls -type f historyhistory [选项][历史命令保存文件]-c:清空历史命令 -w:把缓存中的历史命令写入历史命令保存文件 ~/.bash_history 历史命令默认保存1000条，可以在环境变量配置文件/etc/profile中修改历史命令的调用： 使用上、下箭头调用以前的历史命令 使用”!n”重复执行第n条历史命令 使用”!!”重复执行上一条命令 使用”!字符串”重复执行最后一条以该字符串开头的命令。 使用ctrl+r 搜索历史命令 alias命令别名#alias 别名=&#39;原命令&#39; alias:查询命令别名。 命令执行时顺序： 第一顺位执行时用绝对路径或相对路径执行的命令。 第二顺位执行别名。 第三顺位执行Bash的内部命令。 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。让别名永久生效：vim /root/.bashrc删除别名：unalias 别名. vim:.,$y复制当前行到末尾行:! 调用系统命令，可临时执行 使vim设置永久生效:vim /etc/vimrc 把设置写到这个文件的最后，对所有账户生效set nu 显示行号 set nonu 取消行号set ic 不区分大小写 set noic 取消不区分大小写set ts=4 设置tab键长度set sw=4 设置自动缩进的tab键长度 vim /root/.vimrc 也可以把设置写到此文件，只对root生效 vim字符替换:%s/this/that 每一行的第一个this被替换成that:%s/this/that/g 将文本中所有的this替换成that %从每一行的开头到结尾 s表示替换:1,5 s/old/new/g #替换第一行到第5行中所有匹配的内容. 字符操作u撤销上一步i当前插入，I行首插入。a当前字符插入(光标后一位插入)，A行尾插入。o表示：本行回车到下一行插入，O上一行插入。x删除光标所在字符，X向前删除一个字符。dd删除光标所在的行，dG删除光标所在开始行到文件尾的所有字符。J合并两行。行操作：home 键或^键行首，$或end行尾dd删除一行Ndd(删除本行与下一行)。yy复制一行，Nyy复制n行，p将复制行粘贴，p向光标下一行粘。(N表示数字) 词操作:dw删除一个词，y+$复制至行尾。y+^复制至行首。yw复制一个词。:.,$y 复制当前行到末尾 v模式:编程的时候需要进行多行注释： （删除是要将光标移到这个词的行首，如果光标不在行首则删除光标之后的字母。）块操作：D或d+$删除至行尾 d+^删除至行首1、注释：ctrl+v进入列编辑模式2、向下或向上移动光标 （ctrl L 向下全部选中）3、把需要注释的行开头的开头标记起来4、然后按大写的I5、再插入注释符，比如“#”6、再按Esc，就会全部注释了删除多行注释：按ctrl+v进入列编辑模式;向下或向上移动光标；选中注释部 分然后按d,就会删除注释符号。 vim编辑器： :wq 可以保存外 :w +路径+文件名直接保存在某个位置和重命名:w 路径/文件名ZZ 保存退出 :x 保存退出 :!命令:!ifconfigvi的行定位功能:ctrl+f 向前卷动一个屏幕ctrl+b 向后卷动一个屏幕G 到文件最后一行行首:$ 到文件最后一行行尾mG 到指定行，m为目标行数 或者mggset nu 显示行号/内容 查找指定内容n 查找下一个N 回到前一个？ 寻找上一个 /^字符串 查找以字符串开始的行/字符串$ 查找以字符串结尾的行/a.b 查找字符串a任意字符b vim替换r 替换当前光标字符:r 文件名 在光标当前位置载入另一个文件. useradduseradd命令用来建立用户帐号和创建用户的起始目录，使用权限是终极用户. -u :uid指定用户ID -d:指定用户登入时的启始目录。 -g:指定用户所属的群组 -G:指定用户所属的附加群组。tom 用户的登陆 shell 为非交互式 shell useradd –s /sbin/nologin tom -e :指定账号的有效期限，缺省表示永久有效 useradd user1——创建用户user1;useradd –e 12/30/2009 user2——创建user2,指定有效期2009-12-30到期 -c:用户说明，手工指定用户的说明，添加说明有Spacebar时要加“ “。 用户默认值文件：/etc/defalut/useradd1.GROUP=100 :用户默认组ID (公有模式)2.HOME=/home :用户家目录3.INACTIVE=-1 :密码过期宽限天数(shadow文件7字段)4.EXPIRE=no value :密码失效时间(8字段)5.SHELL=/bin/bash :默认的shell6.SKEL=/etc/skel :模板目录7.CREATE_MAIL_SPOOL=yes :是否建立邮箱 /etc/login.defsPASS_MAX_DAYS 999 :密码有效期(5字段)PASS_MIN_DAYS 0 :密码修改间隔(4字段)PASS_MIN_LEN 5 :密码最小5位(PAM)PASS_WARN_AGE 7 :密码到期警告(6)UID_MIN 500 :最小和最大UID范围GID_MIX 60000ENCRYPT_METHOD SHA512 :加密模式. userdel删除用户userdel [-r] 用户名 -r:删除用户的同时删除用户家目录 id查看用户id：#id 用户名查询用户的UID,初始组ID,附加群组ID usermodusermod命令用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user id，必须确认这名user没在电脑上执行任何程序. -g &lt;群组&gt; 修改用户所属的原始群组。usermod -g root username -G &lt;群组&gt; 修改户所属的附加群组 -a -G 无限增加到附加组，可拥有多个附加组.将a1添加附加组user3 usermod -a -G user3 a1-c:修改用户的说明usermod -c &quot;test user&quot; username 当某一用户拥有多个附加组之后，使用usemod -G会修改附加组，则多个组消失掉变成唯一当前修改的附加组1.将 newuser2 添加到附加组 staff usermod -G staff newuser2 -l &lt;帐号名称&gt; 修改用户帐号名称。2.修改 newuser 的用户名为 newuser1 usermod -l newuser1 newuser-L 锁定用户密码，使密码无效。 -U 解除密码锁定。3.锁定账号 newuser1 usermod -L newuser14.解除对 newuser1 的锁定 usermod -U newuser1 -d 改变用户家目录,常与-m结合使用 -m 将主目录的内容移动到新目录usermod -m -d /home/user2 -uid username若使用报错使用以下命令：cat /dev/null &gt; /var/run/utmp 清空此文件。utmp是一个文件，除了utmp程序你不能编辑这个文件，删掉他的话，当前登陆信息都会丢失。它就好比系统开启后它会把系统成员的信息迅速的记录下来，过一段时间它就不再记录，确认系统的用户配置就是这样了，这个文件在每次机器reboot起来后都会重新创建。. groupadd-g GID: 修改组ID -n 新组名: 修改组名 susu: [选项] 用户名 -:选项只使用”-“代表连带用户的环境变量一起切换。可使用env命令查看-c:仅执行一次命令，而不切换用户身份su - root -c &quot;useradd user3&quot;不切换成root,但是执行useradd命令添加user1用户。 chage修改用户密码状态chagechage [选项] 用户名 -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期(shadow3字段) -m 天数:两次密码修改间隔(4字段) -M 天数:密码有效期(5字段) -W 天数:密码过期前警告天数(7字段) -I 天数:密码过后宽限天数(7字段) -E 日期:账号失效时间(8字段)chage -d 0 username这个命令其实是把密码修改日期归0了(shadow第3字段)，这样用户只要一登录就要修改密码。第三字段是指密码最后一次修改时间的日期。1970年1月1号到现在修改密码的时间戳。如果第3字段改为0，系统会认为用户没有修改过操作密码，那么当此用户一旦登录系统就会提示要修改密码，才可正常使用。. passwd-S:查询用户密码的密码状态，仅root用户可用。 -l:暂时锁定用户。仅root用户可用。 -u:解锁用户。仅root用户可用。 –stdin:可以通过管道符输出的数据作为用户的密码。echo &quot;123&quot; | passwd --stdin user gpasswd -d :从组删除用户 gpasswd -d username groupadd -a :添加用户到组(附加组),同时保留以前的组 添加用户到某一个组可以使用 usermod -G groupB userA 这个命令可以添加一个用户到指定的组，但是以前添加的组就会清空掉.所以想要添加一个用户到一个组，同时保留以前添加的组时，请使用gpasswd这个命令来添加操作用户 -A :指定组内管理员 gpasswd -A username groupname groups groups username 显示linux用户所属的组 datedate 根据给定格式显示日期或设置系统日期时间。print or set the system date and time 指令所在路径：/bin/date date &quot;+%Y-%m-%d %H:%M:%S&quot; -d:显示字符串所指的日期与时间。字符串前后必须加上双引号123date -d now date -d &apos;next monday&apos; date -d yesterday +%Y-%m-%d -r:显示文件最后修改时间 -s:设置系统时间 date -s &quot;2018-11-11 00 00 00&quot; 在使用date -s这个命令修改时间后，系统重启后就失效了，因此为了将这个时间永久生效，需要将修改的时间写入CMOS，查看CMOS的时间:clock –r将当前系统时间写入CMOS中去clock –w 在生产环境中常使用时间格式打包数据：tar zcvf etc-$(date +%F).tar.gz /etctar zcvf etc-`date +%F`.tar.gz /etc date:2018/9/23 hwclock查看硬件时间设置硬件时间hwclock --set --date=&quot;07/07/06 10:19&quot; （月/日/年 时:分:秒）硬件时间和系统时间的同步：重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需要用hwclock命令实现同步。硬件时钟与系统时钟同步：hwclock --hctosys（hc代表硬件时间，sys代表系统时间）系统时钟和硬件时钟同步:（让系统的时间同步到硬件时钟)hwclock –-systohc. lnln：链接命令硬链接：复制并同步 ln /etc/passwd /tmp/password 软链接：类似windows下的快捷方式 ln -s /etc/passwd /tmp password软链接和硬链接的区别:1.创建命令不同:ln -s /root/ruan.txt /root/桌面/ ln /root/ying.txt /root/桌面/2.软链接创建时必须使用绝对路径(链接和源文件在同一目录下,可以相对路径)硬链接创建时可以绝对路径也可相对路径3.软链接的源文件不可以剪切,重命名,删除 硬链接的源文件可以剪切,重命名,删除4.软链接的链接文件权限永远是777，即使将链接文件的权限进行了修改，也不会发生变化，变得是源文件的权限 硬链接的链接文件权限永远和源文件相同5.软链接的链接文件的inode号和源文件不同硬链接的链接文件的inode号和源文件相同6.软链接可以对目录操作硬链接不支持对目录操作，是针对于上层来说，底层是可以针对于目录做硬链接的，通过代码就可以实现7.软链接可以跨文件系统硬链接不可以跨文件系统，因为硬链接是存放在源文件的同一个block上面的 SElinux安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则） DAChttp://blog.51cto.com/zhaotianyu/1795178：在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：某个资源是否拥有对应用户的权限（读、写、执行）。只要访问这个资源的进程符合以上的条件就可以被访问。而最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问。这种权限管理机制的主体是用户，也称为自主访问控制（DAC）。 MAChttp://baijiahao.baidu.com/s?id=1590170088632157084&amp;wfr=spider&amp;for=pc：在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限。这样一来，即使进程是以 root 身份运行的，也需要判断这个进程的类型以及允许访问的资源类型才能决定是否允许访问某个资源。进程的活动空间也可以被压缩到最小。即使是以 root 身份运行的服务进程，一般也只能访问到它所需要的资源。即使程序出了漏洞，影响范围也只有在其允许访问的资源范围内。安全性大大增加。这种权限管理机制的主体是进程，也称为强制访问控制（MAC）。getenforce命令是单词get（获取）和enforce(执行)连写，可查看selinux状态setenforce 命令则是单词set（设置）和enforce(执行)连写，用于设置selinux防火墙状态，如： setenforce 0用于关闭selinux防火墙，但重启后失效。 SELinux status：selinux防火墙的状态，enabled表示启用selinux防火墙关闭SElinux:临时关闭 :setenforce 0用于关闭selinux防火墙，但重启后失效永久关闭：修改selinux的配置文件：vim /etc/selinux/config将SELINUX=enforcing改为SELINUX=disabled，保存后退出，此时获取当前selinux防火墙的安全策略仍为Enforcing，配置文件并未生效。重启后验证。SELinux 有三种工作模式，分别是：1.enforcing：强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中。2.permissive：宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用。3.disabled：关闭 SELinux crontab1.Crontab是一个用于设置周期性执行任务的工具；2.周期性执行的任务我们称为Cron Job；3.周期性执行的任务列表我们称为Cron Tablecrontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下: * * * * * command minute hour day month week command 顺序:分 时 日 月 周 minute： 表示分钟，可以是从0到59之间的任何整数。hour：表示小时，可以是从0到23之间的任何整数。day：表示日期，可以是从1到31之间的任何整数。month：表示月份，可以是从1到12之间的任何整数。week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件 -u:编辑某个用户的cron，只用root可以使用此参数为别的用户设置cron服务。也可用于给用户指定crontab文件。 -l: 列出当前用户的crontab。 -r: 删除当前用户的crontab。 -e: 编辑当前用户的crontab，默认使用vi，或者是由 VISUAL或EDITOR环境变量指定的编辑器。 -i与-r 一起使用，用来询问用户是否直接删除crontab安装cronyum install vixie-cronyum install crontabs检查crontab工具是否安装：crontab -l检查crond服务是否启动：service crond status检查crontab服务状态：service crond status 每晚的21:30重启apache30 21 * * * service httpd restart 每月1,10,22日的4:45重启apache45 4 1,10,22 * * service httpd restart 每月1-10日的4:45重启apache45 4 1-10 * * service httpd restart 每天18:00-23:00之间每隔30分钟重启apache0,30 18-23 * * * service httpd restart0-59/30 18-23 * * * service httpd restart 每晚11-早上7点之间，每隔一个小时重启apache* 23-7/1 * * * service httpd restart 每隔两分钟重启apache 123*/2 * * * * service httpd restart 1-59/2 * * * * service httpd restart(奇数分钟重启) 0-58/2 * * * * service httpd restart(偶数分钟重启) 小结：*表示任何时候都匹配；可以用”A,B,C”表示A或者B或者C时执行命令可以用”A-B”表示A到B之间时执行命令可以用”*/A”表示每A分钟(小时等)执行一次命令 */1 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP时间同步: fdiskfdisk命令操作磁盘详解–添加、删除、转换分区等主分区和扩展分区(扩展分区不能直接使用)(1-4),扩展分区下面再分逻辑分区(5开始)。 fdisk /dev/sda 分区保存报错需要重启时，强制读取分区表信息#partprobeyum install -y parted grepgrep [选项] “搜索内容” 文件名 -i 忽略大小写 -n 输出行号 -v 反向查找 --color=auto把搜索出的关键字用颜色显示]]></content>
      <categories>
        <category>Linux command</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
