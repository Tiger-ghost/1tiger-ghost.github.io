<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[技巧集合]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[linux 小技巧 simple command123456789101112131415uname -a # 查看Linux内核版本信息cat /proc/version # 查看内核版本cat /etc/issue # 查看系统版本lsb_release -a # 查看系统版本 需安装 centos-releaselocale -a # 列出所有语系locale # 当前环境变量中所有编码hwclock # 查看时间who # 当前在线用户w # 当前在线用户whoami # 查看当前用户名logname # 查看初始登陆用户名uptime # 查看服务器启动时间sar -n DEV 1 10 # 查看网卡网速流量dmesg # 显示开机信息lsmod # 查看内核模块 Descriptionsedsed 执行系统命令。查找当前目录以及子目录中以 “.sh”,并改为以”.shell”结尾。find ./a -type f -regex &quot;.*/.sh$&quot; | sed -r -n &#39;s#(.*\.)sh$#mv &amp; \1shell#e&#39; -regex: 使用正则表达式&quot;.*/.sh$&quot; 给出的正则表达式必须要匹配完整的文件路径,比如：find / -regex &quot;find&quot; 这样子是找不到/usr/bin/find的，要像这样find / -regex &quot;.*find&quot;或者更精确一点find / -regex &quot;.*/find&quot; &amp;: 匹配前面找到的内容 e: 末尾的e表示# #这里允许执行命令然后得到结果#,也就是mv 前面匹配到的.sh文件 任意内容.shell Bash中${}的用法和变量的间接引用1234$&#123;STR^^&#125;, 把STR中的所有小写字母转换为大写输出(不改变值)[root@junun ~]# str=abcde[root@junun ~]# echo $&#123;str^^&#125;ABCDE 1234$&#123;STR,,&#125;, 把STR中的所有大写字母转换为小写输出(不改变值)[root@junun ~]# str1=ABCDE[root@junun ~]# echo $&#123;str1,,&#125;abcde]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ghost]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[As long as it starts it will not end！ body{ background-image:url(https://ws1.sinaimg.cn/large/005RRiqRly1fvw1bz9he2j33dc28w4qu.jpg); background-position:center; background-repeat:repeat-y； } 魔术剪辑届 “巫男” 的创意新作《魔术》本文作分享，请勿用于商业用途。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[style]]></title>
    <url>%2F2018%2F08%2F28%2F%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文章写作样式 样式且不问结果如何，尽自己之所能，积极的面对。Content (md partial supported) 站点配置文件 主题配置文件 站点配置文件 主题配置文件 Download Now 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 点击访问博客 居中引用 1.数字块定义 5.命令历史相关环境变量 本文旨在介绍样式的使用规则。 本文旨在介绍样式的使用规则。 本文旨在介绍样式的使用规则。 GA17 YouTube ghost.me I heard the echo, from the valleys and the heartOpen to the lonely soul of sickle harvestingRepeat outrightly, but also repeat the well-being ofEventually swaying in the desert oasisI believe I amBorn as the bright summer flowersDo not withered undefeated fiery demon ruleHeart rate and breathing to bear the load of the cumbersomeBored GA17 1GA17 2GA17 3GA17 4你是谁，你来自哪里我是一个怪物，来自我也不知道的地方f你觉得你死了，还有有人记得你吗]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[two]]></title>
    <url>%2F2018%2F08%2F28%2F%E9%A9%AC%E5%93%A5%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[linux 培训文档 uptime08:21:34 up 36 min, 2 users, load average: 0.00, 0.00, 0.00当前服务器时间： 08:21:34当前服务器运行时长 36 min当前用户数 2 users当前的负载均衡 load average 0.00, 0.00, 0.00，分别取1min,5min,15min的均值 分区两种分区方式：MBR，GPTMBR: Master Boot Record，1982年，使用32位表示扇区数，分区不超过2T如何分区：按柱面0磁道0扇区：512bytes 446bytes: boot loader 64bytes：分区表，其中每16bytes标识一个分区 2bytes: 55AA4个主分区；3主分区+1扩展(N个逻辑分区)dos代表MBR分区 管理分区列出块设备• lsblk创建分区使用：• fdisk 创建MBR分区• gdisk 创建GPT分区• parted 高级分区操作重新设置内存中的内核分区表版本也就是同步分区表• partprobe或者：ls /dev/sdb* , cat /proc/partitionsblkid /dev/sdb1 查看分区的文件格式和UUID,也可以不跟分区 同步分区表查看内核是否已经识别新的分区cat /proc/partationscentos6通知内核重新读取硬盘分区表新增分区用partx -a /dev/DEVICE kpartx -a /dev/DEVICE -f: force删除分区用partx -d –nr M-N /dev/DEVICECentOS 5，7: 使用partprobe partprobe [/dev/DEVICE] centos6: partx -a /dev/sda -a增加partx -d –nr 6 /dev/sda -d删除第6个分区 Linux不重启识别硬盘123[root@centos6 ~]# echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host0/scan [root@centos6 ~]# echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host1/scan [root@centos6 ~]# echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host2/scan parted分区命令parted的操作都是实时生效的，小心使用用法：parted [选项]… [设备 [命令 [参数]…]…] parted /dev/sdb mklabel gpt|msdos parted /dev/sdb print parted /dev/sdb mkpart primary 1 200 （默认M） parted /dev/sdb rm 1 parted –l 列出分区信息 创建文件系统mkfs命令：(1) mkfs.FS_TYPE /dev/DEVICE ext4xfs btrfs vfat(2) mkfs -t FS_TYPE /dev/DEVICE-L ‘LABEL’ 设定卷标 创建ext文件系统mke2fs：ext系列文件系统专用管理工具-t {ext2|ext3|ext4} 指定文件系统类型-b {1024|2048|4096} 指定块大小-L ‘LABEL’ 设置卷标-j 相当于 -t ext3mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3-i # 为数据空间中每多少个字节创建一个inode；不应该小于block大小-N # 指定分区中创建多少个inode-I 一个inode记录占用的磁盘空间大小，128—4096-m # 默认5%,为管理人员预留空间占总空间的百分比-O FEATURE[,…] 启用指定特性-O ^FEATURE 关闭指定特性 文件系统标签指向设备的另一种方法与设备无关blkid：块设备属性信息查看 blkid [OPTION]… [DEVICE]-U UUID 根据指定的UUID来查找对应的设备-L LABEL 根据指定的LABEL来查找对应的设备e2label：管理ext系列文件系统的LABEL e2label DEVICE [LABEL]findfs ：查找分区findfs [options] LABEL= tune2fstune2fs：重新设定ext系列文件系统可调整参数的值 -l 查看指定文件系统超级块信息；super block -L ‘LABEL‘ 修改卷标 -m # 修预留给管理员的空间百分比 -j 将ext2升级为ext3 -O 文件系统属性启用或禁用, –O ^has_journal -o 调整文件系统的默认挂载选项，–o ^acl -U UUID 修改UUID号dumpe2fs： 块分组管理，32768块 -h：查看超级块信息，不显示分组信息tune2fs -l /dev/sdb1 查看ext文件系统的工具不支持xfs格式Filesystem features: ext_attr resize_inode dir_index filetype sparse_super large_file 这里没有日志功能，如果有会有journal表示日志Reserved block count: 13107 保留块，默认5% Block count: 262144 Reserved block count: 13107 就用13107/262144 大约5% tune2fs -o has_journal /dev/sdb1 加入日志功能tune2fs -o ^acl /dev/sdb1 取消acl权限tune2fs -o +acl /dev/sdb1 加入acl权限 只查询UUID是哪一个分区 1[root@centos7 ~]# blkid -U `sed -r-n &apos;s#^UUID=(.*) / .*#\1#p&apos; /etc/fstab` /dev/sda2 e2label -L /mnt/sdb1 /dev/sdb1 加入卷标:/mnt/sdb1,查看卷标：blkid,e2label 用mount命令挂载文件系统 挂载方法：mount DEVICE MOUNT_POINTmount：通过查看/etc/mtab文件显示当前已挂载的所有设备mount [-fnrsvw] [-t vfstype] [-o options] device dir device：指明要挂载的设备； (1) 设备文件：例如/dev/sda5 (2) 卷标：-L ‘LABEL’, 例如 -L ‘MYDATA’ (3) UUID, -U ‘UUID’：例如 -U ‘0c50523c-43f1-45e7-85c0-a126711d406e’ (4) 伪文件系统名称：proc, sysfs, devtmpfs, configfs dir：挂载点 事先存在；建议使用空目录 进程正在使用中的设备无法被卸载补充：用UUID形式挂载目录mount -U UUID /mnt/sdb1查看某个目录是否有人使用：lsof /data 或者fuser -v /bootfuser -km /mnt/sdb1 此命令将把使用此目录的人全部杀掉，退出终端。 mount常用命令选项-t vsftype指定要挂载的设备上的文件系统类型-r readonly，只读挂载-w read and write, 读写挂载-n 不更新/etc/mtab，mount不可见。可查看这个文件，看的非常全cat /proc/mounts-a 自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中，且挂载选项中有auto功能)-L ‘LABEL’以卷标指定挂载设备-U ‘UUID’以UUID指定要挂载的设备-B, –bind 绑定目录到另一个目录上mount /boot /mnt/boot --bind 目录挂目录查看内核追踪到的已挂载的所有设备 cat /proc/mounts -o options：(挂载文件系统的选项)，多个选项使用逗号分隔 async 异步模式sync 同步模式,内存更改时，同时写磁盘atime/noatime 包含目录和文件diratime/nodiratime 目录的访问时间戳auto/noauto 是否支持自动挂载,是否支持-a选项exec/noexec 是否支持将文件系统上运行应用程序mount -o noexec /dev/sdb1 /mnt/sdb1 此时可执行权限不可执行mount -o remount,exec /mnt/sdb1 恢复执行mount -o remount,acl /mnt/sdb1 加入acl权限dev/nodev 是否支持在此文件系统上使用设备文件suid/nosuid 是否支持suid和sgid权限remount 重新挂载ro只读 rw读写user/nouser 是否允许普通用户挂载此设备，/etc/fstab使用acl 启用此文件系统上的acl功能loop 使用loop设备用文件作为 文件系统 然后可以实现挂载 centos6要加mount -o -loop /data/ext4file /mnt/ext4 centos 6上面默认只有lop0-lop7,需要更多的就必须修改内核参数：在kernel 这行加上max_loop=100defaults：相当于rw, suid, dev, exec, auto, nouser, async 卸载命令查看挂载情况， findmnt MOUNT_POINT|devicefindmnt /mnt 查看文件夹是否为挂载点查看正在访问指定文件系统的进程 lsof MOUNT_POINT fuser -km MOUNT_POINT终止所有在正访问指定的文件系统的进程卸载 umount DEVICE umount MOUNT_POINT 挂载点和/etc/fstab配置文件系统体系被mount、fsck和其它程序使用系统重启时保留文件系统体系可以在设备栏使用文件系统卷标使用mount -a 命令挂载/etc/fstab中的所有文件系统cat /var/log/boot.log 查看内核启动日志 swapswap分区改完相对应的文件系统83以后，mkswap /dev/sdd1然后加到/etc/fstabswapon -s查看当前生效的swap设备swapon -a 让swap设备生效 最后一个表示优先级，数值越大优先级越高，可在/etc/fatab 修改优先级default 这个位置，替换掉pri=10swapoff /dev/sdb4 禁用后启用swapon -a 才生效: 自动启动所有SWAP装置 用文件来当做swap分区dd if=/dev/zero of=/swapfile bs=2G count=1mkswap /swapfileblkid /swapfileswapon -s :-s | –summary 按设备显示交换用途摘要，等价于cat /proc/swaps 如果要移动这个swap文件,要先禁用swapoff /swapfile查看swapon -s移动：mv /swapfile /data/swapon -p 5 /data/swapfile 设置优先级要先禁用swapoff 将文件制作成iso文件，注意iso文件是只读的。mkisofs -r -o /data/etc.iso /etc/ 交换分区是系统RAM的补充基本设置包括 创建交换分区或者文件 使用mkswap写入特殊签名 在/etc/fstab文件中添加适当的条目 使用swapon -a 激活交换空间挂载交换分区 启用：swapon swapon [OPTION]… [DEVICE] -a：激活所有的交换分区 -p PRIORITY：指定优先级 /etc/fstab:pri=value 禁用：swapoff [OPTION]… [DEVICE] 文件系统空间占用等信息的查看工具：df [OPTION]… [FILE]… -H 以1000为单位 -T 文件系统类型 -h: human-readable -i：inodes instead of blocks -P: 以Posix兼容的格式输出查看某目录总体空间占用状态: du [OPTION]… DIR -h: human-readable -s: summary –max-depth 工具dd dd命令：convert and copy a file用法：dd if=/PATH/FROM/SRC of=/PATH/TO/DESTbs=#：block size, 复制单元大小count=#：复制多少个bsof=file 写到所命名的文件而不是到标准输出if=file 从所命名文件读取而不是从标准输入bs=size 指定块大小（既是是ibs也是obs)ibs=size 一次读size个byteobs=size 一次写size个bytecbs=size 一次转化size个byteskip=blocks 从开头忽略blocks个ibs大小的块 seek=blocks 从开头忽略blocks个obs大小的块count=n 只拷贝n个记录 工具ddconv=conversion[,conversion…] 用指定的参数转换文件转换参数:ascii 转换 EBCDIC 为 ASCIIebcdic 转换 ASCII 为 EBCDIClcase 把大写字符转换为小写字符ucase 把小写字符转换为大写字符dd if=/etc/fstab conv=ucasenocreat 不创建输出文件noerror 出错时不停止notrunc 不截短输出文件sync 把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐Fdatasync 写完成前，物理写入输出文件 skip=3 跳过原文件的前三个读2个seek=跳过f1四个123456789[root@centos7 text]# cat f1;cat f2abcefghi123456[root@centos7 text]# dd if=f2 of=f1 bs=1 count=2 skip=3 seek=42+0 records in2+0 records out2 bytes (2 B) copied, 0.000231085 s, 8.7 kB/s[root@centos7 text]# cat f1abce45[root@centos7 text]# 12345678910[root@centos7 text]# cat f1;cat f2abcefghi123456[root@centos7 text]# dd if=f2 of=f1 bs=1 count=2 skip=3 seek=4 conv=notrunc2+0 records in2+0 records out2 bytes (2 B) copied, 0.000266614 s, 7.5 kB/s[root@centos7 text]# cat f1abce45hi[root@centos7 text]# 工具dd备份MBRdd if=/dev/sda of=/tmp/mbr.bak bs=512 count=1破坏MBR中的bootloaderdd if=/dev/zero of=/dev/sda bs=64 count=1 seek=446有一个大与2K的二进制文件fileA。现在想从第64个字节位置开始读取，需要读取的大小是128Byts。又有fileB, 想把上面读取到的128Bytes写到第32个字节开始的位置，替换128Bytes，实现如下dd if=fileA of=fileB bs=1 count=128 skip=63 seek=31 conv=notrunc 备份：dd if=/dev/sdx of=/dev/sdy将本地的/dev/sdx整盘备份到/dev/sdydd if=/dev/sdx of=/path/to/image将/dev/sdx全盘数据备份到指定路径的image文件dd if=/dev/sdx | gzip &gt;/path/to/image.gz 备份/dev/sdx全盘数据，并利用gzip压缩，保存到指定路径 恢复：dd if=/path/to/image of=/dev/sdx将备份文件恢复到指定盘gzip -dc /path/to/image.gz | dd of=/dev/sdx将压缩的备份文件恢复到指定盘 拷贝内存资料到硬盘 dd if=/dev/mem of=/root/mem.bin bs=1024 将内存里的数据拷贝到root目录下的mem.bin文件 从光盘拷贝iso镜像 dd if=/dev/cdrom of=/root/cd.iso 拷贝光盘数据到root文件夹下，并保存为cd.iso文件 销毁磁盘数据 dd if=/dev/urandom of=/dev/sda1 利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据，执行此操作以后，/dev/sda1将无法挂载，创建和拷贝操作无法执行 破坏分区dd if=/dev/zero of=/dev/sdc bs=1 count=512 lsblk同步partx -d --nr 1-2 /dev/sdb 删除/dev/sdb 1和2分区 raid比如四个硬盘做raid5每个1G容量，可用的最后只有2G 2/3的利用率就是2G lvm网咯七层模型applicationpersentionsessiontransportnetworkdata linkphysical 集线器 物理层交换机 数据链路路由器 网络层 IP地址IP地址由两部分组成: 网络ID:标识网络 每个网段分配一个网络ID 主机ID:标识单个主机 由组织分配给各个设备 公式：一个网络中主机最大数=2^主机ID位数(32-网络ID位数)-2=2^(32-网络ID位数)-2网络数=2^可变网络ID位 A1-126.X.Y.Z1600万网络ID位为高8位，主机ID位为24 可变网络位2^7=128-2=1260xxxxxxx.X.Y.Z00000000 001111111 127B128-191.x.y.z网络ID位为高16位，主机ID位为16 可变网络位2^1410xxxxxx.X.Y.Z10000000. 12810111111. 19165534C192-223.x.y.z网络ID位为高24位，主机ID位为8110xxxxx.x.y.z11000000 19211011111 223254 无类域间路由CIDR:网络id位数不确定254 252 248 242 224 192 128netmask子网掩码: 32bit 二进制,对应于网络ID位为1，对应于主机ID位为0255.255.224.0 主机数：2^13-2 网络ID相同就是在同一个网络, 网络ID就是IP地址和本地的子网掩码进行与计算得到的值，是与本机的子网掩码进行的与运算，因为查看与本机的网络是否相同。重点记住与本机的掩码进行的与运算。有坑 CIDR表示法: IP/网络ID位数 10.0.0.100/19 255.255.224.0 有19个112345题目：203.110.200.199/22 1 主机数?1022 2^(32-22)-22 netmask?255.255.252.03 网络ID值? 11111111 11111111 11111100 00000000 /22二进制表示255.255.252.0 网络ID值203.110.200.199:二进制。网络ID为前22位，主机ID位后10位12311001011 01101110 110010 00 11000111 203.110.200.19911111111 11111111 111111 00 00000000 255.255.252.011001011 01101110 110010 00 00000000 203.110.200.0/22 网络ID具体值=IP 与运算 子网掩码192.168.34.6255.255.255.0192.168.34.0/24 题目：求 100.123.199.124/20主机数：01100100 01010011 1100 0111 01111100 ip二进制11111111 11111111 1111 0000 00000000 /202^12-2=4096-2=4064子网掩码：255.255.240.0网络ID：100.123.192.0/20 1100 0111 1111 000001100100 10000100 1100 0000 00000000100.123.192.0/20最小和最大IP：100.123.192.1 ➜ 100.123.207.254通过网络ID 100.123.192.0/20,又前20位为网络位，所以只能是后面的从小到大100.123.1100 0000.00000001 ➜ 100.123.192.1100.123.1100 1111.11111110 ➜ 100.123.207.254 划分子网一个子网划分成多少个小网。网络ID位变多，主机ID位才变少，网络ID向主机ID借位。分成2^N个小子网10.0.0.1–10.255.255.254划分两个子网10.00 000000.0.0 10.00 000000.0.0 10.0.0.0/1010.01 000000.0.0 10.64.0.0/1010.10 000000.0.0 10.128.0.0/1010.11 000000.0.0 10.192.0.0/10 题目:10.0.0.0/8 给32省份划分各自子网1.子网子网掩码 255.248.0.02.最小子网，最大子网的网络ID3.每个子网主机数？2^19-24.第20个子网分给河南使用，最小ip，最大IP范围? 10.152.0.1 ➜ 10.159.255.254 1. 根据公式2^n=子网数 2^n=32 也就是借5位 8+5=13 网络位是13掩码: 255.11111000.0.0 ➜ 255.248.0.02. 10.00000 000.0.0 10.0.0.0/13 10.11111 000.0.0 10.248.0.0/133. 主机数: 2^(32-13)-2=4. 0表示第一个子网，那么19就表示第20个子网10.10011 000.0.1 ➜ 10.152.0.110.10011 111.255.254 ➜ 10.159.255.254 题目:河南省10.152.0.0/13 给15个市，划分各自子网1. 子网子网掩码：2^n&gt;=15 n&gt;=4 13+4=17位11111111.11111111.1 0000000.00000000255.255.128.02. 最小子网，最大子网的网络ID:原：10.10011 000.0.0 10.152.0.0/13现：10.10011 000.0 .0 借了4位 10.10011 000.00000000.0 ➜ 10.152.0.0/17 10.10011 111.10000000.0 ➜ 10.159.128.0/173. 每个子网主机数？2^(32-17)-24. 最大子网的最小IP,最大IP范围10.10011 111.10000000.0 最大子网10.10011 111.1 0000000.1 ➜ 10.159.128.110.10011 111.1 1111111.254 ➜ 10.159.255.254 合并超网多个小网合并成一个大网，主机ID向网络ID借位220.78.10101 000.0220.78.10101 001.0220.78.10101 111.0这几个IP前面都一样直接写 220.78.168.0/21route -n 查看路由表 路由表: 目标网络ID:目标网络所在网络ID 接口:本设备要发送数据包到目标，从哪个接口发送出来，才能到达 网关:到达目标网络，需要将数据交给下一个路口哪个接口的对应IP路由的分类优先级排列： 主机路由 网络路由 默认路由优先级:精度越高，优先级越高. DNS解析优先级： vim /etc/nsswitch.conf 网络基本配置CentOS 6网卡名称接口命名方式：CentOS 6 以太网：eth[0,1,2,…] ppp：ppp[0,1,2,…] 网络接口识别并命名相关的udev配置文件：/etc/udev/rules.d/70-persistent-net.rules 查看网卡：dmesg |grep –i ethethtool -i eth0 卸载网卡驱动：modprobe -r e1000 rmmod e1000 装载网卡驱动：modprobe e1000 route命令 路由管理命令 查看：route -n 添加：route addroute add [-net|-host] target [netmask Nm] [gw Gw] [[dev] If] 目标：192.168.1.3 网关：172.16.0.1route add -host 192.168.1.3 gw 172.16.0.1 dev eth0 目标：192.168.0.0 网关：172.16.0.1route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 dev eth0route add -net 192.168.0.0/24 gw 172.16.0.1 dev eth0 route命令 默认路由，网关：172.16.0.1route add -net 0.0.0.0 netmask 0.0.0.0 gw 172.16.0.1route add default gw 172.16.0.1 删除：route delroute del [-net|-host] target [gw Gw] [netmask Nm] [[dev] If] 目标：192.168.1.3 网关：172.16.0.1route del -host 192.168.1.3 目标：192.168.0.0 网关：172.16.0.1route del -net 192.168.0.0 netmask 255.255.255.0 netstat -ntau | sed -nr &#39;/^tcp/s/.* ([^ ]+) ?/\1/p&#39; | sort | unip -c ip设置网卡状态ip link set eth1 downip link set eth1 upip addr add 1.1.1.1/24 dev ens37ip addr del 1.1.1.1/24 dev ens37ip addr flush dev eth1 清空地址 ip route - routing table management添加路由：ip route addip route add TARGET via GW dev IFACE src SOURCE_IP TARGET:主机路由：IP网络路由：NETWORK/MASKip route add 192.168.0.0/24 via 172.16.0.1 ip route add 192.168.1.13 via 172.16.0.1添 加 网 关 ：ip route add default via GW dev IFACE ip route add default via 172.16.0.1删除路由：ip route del TARGET 显示路由：ip route show|list清空路由表：ip route flush [dev IFACE] [via PREFIX]ip route flush dev eth0 网络配置文件 /etc/sysconfig/network-scripts/route-IFACE• 注意：需service network restart生效• 两种风格：(1) TARGET via GW如 ：10.0.0.0/8 via 172.16.0.1(2) 每三行定义一条路由 ADDRESS#=TARGET NETMASK#=mask GATEWAY#=GW 创建bonding设备的配置文件/etc/sysconfig/network-scripts/ifcfg-bond0 DEVICE=bond0BOOTPROTO=noneBONDING_OPTS=”mode=1,miimon=100” 工作模式为1，后面指两个机子之间间隔100毫秒进行通讯 /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=noneMASTER=bond0SLAVE=yes 查看bond0状态：/proc/net/bonding/bond0 进程优先级进程优先级：系统优先级：数字越小，优先级越高0-139（CentOS4,5）各有140个运行队列和过期队列0-98，99（CentOS6）实时优先级: 99-0 值最大优先级最高nice值：-20到19，对应系统优先级100-139或99 Big O：时间复杂度，用时和规模的关系O(1), O(logn), O(n)线性, O(n^2)抛物线, O(2^n) 进程状态 Linux内核：抢占式多任务 进程类型：守护进程: daemon,在系统引导过程中启动的进程，和终端无关进程前台进程：跟终端相关，通过终端启动的进程注意：两者可相互转化 进程状态：运行态：running就绪态：ready睡眠态：可中断：interruptable不可中断：uninterruptable停止态：stopped,暂停于内存，但不会被调度，除非手动启动僵死态：zombie，结束进程，父进程结束前，子进程不关闭 系统管理工具进程的分类：CPU-Bound：CPU密集型，非交互IO-Bound：IO密集型，交互 Linux系统状态的查看及管理工具：pstree, ps, pidof, pgrep, top, htop, glance, pmap, vmstat, dstat, kill, pkill, job, bg,fg, nohup pstree命令：显示树状的进程关系 里面花括号代表的是线程 pstree -p 以树状图显示进程，还显示进程PID。pstree display a tree of processes ps: process stateps report a snapshot of the current processesps能看到当前进程的状态快照Linux系统各进程的相关信息均保存在/proc/PID目录下的各文件中 ps查看进程进程ps [OPTION]…支持三种选项：UNIX选项 如-A -eBSD选项 如aGNU选项 如–help• 选项：默认显示当前终端中的进程• a 选项包括所有终端中的进程• x 选项包括不链接终端的进程• u 选项显示进程所有者的信息• f 选项显示进程树,相当于 –forest• k|–sort 属性 对属性排序,属性前加- 表示倒序• o 属性… 选项显示定制的信息ps axo pid,%cpu,%mem,cmd 显示选定的选项• L 显示支持的属性列表 ps常见选项-C cmdlist 指定命令，多个命令用，分隔-L 显示线程-e: 显示所有进程，相当于-A-f: 显示完整格式程序信息-F: 显示更完整格式的进程信息-H: 以进程层级格式显示进程相关信息-u userlist 指定有效的用户ID或名称-U userlist 指定真正的用户ID或名称-g gid或groupname 指定有效的gid或组名称-G gid或groupname 指定真正的gid或组名称-p pid 显示指pid的进程–ppid pid 显示属于pid的子进程-M 显示SELinux信息，相当于Z ps输出属性VSZ: Virtual memory SiZe，虚拟内存集，线性内存RSS: ReSident Size, 常驻内存集STAT：进程状态S: interruptable sleeping 可中断休眠D: uninterruptable sleepingT: stoppedZ: zombie+: 前台进程l: 多线程进程L：内存分页并带锁N：低优先级进程 &lt;: 高优先级进程s: session leader，会话（子进程）发起者 ps ni: nice值 pri: priority 优先级 psr: processor CPU编号 rtprio: 实时优先级示例：ps axo pid,cmd,psr,ni,pri,rtprio 常用组合：aux-ef-eFH-eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,commaxo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm 例子:查询你拥有的所有进程 ps -x显示指定用户名(RUID)或用户ID的进程 ps -fU apacheps -fU 48显示指定用户名(EUID)或用户ID的进程 ps -fu wangps -fu 1000查看以root用户权限（实际和有效ID）运行的每个进程 ps -U root -u root列出某个组拥有的所有进程（实际组ID：RGID或名称） ps -fG nginx 列出有效组名称（或会话）所拥有的所有进程 ps -fg mysqlps -fg 27显示指定的进程ID对应的进程ps -fp 1234以父进程ID来显示其下所有的进程，如显示父进程为1234的所有进程 ps -f –ppid 1234显示指定PID的多个进程ps -fp 1204,1239,1263要按tty显示所属进程 ps -ft pts/0 以进程树显示系统中的进程如何相互链接 ps -e –forest以进程树显示指定的进程ps -f –forest -C sshdps -ef –forest | grep -v grep | grep sshd要显示一个进程的所有线程,将显示LWP（轻量级进程）以及NLWP（轻量级进程数）列ps -fL -C nginx要列出所有格式说明符ps L查看进程的PID，PPID，用户名和命令 ps -eo pid,ppid,user,cmd 自定义格式显示文件系统组,ni值开始时间和进程的时间 ps -p 1234 -o pid,ppid,fgroup,ni,lstart,etime使用其PID查找进程名称：ps -p 1244 -o comm=要以其名称选择特定进程，显示其所有子进程 ps -C sshd,bash查找指定进程名所有的所属PID，在编写需要从std输出或文件读取PID的脚本时这个参数很有用ps -C httpd,sshd -o pid=检查一个进程的执行时间ps -eo comm,etime,user | grep nginx 查找占用最多内存和CPU的进程ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%mem | head ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%cpu | head显示安全信息 ps -eMps –context使用以下命令以用户定义的格式显示安全信息 ps -eo euser,ruser,suser,fuser,f,comm,label使用watch实用程序执行重复的输出以实现对就程进行实时的监视，如下面的命令显示每秒钟的监视watch -n 1 ‘ps -eo pid,ppid,cmd,%mem,%cpu –sort=-%mem | head’ 进程优先级进程优先级调整静态优先级：100-139进程默认启动时的nice值为0，优先级为120只有根用户才能降低nice值（提高优先性）nice命令nice [OPTION] [COMMAND [ARG]…]renice命令renice [-n] priority pid…查看ps axo pid,comm,ni 搜索进程最灵活：ps 选项 | 其它命令按预定义的模式：pgrep pgrep [options] pattern-u uid: effective user，生效者-U uid: real user，真正发起运行命令者-t terminal: 与指定终端相关的进程-l: 显示进程名-a: 显示完整格式的进程名-P pid: 显示指定进程的子进程按确切的程序名称：/sbin/pidofpidof bash uptime显示当前时间，系统已启动的时间、当前上线人数，系统平均负载（1、5、10分钟的平均负载，一般不会超过1）系统平均负载:指在特定时间间隔内运行队列中的平均进程数通常每个CPU内核的当前活动进程数不大于3，那么系统的性能良好。如果每个CPU内核的任务数大于5，那么此主机的性能有严重问题如果linux主机是1个双核CPU，当Load Average 为6的时候说明机器已经被充分使用 搜索终端运行的相关进程 pgrep -t pts/0]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F28%2F%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目归档 描述linux目录结构以及目录结构命名规定所有的目录都是按照一定的类别有规律的组织和命名的.FHS（目录层次结构）是Linux的目录规范标准.不要使用特殊字符来命令目录名。和glob字符或许会有冲突FHS（目录层次结构）: http://www.pathname.com/fhs/总结流程图:http://naotu.baidu.com/file/90bbd454b261551260c4e75ca6564f0d 显示/etc目录下，所有以.d结尾的文件或目录ls -d /etc/*.d -d 只显示当前文件夹 显示/etc目录下，所有.conf结尾，且以m,n,r,p开头的文件或目录ls /etc/[mnrp]*.conf 创建/app/rootdir目录，并复制/root下所有文件到该目录内， 要求保留原有权限12345[root@centos7 /]# mkdir -p /app/rootdir[root@centos7 /]# cp -a /root/ !$cp -a /root/ /app/rootdir[root@centos7 /]# ls /app/rootdir/root 使用命令行展开功能，创建/tmp/a1, /tmp/a2, /tmp/a1/a, /tmp/a1/b，在/tmp目录下创建目录：x_y, x_z, q_y, q_zmkdir {x,q}_{y,z} 总结用户、用户组管理命令并演示命令以及常见用法useradd 创建用户 http://holyghost.me/2018/08/28/linux%20command/-u 指定UID -g 指定所属组或gid -c “文字” 用户的注释信息 -d 指定家目录 -s 指定用户的默认登录的shell,可用列表在/etc/shells文件中 -G 指定用户的附加组，要先创建useradd -u 678 -g pan -c &quot;测试&quot; -d /data -s /bin/sh aaauserdel -r username 删除用户及所属的家目录和邮件groups username 显示linux用户所属的组groupadd groupname 创建组usermod -g root username将用户username的组修改为root组usermod -a -G-a -G 无限增加到附加组，可拥有多个附加组.将a1添加附加组user3 usermod -a -G user3 a1 某一用户拥有多个附加组之后，使用usemod -G会修改附加组，则多个组消失掉变成唯一当前修改的附加组 文件权限，属主属组管理命令有哪些，并演示命令以及用法chmod 更改文件权限：chmod 777 a http://holyghost.me/2018/08/28/linux%20command/chown 更改文件拥有者和所属组：chown USER:GROUP 对象 chown USER 对象 chown :group 对象chgrp 改变文件或目录所属的组: chgrp - R book /opt/local /book 改变/opt/local /book/及其子目录下的所有文件的属组为book 创建用户gentoo，附加组为bin和root，默认shell为/bin/csh，注释信息为 “Gentoo Distribution”useradd -G bin,root -s /bin/sh -c &quot;Gentoo Distribution&quot; gentoo 1、总结vim命令行模式常见快捷方式，以及vim查找，替换的方法:.,$y复制当前行到末尾行:! 调用系统命令，可临时执行 使vim设置永久生效:vim /etc/vimrc 把设置写到这个文件的最后，对所有账户生效set nu 显示行号 set nonu 取消行号set ic 不区分大小写 set noic 取消不区分大小写set ts=4 设置tab键长度set sw=4 设置自动缩进的tab键长度 vim /root/.vimrc 也可以把设置写到此文件，只对root生效 vim字符替换:%s/this/that 每一行的第一个this被替换成that:%s/this/that/g 将文本中所有的this替换成that %从每一行的开头到结尾 s表示替换:1,5 s/old/new/g #替换第一行到第5行中所有匹配的内容. 1234：s/a/b/ 替换当前行第一个a为b：s/a/b/g 替换当前行所有a为b：%s/a/b/ 替换每一行的第一个a为b：%s/a/b/g 替换每一行中所有a为b 字符操作u撤销上一步i当前插入，I行首插入。a当前字符插入(光标后一位插入)，A行尾插入。o表示：本行回车到下一行插入，O上一行插入。x删除光标所在字符，X向前删除一个字符。dd删除光标所在的行，dG删除光标所在开始行到文件尾的所有字符。J合并两行。行操作：home 键或^键行首，$或end行尾dd删除一行Ndd(删除本行与下一行)。yy复制一行，Nyy复制n行，p将复制行粘贴，p向光标下一行粘。(N表示数字) 词操作:dw删除一个词，y+$复制至行尾。y+^复制至行首。yw复制一个词。:.,$y 复制当前行到末尾 v模式:编程的时候需要进行多行注释： （删除是要将光标移到这个词的行首，如果光标不在行首则删除光标之后的字母。）块操作：D或d+$删除至行尾 d+^删除至行首1、注释：ctrl+v进入列编辑模式2、向下或向上移动光标 （ctrl L 向下全部选中）3、把需要注释的行开头的开头标记起来4、然后按大写的I5、再插入注释符，比如“#”6、再按Esc，就会全部注释了删除多行注释：按ctrl+v进入列编辑模式;向下或向上移动光标；选中注释部 分然后按d,就会删除注释符号。 vim编辑器： :wq 可以保存外 :w +路径+文件名直接保存在某个位置和重命名:w 路径/文件名ZZ 保存退出 :x 保存退出 :!命令:!ifconfigvi的行定位功能:ctrl+f 向前卷动一个屏幕ctrl+b 向后卷动一个屏幕G 到文件最后一行行首:$ 到文件最后一行行尾mG 到指定行，m为目标行数 或者mggset nu 显示行号/内容 查找指定内容n 查找下一个N 回到前一个？ 寻找上一个 /^字符串 查找以字符串开始的行/字符串$ 查找以字符串结尾的行/a.b 查找字符串a任意字符b vim替换r 替换当前光标字符:r 文件名 在光标当前位置载入另一个文件. 2、总结脚本中运算符、逻辑运算以及用法按照文件类型判断 测试选型作用-b 文件判断该文件是否存在，并且是否为块设备文件(是块设备文件为真)-c 文件判断该文件是否存在，并且是否为字符设备文件(是字符设备文件为真)-d 文件判断该文件是否存在，并且是否为目录文件(是目录为真)-e 文件判断该文件是否存在，(存在为真)-f 文件判断该文件是否存在，并且是否为普通文件(是普通文件为真)-L 文件判断该文件是否存在，并且是否为符号链接文件(是符号链接文件为真)-p 文件判断文件是否存在，并且是否为管道文件(是管道文件为真)-s 文件判断该文件是否存在，并且是否为非空(非空为真)-S 文件判断该文件是否存在，并且是否为套接字文件(是套接字文件为真) 判断文件是否存在(两种格式)test -e /root/install.log-e /root/install.log]第一个判断命令如果正确执行，则打印”yes”，否则打印”no”[ -d /root ] &amp;&amp; echo &quot;yes&quot; || &quot;no&quot;注意空格 按照文件权限进行判断测试选项作用-r 文件判断该文件是否存在，并且是否该文件拥有读权限(有读权限为真)-w 文件判断该文件是否存在，并且是否该文件拥有写权限-x 文件判断该文件是否存在，并且是否该文件拥有执行权限(有执行权限为真)-u 文件判断该文件是否存在，并且是否该文件拥有SUID权限(有SUID权限为真)-g 文件判断该文件是否存在，并且是否该文件拥有SGID权限(有SGID权限为真)-k 文件判断该文件是否存在，并且是否该文件拥有SBit权限(有SBit权限为真). 1test -w /data/a.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 他只要UGO只要有一个有写权限就会执行出来 两个文件之间进行比较测试选项作用文件1 -nt 文件2判断文件1的修改时间是否比文件2的新(如果新则为真)文件1 -ot 文件2判断文件1的修改时间是否比文件2的旧(如果旧则为真)文件1 -ef 文件2判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法比较硬链接的文件Inode号1test a.txt -ef /tmp/a1.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 两个整数之间比较测试选项作用整数1 -eq 整数2判断整数1是否和整数2相等 (相等为真)整数1 -ne 整数2判断整数1是否和整数2不相等 (不相等为真)整数1 -gt 整数2判断整数1 是否大于整数2 (大于为真)整数1 -lt 整数2判断整数1是否小于整数2 (小于为真)整数1 -ge 整数2判断整数1是否大于等于整数2 (大于等于为真)整数1 -le 整数2判断整数1是否小于等于整数2 (小于等于真)1[ 23 -gt 22 ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot; 注意[]左右的空格 字符串的判断测试选项作用-z 字符串判断字符串是否为空(为空返回真)-n 字符串判断字符串是否为非空(非空返回真)子串1 == 子串2判断子串1是否和子串2相等(相等返回真)子串1 ！= 子串2判断字符串1是否和字符串2不相等(不相等为真). 1234[root@Tiger data]# name=scYou have new mail in /var/spool/mail/root[root@Tiger data]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot;N 1234[root@Tiger data]# aa=abc[root@Tiger data]# bb=abc[root@Tiger data]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;y&quot; || echo &quot;N&quot;y 多重条件判断测试选项作用判断1 -a 判断2逻辑与，判断1和判断2都成立，最终的结果才为真判断1 -o 判断2逻辑或，判断1和判断2有一个成立，最终的结果就为真! 判断逻辑非，使原始的判断式取反12345[root@Tiger data]# aa=24[root@Tiger data]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot;yes[root@Tiger data]# [ -z &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot; NO 3、编写脚本/root/bin/backup.sh，可实现每日将/etc/目录备份到 /root/etcYYYY-mm-dd中12345#!/bin/bashecho &quot;Start Backup&quot; sleep 5cp -av /etc/ /root/data/etc`date +%F`echo &quot;backup is finished&quot; 4、编写脚本/root/bin/nologin.sh和login.sh,实现禁止和充许普通用户登录系统123456禁止普通用户登录系统#!/bin/bashread -p &quot;请输入禁止登陆用户名: useruid=$(id $user | sed -r -n &apos;s/.*=([0-9]&#123;3,&#125;).*$/\1/p&apos;)[ $uid -ge 500 ] &amp;&amp; usermod -s /bin/nologin $user || echo &quot;该用户为系统用户，无法禁止&quot;echo &quot;该用户已经禁止登陆&quot; 123456允许普通用户登录系统#!/bin/bashread -p &quot;请输入允许登录的用户： useruid=$( id $user | sed -r -n &apos;s/.*=([0-9]&#123;3,&#125;).*$/\1/p&apos; )[ $uid -ge 500 ] &amp;&amp; usermod -s /bin/bash $user || echo &apos;该用户为系统用户&apos;echo &apos;该用户已允许登陆&apos; 5、编写脚本/root/bin/disk.sh,显示当前硬盘分区中空间利用率最大的值df | grep /dev/sd | grep -o &#39;[0-9]\+%&#39; | sort -nr | head -1 1.查找/var/目录下不属于root、lp、gdm的所有文件find /var/ -not -user root -a -not -user lp -a -not -user gdm; 2.统计/etc/init.d/functions文件中每个单词的出现次数，并排序(用grep和sed两种方法分别实现)123$ cat /etc/init.d/functions|tr -c &apos;[:alpha:]&apos; &apos;\n&apos;|tr -s &apos;\n&apos; | sort | uniq -c | sort -nr$ sed -nre &apos;s/[^[:alnum:]]+/\n/g&apos; -e &apos;s/[0-9]/\n/gp&apos; /etc/init.d/functions|sort|uniq -c|sort -n$ grep -Eo &quot;\&lt;[[:alpha:]]+[[:alnum:]]+\&gt;&quot; /etc/init.d/functions | sort | uniq -c | sort -n [:alpha:] 表示任何大小写字母tr -c, 用集合1中的字符串替换，要求字符集为ASCII -s, 即将重复出现字符串压缩为一个字符串[:alnum:] 任意字符sort 将文本文件内容加以排序 -n 依照数值的从小到大排序。 -r 以相反的顺序来排序。uniq -c或–count 在每列旁边显示该行重复出现的次数[:alnum:] 表示字母和数字\&lt; #锚定单词的开始，如:&#39;\&lt;\grep&#39;匹配包含以grep开头的单词的行&#39; 3.利用sed取出ifconfig命令本机的IPV4地址ifconfig | sed -nr &#39;2s/.*t (.*) net.*/\1/p&#39; 4.总结yum的配置和使用，包括yum仓库的创建yum repolist 查看仓库信息仓库的元数据yum history 查看yum安装历史yum history info 2 查看历史中的第二项yum客户端配置文件：/etc/yum.conf：为所有仓库提供公共配置/etc/yum.repos.d/*.repo：为仓库的指向提供配置仓库指向的定义：[repositoryID]name=Some name for this repositorybaseurl=url://path/to/repository/enabled={1|0}gpgcheck={1|0}gpgkey=URLenablegroups={1|0} 5.编写系统初始化脚本reset.sh,包括别名，提示符颜色，yum仓库配置文件123456789101112131415161718#!/bin/bashc=&quot;alias cdnet=&apos;cd /etc/sysconfig/network-scripts&apos;&quot;a=&quot;alias ednet=&apos;vim /etc/sysconfig/network-scripts/ifcfg-ens33&apos;&quot;echo $c &gt;&gt; /root/.bashrcecho $a &gt;&gt; /root/.bashrcsource /root/.bashrcecho -e &quot;PS1=\&quot;\e[33m[\u@\h \W]\$\e[m\&quot;&quot; &gt; /etc/profile.d/env.shsource /etc/profile.d/env.shecho &apos;PATH=/data/bin:$PATH&apos; &gt; /etc/profile.d/input.shsource /etc/profile.d/input.shchmod +x /etc/profile.d/*mkdir /data/basemount /dev/sr0 /data/base[ -d /etc/yum.repos.d/bak ] &amp;&amp; echo &quot;yes&quot; exit || mkdir /etc/yum.repos.d/bakmv /etc/yum.repos.d/*.repo /etc/yum.repos.d/baktouch /etc/yum.repos.d/base.repoecho -e &quot;[base]\nname=cdrom\nbaseurl=file:///data/base\ngpgcheck=0&quot;&gt;&gt;/etc/yum.repos.d/base/repo 6.安装tree,lftp,telnet等包yum install tree ftp lftp telnet 7.在centos7上编译安装apache2.4源码包，并启动此服务yum groupinstall “development tools” 使用组包安装tar -xf httpd-2.4.39.tar.gzcd httpd-2.4.39/通过./configure –指定软件总目录，二进制目录和其他功能make 使用make命令创建make文档文档中存放着各种文件路径make install 讲各文件复制到所对应的目录systemctl start apache 启动服务 1、磁盘lvm管理，完成下面要求，并写出详细过程： 1) 创建一个至少有两个PV组成的大小为20G的名为testvg的VG;要求PE大小 为16MB, 而后在卷组中创建大小为5G的逻辑卷testlv;挂载至/users目录 2) 扩展testlv至7G，要求archlinux用户的文件不能丢失 3) 收缩testlv至3G，要求archlinux用户的文件不能丢失 4) 对testlv创建快照，并尝试基于快照备份数据，验证快照的功能2、创建一个可用空间为1G的RAID1设备，文件系统为ext4，有一个空闲盘，开机可自动挂载至/backup目录3、简述TCP链接建立和断开过程4、简述TCP和UDP的区别 命令积累lscpu 查看cpu信息 lsblk （列出块设备）命令用于列出所有可用块设备的信息sosreport 收集日志 查看内存：cat /proc/meminfopartorobe 新分区不用重启的识别命令。刷新硬盘分区表 centos7partx -a centos6 -a对于增加硬盘的选项partx -d --nr 6 /dev/sda 对于删除分区后，刷新硬盘的选项 用户的UID大于500的都是非系统账号，500以下的都为系统保留的账号 进制转换123456789101112130 01 110 2 11 3100 4 101 5 110 6 111 71000 8(2^3)10000 16(2^4)100000 32(2^5)1000000 64(2^6)10000000 128(2^7) 2^0=1 2^1=2 2^2=4 2^3=8 16 32 64 128例：97(十进制)=64+32+1=1000000+100000+1=1100001。例：10101010(二进制)=128+32+8+2=170。1Gbps：每秒传输1g的位。1Gbit/second1Byte=8bit touch建立带-的文件:touch -- -atouch ./-b DAS NAS SAM 存储基础知识—存储网络 DAS NAS SAM 传输类型 SCSI、FC IP IP、FC、SAS 数据类型 数据块 文件 数据块 典型应用 任何 文件服务器 数据库应用 优点 磁盘与服务器分离，便于统一管理 不占用应用服务器资源 高扩展性，高可用性，数据集中，易管理 缺点 连接距离短，数据分散，共享困难，存储空间利用率不高，扩展性有限 不适合存储大量的块级应用，数据备份已恢复占用网络带宽 相比NAS成本较高，安装和升级比NAS复杂 分区分区分配一个目录名mount point,名为挂载分区：MBR,GPT主：一个硬盘最多有四个，只有一个是活动，1-4扩展：最多一个，划分更小的分区，扩展+主分区&lt;=4 1-4逻辑分区：5,6 运行模式：runlevel3 5.3表示前一次的运行级别，5表示现在的运行级别N:表示前一次没有运行级别 。init 3：切换到3级别，init要登录startx:切换到？级别，startx不需要登录5：字符界面 0：关机 6：重启 终端tty显示终端号chvt 2:表示ctrl+Alt+F2切换到的界面 centos7启动网络启动网络：nmcli connection modify ens33 connection.autoconnect yesid -u:当前用户的UID，root为0，非0为普通用户。 查看版本号cat /etc/centos-release lsb_release -a 命令提示符查看：echo $PS1更改：PS1=&quot;\[\e[1;33m\][\u@\h \w \!]\\$\[\e[0m\]&quot;命令提示符:prompt # :管理员 $ :普通用户显示提示符格式：echo $PS1修改提示符格式：PS1=&quot;\e[1;33m\[[\u@\h \W]\\$\\e[0m&quot;PS1=&#39;\e[1;33m[\u@\h \w]\$ &#39; \e \033 \u 当前用户 \h 主机名称 \H 主机名 \w 当前工作目录 \W 当前工作目录最后目录名 \t 24小时时间格式 \T 12小时时间格式 \！命令历史数 \# 开机后命令历史数cat ~/.bashrc 命令提示符当前用户修改路径 虚拟机取消密码进入123vim /etc/gdm/custom.conf AutomaticLoginEnable=true AutomaticLogin=root 查看命令类型type pwd:显示命令的类型外部命令或者内部命令 -a :显示所有的内部命令后外部命令的列表 执行命令输入命令后回车:提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来。在shell中可执行的命令有两类1.内部命令：由shell自带的，而且通过某种命令形式提供 help内部命令列表enable cmd 启动内部命令enable -n cmd 禁用内部命令enable -n 查看所有禁用的内部命令2.外部命令：在文件系统路径下有对应的可执行程序文件查看路径：which -a |–skip-alias; whereis3.区别指定的命令是内部或外部命令type COMMANDwhereis:查看外部命令路径和他的配置文件文档路径 命令执行路径alias –内部 –hash表(记录外部命令的路劲) –$PATH –命令找不到 Hash缓存表 系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将这条命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先会查看hash表，存在将执行之，如果不存在，将会去PATH路径下寻找，利用hash缓存表可大大提高命令的调用率。 hash常见用法 hash 显示hash缓存 hash -l 显示hash缓存，可作为输入使用 hash -p path name 将命令全路径path起别名为name hash -t name 打印缓存中name的路径 hash -d name 清除name缓存 hash -r 清除缓存 别名显示当前shell进程所有可用的命令别名alias定义别名NAME，其相当于执行命令VALUEalias NAME=&#39;VALUE&#39;在命令行中定义的别名，仅对当前shell进程有效如果想要永久有效，要定义在配置文件中 仅对当前用户： ~/.bashrc 对所有用户有效： /etc/bashrc 写入文件后，文件存储在磁盘上没有生效，必须让他在内存中才会生效，使用命令source.bashrc删除别名(指在内存中删除)：unalias 别名编辑配置给出的新配置不会立即生效bash进程重新读取配置文件. 12source /path/to/config_file./path/to/config_file 撤销别名: unalias [name] -a取消所有别名如果别名同原命令同名，如果要执行原命令，可使用12345\ALIASNAME&quot;ALIASNAME&quot;&apos;ALIASNAME&apos;command ALIASNAME/path/command 针对外部命令 . 日期和时间linux的两种时钟系统时钟：由Linu内核通过CPU的工作频率进行的硬件时钟：主板相关命令:date 显示和设置系统时间 date +%s date -d @1509536033hwclock,clock:显示硬件时钟-s,–hctosys 以硬件时钟为准，校正系统时钟-w,–systohc 以系统时钟为准，校正硬件时钟时区：/etc/localtime显示日历：cal whoami用户登录信息查看命令:whoami :显示当前登录有效用户who :系统当前所有的登录会话w :系统当前所有的登录会话及所做的操作. 远程协助：screen screen 命令：创建新screen会话 screen -S [SESSION]加入screen会话 screen -x [SESSION]退出并关闭screen会话 exit剥离当前screen会话 Ctrl+a,d显示所有已经打开的screen会话 screen -ls恢复screen会话 screen -r [SESSION]. echolinux中换行表示：移动到下一行回车：光标移动到行首说明：echo会将输入的字符送往输出。输出的字符串间以空白字符隔开，并在最后加上换行号。-E :(默认)不支持\解释功能 -n :不自动换行 -e :启用\字符的解释功能 显示变量：echo &quot;$VAR_NAME&quot; 变量会替换，弱引用 单双引号的区别echo &#39;$VAR_NAME&#39; 变量会替换，强引用反引号里面可执行命令（可用$(命令)代替）`` ls -l `echo $SHELL` 得到的是/bin/bash 文件的详细信息 启用命令选项：-e,若字符串中出现以下字符，则特别加以处理，而不会将他当成一般文字输出\a :发出警告声\b :退格键\c :最后不加上换行符号\n :换行且光标移动至行首\r :回车，即光标移动至行首，但不换行\t :插入Tab字符\ :插入\字符\0nnn :插入nnn(八进制)所代表的ASCII字符 echo -e &#39;\033[43;31;5mmagedu\033[0m&#39;\xHH插入HH(十六进制)所代表的ASCII数字(man 7 ascii) hexdump查看”二进制”文件的十六进制编码123456[root@centos7localdomain ~]# hexdump -C a00000000 31 0a |1. |00000002[root@centos7localdomain ~]# hexdump -C a00000000 31 32 0a 33 0a 61 0a |12.3.a. | 00000007 查看文件a的十六进制和ASCII码。偏移量；十六进制；ASCII码； 原始数据 （最后有空格）文件原始数据每行一个数。 Centos7设置语言localectl list-locales查看语言列表localectl set-locale LANG=en_US.utf8 修改修改后要注销再登录cat /etc/locale.conf 符号命令行扩展，被括起来的集合命令行扩展: $()或``把一个命令的输出打印给另一个命令的参数 1234echo &quot;This system&apos;s name is $(hostname)&quot;This system&apos;s name is server1.example.com echo &quot;i am `whoami`&quot;i am root 括号扩展:{}打印重复字符串的简化形式echo file{1,3,5} 结果为: file1 file3 file5rm -fr file{1,3,5}echo {1..10}echo {a..z}. whatiscentos6生成whatis数据库:makewhatisCentos7: mandbwhatis:显示命令的简短叙述;使用数据库;刚安装后不可立即使用makewhatis | mandb 制作数据库使用示例: whatis cal 或 man -f cal history 重复前一个命令使用上方向键，并且执行 按!!并回车执行 输入!-1执行倒数第一个命令 按Ctrl+p 并回车执行!:0 执行前一条命令(去除参数)Ctrl+n 显示当前历史中的下一条命令，但不执行Ctrl+j 执行当前密令!n 执行history命令输出对应序号n的命令!-n 执行history历史中倒数的第n个命令!string 重复前一个以”string”开头的命令!?string 重复前一个包含string的命令!string:p 仅打印命令历史，而不执行!$:p 打印输出!$(上一条命令的最后一个参数)的内容!*:p 打印输出!*(上一条命令的所有参数)的内容^string 删除上一条命令中的第一个string^string1^string2 将上一条命令中的第一个string1替换为string2!:g/s/string/string2 将上一条命令中所有的string1都替换为string2 3. 使用up(向上)和down(向下)键上下浏览从前输入的命令ctrl+r 在历史命令中搜索ctrl+g 从历史搜索模式中退出要重新调用前一个命令中最后一个参数：!$ESC,.(点击ESC键后松开，然后点击.键)Alt+. (按住Alt键的同时点击.键) 4. command !^ 利用上一个命令的第一个参数做cmd的参数.command !$ 利用上一个命令的最后一个参数做cmd的参数command !* 利用上一个命令的全部参数做cmd的参数command !:n 利用上一个命令的第n个参数做cmd的参数command !n:m 调用第n条命令的第m个参数command !n:* 调用第n条命令的所有参数 -c :清空命令历史 -d offser :删除历史中指定的第offser个命令 n :显示最近的n条历史 -a :追加本次会话新执行的命令历史列表至历史文件 -r :读历史文件附加到历史列表 -w :保存历史列表到指定的历史文件 -n :读取历史文件中未读过的行到历史列表 -p :展开历史参数成多行，但不存在历史列表中 -s :展开参数成一行，附加在历史列表后 -p:可以执行命令但不存在历史记录中。-s:伪造历史，不执行命令。HISTTIMEFORMAT=&quot;%F %T &quot;历史加上时间. 5.命令历史相关环境变量 HISTSIZE :命令历史记录的条数HISTFILE :指定历史文件，默认为~/.bash_history HISTFILESIZE :命令历史文件记录历史的条数 HISTTIMEFORMAT= “%F %T” 显示时间 HISTIGNORE= “str1:str2*……” 忽略str1命令，str2开头的历史 控制命令历史的记录方式： 环境变量：HISTCONTROL ignoredups 默认，忽略重复的命令，连续且相同为”重复” ignorespace 忽略所有已空白开头的命令 ignoreboth 相当于ignoredups,ignorespace的组合 erasedups 删除重复命令export 变量名=”值”存放在 /etc/profile 或 ~/.bash_profile. man查看man手册页 man [章节] keyword列出所有帮助 man -a keyword搜索man手册 man -k keyword 列出所有匹配的页面相当于whatis 数据库 man -f keyword打印man帮助文件的路径 man -w [章节] keyword man 命令的操作方法：使用less 命令实现待续写 man搜索待续写 bash 的快捷键Ctrl + l 清屏，相当于clear命令Ctrl + o 执行当前命令，并重新显示本命令Ctrl + s 阻止屏幕输出，锁定Ctrl + q 允许屏幕输出Ctrl + c 终止命令Ctrl + z 挂起命令 基名，目录名basename :取文件基名dirname :取文件目录名 centos6自动挂载cd /misc/cd 目录磁盘会自动挂载 通配符* 匹配零个或多个字符? 匹配任何单个字符~ 当前用户家目录 ~mage 用户mage家目录~+ 当前工作目录~- 前一个工作目录[0-9] 匹配数字范围 [a-z]:字母 [A-Z]:字母 [wang]匹配列表中的任何的一个字符[^wang] 匹配列表中的所有字符以外的字符ls 1[a-z].txt:不会显示出小写字母到大写字母的文件，他会以小写大写的顺序排列出来预定义的字符类：man 7 glob [:digit:] :任意数字，相当于0-9[:lower:] :任意小写字母[:upper:] :任意大写字母[:alpha:] :任意大小写字母[:alnum:] :任意数字或字母[:blank:] :水平空白字符[:space:] :水平或垂直空白字符[:punct:] :标点符号[:print:] :可打印字符[:cntrl:] :控制(非打印)字符[:graph:] :图形字符[:xdigit:] :十六进制字符ls .[^.]*显示当前目录下的隐藏目录ls -d .*ls -l &quot;[^.]*&quot; -a 三种显示方式 atime mtime ctimetouch命令-a 仅改变 atime和ctime-m 仅改变 mtime和ctime-t [[CC]YY]MMDDhhmm[.ss] touch -t 201802062036.18 linuxidc.txt 指定atime和mtime的时间戳-c 如果文件不存在，则不予创建, 如果文件存在，touch将更新访问时间 cpcp -r递归cp /etc/passwd ./a --backup将文件cp到a文件夹并备份-d:保留链接属性-a:归档，相当于-d,-p,-r-v:显示复制过程-p:此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中-u:两个同样的文件覆盖时，只复制新的到旧的上去。-f:复制已经存在的目标文时件不提示-i:询问，如果目标文件已经存在，则会询问是否覆盖-l:把目标文件建立为源文件的硬链接文件，而不是复制源文件；-b:覆盖前，目标存在先备份cp /etc/passwd ./a1 --backup=numbered例：cp -av /etc/ app/back date +%F :/etc/目录下所有文件，备份到/app独立的子目录下，要求子目录格式为backYYY-mm-dd,备份过程可见。 mv-b: 如果有相同的文件，覆盖前先备份。 -t移动文件路径和目标路径颠倒 alias rm=&#39;mv -t /data&#39; rename将main1.c重命名为main.c rename main1.c main.c main1.c如果使用rename foo foo0 foo?，会把foo1到foo9的文件重命名为foo01到foo09，重命名的文件只是有4个字符长度名称的文件，文件名中的foo被替换为foo0。 如果使用rename foo foo0 foo??，foo01到foo99的所有文件都被重命名为foo001到foo099，只重命名5个字符长度名称的文件，文件名中的foo被替换为foo0。rename支持正则表达式:rename &quot;s/AA/aa/&quot; //把文件名中的AA替换成aa修改文件的后缀 rename &quot;s//.html//.php/&quot; //把.html 后缀的改成 .php后缀批量添加文件后缀 rename &quot;s/$//.txt/&quot; //把所有的文件名都以txt结尾批量删除文件名 rename &quot;s//.txt//&quot; //把所有以.txt结尾的文件名的.txt删掉如我们想把文件扩展名为.bak 的文件扩展名去掉，可以这样 rename &#39;s/.bak$//&#39; \*.bak*.bak 为通配符(wildcard)，会被shell展开为各个文件名 123去除文件名中的空格 rename &apos;s/ //g&apos;g 是global的意思，替换所有的空格为空字符（也就是删除啦） 文件名转为小写: rename &apos;y/A-Z/a-z/&apos; tree显示目录树 -d :只显示目录 -L level :指定显示的层级数目 -P pattern :只显示由指定pattern匹配到的路径tree -P /etc/rc* mkdir创建目录 -p :存在于不报错，且可自动创建所需的各目录 -v :显示详细信息 -m MODE :创建目录时直接指定权限 rmdir删除空目录 -p :递归删除父目录(rmdir -p:从下往上删除，从深往浅删除) -v :显示详细信息rm -r :递归删除目录树 例：1.创建/testdir/dir1/x,/testdir/dir1/y,/testdir/dir1/x/a,/testdir/dir1/x/b,/testdir/dir1/y/a,/testdir/dir1/y/bmkdir -p ./testdir/dir1/{x,y}/{a,b}2.创建/testdir/dir2/x,/testdir/dir2/y,/testdir/dir2/x/a,testdir/dir2/x/bmkdir -p testdir/dir2{x/{a,b},y}3.创建/testdir/dir3,/testdir/dir4,/testdir/dir5,/testdir/dir5/dir6,testdir/dir5/dir7mkdir -p ./testdir/dir{3,4,5/dir{6,7}} inode索引节点:inode(index node)表中包含文件系统所有文件列表一个节点(索引节点)是在一个表项，包含有关文件的信息(元数据),包括： 文件类型,权限,UID,GID 链接数(指向这个文件名路径名称个数) 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据]]></content>
      <categories>
        <category>write</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[command]]></title>
    <url>%2F2018%2F08%2F28%2Flinux%20command%2F</url>
    <content type="text"><![CDATA[linux 常用命令集合: 写在前面[root@pan ~]# root:登录的用户 @分隔符 pan主机名 ~当前路径\:newline echo $PATHctrl+r:在历史命令中搜索。 ctrl+s:暂停屏幕输出。 ctrl+q:恢复屏幕输出。&quot;&amp;&quot; &quot;||&quot; &quot;!&quot;只用普通用户登录Shell是/bin/bash catcat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ -n 显示的时候，顺道输出行号！ -A:查询所有的内容包括隐藏字符 ls-F:在每个输出项后追加文件的类型标识符，具体含义：“*“表示具有可执行权限的普通文件“/“表示目录 “@”表示符号链接“|”表示命令管道FIFO“=”表示sockets套接字当文件为普通文件时，不输出任何标识符drwxr-xr-x. 3 root root 24 May 11 23:29 Music这里的3: 如果是普通文件就表示链接次数，如果是目录文件就表示目录下的一级子目录数。 echo#echo [选项][输出内容] echo -e &quot;\e[1;31m abcd \e[0m&quot; 输出颜色=30m 黑色，=31m 红色，=32m 绿色，=33m 黄色，=34m 蓝色，=35m 洋红，=36m 青色，=37m 白色。&quot;echo -e ab\bc&quot; 控制字符在末尾可能不执行。-e:支持反斜线控制的字符转换 控制字符 作用 \ 输出\本身 \a 输出警告音 \b \退格键，也就是向左删除键 \c 取消输出行末的换行符，和“-n”选项一致 \e ESCAPE键 \f 换页符 \n 换行符 \r 回车键 \t 制表符，也就是Tab键 \v 垂直制表符 \0nm 按照八进制ASCII码输出字符，其中0为数字零，nnn是三位八进制数 \xhh 按照十六进制ASCII码表输出字符。其中hh是两位十六进制数。 I/o redirection输出重定向:命令 &gt; 文件 2&gt;&amp;1 :以覆盖的方式，把正确输出和错误输出都保存在一个文件当中。命令 &amp;&gt;文件 :以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。 &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件。1&gt;&amp;2 意思是把标准输出重定向到标准错误.2&gt;&amp;1 意思是把标准错误输出重定向到标准输出&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中 输入重定向：命令 &lt;文件wc [选项] [文件名]默认行，单词，字节数选项： -c :统计字节数 -w :统计单词数 -l :统计行数wc &lt; filename12345678wc &lt;&lt; filename wc &lt;&lt; a.txt 注意a.txt &gt; dshi &gt; jdiosjfh &gt; diosjfiojd &gt; fdiojsoifj &gt; hello 4 4 36 sortsort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，不加参数时依次按ASCII码值进行比较，最后将他们按升序输出 -n :依照数值的从小到大排序; -f ：忽略大小写 -r :以相反的顺序来排序; -u :忽略相同行使用-u选项或者uniq 文件名 -t &lt;分隔符&gt;：指定排序时所用的栏位分隔字符； -k n[,m]是按照指定的字段范围排序，从第n字段开始，m字段结束(默认到行尾)（字母按ASCII排序，数字按从小到大。先数字后字母） [root@mail text]# sort -nrk 3 -t: sort.txt 将CC列数字从大到小顺序排列：eee:40:5.4eee:60:5.1ddd:20:4.2ccc:50:3.3bbb:10:2.5aaa:30:1.6AAA:BB:CC 列 指定分隔符是:，用第三字段开头，第三字段结尾排序，就是只用第三字段排序1[root@Tiger data]# sort -n -t &quot;:&quot; -k 3,3 /etc/passwd 但是这样排序会以字符串排序需要以数字排序1sort -n -t &quot;:&quot; -k 3,3 /etc/passwd awk awk &#39;{print $1}&#39; 文件名 $1第一列，$2第二列，$NF最后一列.$(NF-1)倒数第二列）。 现在是以文件的空格为分隔符这样打印 awk-F&quot;:&quot;&#39;{print $1}&#39; /etc/passwd -F指定分隔符，并打印文件第一列 多列打印#awk -F &quot;:&quot; &#39;{print $2 $3}&#39; /etc/passwd 这样打印$2 $3之间是没有分隔符 要加分隔符就是 awk -F &quot;:&quot; &#39;{print $2 &quot;\t&quot; $3}&#39; /etc/passwd $0表示整个文件 df文件系统查看命令 -a:显示所有的文件系统信息信息，包括特殊文件系统，如，/proc,/sysfs -h:使用习惯单位显示容量，如KB,MB或GB等。 -T:显示文件系统类型 -m: 以MB为单位显示容量。 -k:以KB为单位显示容量，默认就是以KB为单位显示容量。 du命令和df命令的区别df:命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间(最常见的就是文件已经删除，但是程序并没有释放空间) du: 命令是面向文件的，只会计算计算机文件或目录占用的空间. du是通过搜索文件来计算每个文件的大小然后累加，du能看到的文件只是一些当前存在的，没有被删除的。他计算的大小就是当前他认为存在的所有文件大小的累加和 -h : 以K，M，G为单位，提高信息的可读性。 -s : 统计总占用量，而不列出子目录和子文件的占用量。ls -h是目录下文件名占用大小 du -h 是目录下所有文件的大小 -k : 以KB(1024bytes)为单位输出。 -m : 以MB为单位输出。 -a显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量。 dddd(磁盘对拷命令)命令用于复制文件并对原文件的内容进行转换和格式化处理 [root@localhost]# dd if=输入文件 of=输出文件 bs=字节数 count=个数选项：if=输入文件 指定源文件或源设备of=输出文件 指定目标文件或目标设备bs=字节数 指定一次输入/输出多少字节，即把这些字节看做一个数据块count=个数 指定输入/输出多少个数据块 date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000(100M) ; data。 fsck文件系统修复命令fsck [选项] 分区设备文件名 -a:不显示用户提示，自动修复文件系统 -y:自动修复。和-a作用一致，不过有些文件系统只支持-y dumpe2fs显示磁盘状态命令 #dumpe2fs 分区设备名 rpmrpm是Linux标准基础（LSB）兼容发行版所使用的一种软件包管理器，用来对软件包进行低级处理rpm可以查询、安装、检验、升级和卸载软件包，它多数用于基于Fedora的系统，比如RHEL和CentOS 只有安装和升级要加包全名。 -ivh: -i:安装，-v:显示详细信息，-h:显示进度，–nodeps：不检测依赖性。 -Uvh包全名：RPM包升级. -q :接软件包名字 #查询软件是否已经安装 -q(查询query) -qa :#查询所有已经安装的RPM包。-a(所有all) -qi :包名字#查询软件包详细信息 -i :显示软件包的相关信息 -ql 包名:查询软件包安装位置 -l :显示套件的文件列表。 -qf +系统文件名。查看一个文件是由哪个包安装的 -qip 包全名:查询未安装软件包信息，必须在软件包目录进行查询。 -qR :查询软件包的依赖性。 -qRp :查询未安装软件包的依赖性必须在Packages目录查询。 -e 包名:卸载软件。rpm -qf `which 程序名` #返回软件包的全名 已安装的软件包rpm -qif `which 程序名` #返回软件包的有关信息rpm -qlf `which 程序名` #返回软件包的文件列表 RPM校验#rpm -V 已安装的包名选项：-V 校验指定RPM包中的文件。(verify) [root@Tiger ~]#rpm -V httpdS.5….T. c /etc/httpd/conf/httpd.conf验证内容中的8个信息的具体内容如下： S：文件大小是否改变； M：文件的类型或文件的权限(r w x)是否被改变； 5：文件MD5校验和是否改变(可以看成文件的内容是否改变)； D：设备的主，从设备号是否改变； L：文件路径是否改变； U：文件的属主(所有者)是否改变； G：文件的属组是否改变； T：文件的修改时间是否改变；文件类型： c :配置文件(config file) d :普通文档(documentation) g :”鬼”文件(ghost file),很少见，就是该文件不应该被这个RPM包包含 l :授权文件(license file) r :描述文件(read me) RPM包中文件提取#rpm2cpio 包全名 | \ cpio -idv .文件绝对路径 反斜杠：换行的作用。rpm2cpio:将rpm包转换为cpio格式的命令。cpio:是一个标准工具，他用于创建软件档案文件和从档案文件中提取文件。 #cpio 选项 &lt; [文件|设备]选项： -i:copy-in模式，还原 -d:还原时自动新建目录 -v：显示还原过程 rpm -qf /bin/ls 查询ls命令属于哪个软件包mv /bin/ls /tmp 造成ls命令误删除的假象rpm2cpio /mnt/Packages/coreutils-8.4-37.el6.x86_64.rpm | cpio -idv ./bin/ls提取RPM包中ls命令到当前目录的/bin/ls下 cp /root/bin/ls /bin 把ls命令复制到/bin目录，修复文件丢失。 源码包与RPM包的区别安装在指定位置当中，一般是/usr/local/软件名/。RPM包安装的服务可以使用系统服务管理命令(service)来管理，例如RPM包安装apache的启动方法是:/etc/rc.d/init.d/httpd start: 绝对路径启动服务。service httpd start源代码保存位置：/usr/local/src/软件安装位置：/usr/local/如何确定安装过程报错：安装过程停止；并出现error、warning或no的提示。源码包安装过程：下载源码包；解压缩下载的源码包；进入解压缩目录。 CRT中sftp里面要设置远程的路径和本地的路径:cd 1 进入远程连接到的Linux的1目录lcd \text 本地的c盘text目录get abc.c 从远程目录得到文件abc.c放入本地目录textput a11.txt 从Windows上将文件a11.txt传入linux 源码包配置./configure软件配置与检查 定义需要的功能选择。 检测系统环境是否符合安装需求。 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。./configure –prefix=/usr/local/apache2安装路径详情参考INSTALL 源码包的卸载：不需要卸载命令，直接删除安装目录即可，不会遗留任何垃圾文件。 脚本安装包：脚本安装包并不是独立的软件包类型，常见安装的是源码包。是人们把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。非常类似于Windows下软件的安装方式。 yum能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。remove :删除指定的rpm软件包； yum -y remove 软件包名yum update +包名 :升级。 禁用yum grouplist:列出所有可用的软件组列表；yum groupinstall 软件组名:安装指定的软件组，组名可以由goruplist查询出来；yum groupremove:卸载指定软件组； 配置yum仓库: [base] name=centos baseurl=file:///mnt/ enabled=1 gpgcheck=0 yum clean all 清除缓存，使最新的yum配置生效。yum list 列出所有可安装的软件包列表，包含已安装和未安装的 headhead 用来显示档案的开头至标准输出中,默认head命令打印其相应文件的开头10行 -n:显示文件的前n行 head -n 5 a.txt 显示文件的前5行 -c显示文件前n个字节 &gt;head -c 20 a.txt head -c -32 log2014.log文件的除了最后n个字节以外的内容head -n -6 log2014.log 输出文件除了最后n行的全部内容 . tail主要用来从指定点开始将文件写到标准输出。很多人喜欢使用tail -f 来监控日志文件。 -f该参数用于监视文件的增长 tail -f filename监视filename文件的尾部内容（默认10行，相当于增加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。 -n从指定行位置读取指定文件。 tail -n 20 filename 显示filename最后20行 -c显示文件最后n个字节 tail -c 20 a.txt chmod chmod命令用来变更文件或目录的权限，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件 -f :若该文件权限无法被更改也不要显示错误讯息 -R :对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)r=读取属性 值＝4 w=写入属性 值＝2 x=执行属性 值＝1 chown改变某个文件或目录的所有者和所属的组chown USER:GROUP 对象chown USER 对象 chown :group 对象 systemctlsystemctl命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起 chkconfig1.服务概述:在linux操作系统下，经常需要创建一些服务，这些服务被做成shell脚本，这些服务需要在系统启动的时候自动启动，关闭的时候自动关闭。将需要自动启动的脚本/etc/rc.d/init.d目录下，然后用命令chkconfig –add filename将自动注册开机启动和关机关闭。实质就是在rc0.d-rc6.d目录下生成一些文件连接，这些链接连接到/etc/rc.d /init.d目录下指定文件的shell脚本。 --list :列出所有系统服务 --add httpd:增加httpd服务。 --del httpd:删除httpd服务。 --list mysqld:列出mysqld服务设置情况 --level 35 mysqld on:设定mysqld在等级3和5为开机运行服务，–level 35表示操作只在等级3和5执行，on表示启动，off表示关闭。 chkconfig mysqld on:设定mysqld在各等级为on，“各等级”包括2、3、4、5等级。 chkconfig 设置是当前不生效，linux重启后才生效.service 设置是即时生效，linux关机重启后设置失效. mount查询与自动挂载(Auto Mount) mount [-l] 查询系统中已经挂载的设备，-l会显示卷标名称mount -a 依据配置文件/etc/fstab的内容，自动挂载 挂载命令格式 mount [-t 文件系统] [-L卷标名] [-o特殊选项] 设备文件名 挂载点-t 文件系统:加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统 -L 卷标名:挂载指定卷标的分区，而不是安装设备文件名挂载 -o 特殊选项:可以指定挂载的额外选项。 mount -o remount,noexec /home这里的/home是df可以查看到的分区重新挂载/home分区，并使用noexec权限 #cd /home #vi hello.sh#!/bin/bashecho “i love you”#chmod 755 #./hello.sh 会显示没有权限执行 #mount -o remount,exec /home 记得改回来，要不然会影响系统启动的。 挂载光盘mkdir /mnt/cdrom 建立挂载点mount -t iso9660 /dev/cdrom /mnt/cdrom 挂载光盘mount /dev/sr0 /mnt/cdrom 卸载光盘#umount设备文件名或挂载点umount /mnt/cdrom 挂载U盘fat32格式:fdisk -l 查看U盘设备文件名mount -t vfat /dev/sdb1 /mnt/usb/注意：fat16分区识别为fat,fat32分区识别为vft。linux默认是不支持NTFS文件系统的. NTFS u盘支持下载NTFS-3G插件https://www.tuxera.com/community/open-source-ntfs-3g/ 解压 tar -zxvf filename 安装 ./configure &amp;&amp; make &amp;&amp; make installfdisk -l查看linux的U盘分区：sdc1mount -t ntfs-3g /dev/sdc1 /mnt/usb/mkfs -t ext4 /dev/sdb1/ 格式化分区,扩展分区不可格式mkdir /disk1 建立挂载点mount /dev/sdb1 /disk1 挂载 swap新增swap空间:free查看swap大小新增一个分区，改分区号82，保存退出格式化：mkswap /dev/sdb6 加入swap分区：swapon /dev/sdb6取消swap分区：swapoff /dev/sdb6 但是每次开机都要手动挂载一遍，可以写入fatab开机自动挂载vi /etc/fstab/dev/sdb6 swap swap defaults 0 0 free显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。 -b ：以Byte为单位显示内存使用情况； -k ：以KB为单位显示内存使用情况； -m ：以MB为单位显示内存使用情况； total:去掉为硬件和操作系统保留的内存后剩余的内存总量。许多人奇怪自己的电脑安装了一共8G的内存，但是显示总共只有七点几G的，现在应该没什么疑惑了把，不管Linux还是Windows都会有部分内存是保留给硬件和操作系统的！ userd：当前已使用的内存总量。 free：空闲的或可以使用的内存总量 shared：共享内存大小，主要用于进程间通信 buff(buffers):缓冲，主要用于块设备数据缓冲(磁盘缓存大小)，例如记录文件系统的metadata（目录、权限等等信息）。是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减小了磁盘碎片和硬盘反复寻道，加速了数据的写入过程。 cache:缓存，主要用于文件内容缓冲,是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程。 available:可以使用的内存总量. Compression 压缩 commandgzipgzip filename压缩 *.gz :”后缀名”gzip -d filename.gz gunzip filename.gz 解压缩不解压查看：zcat filename.gz bz2bzip2 filename压缩 *.bzip2:”后缀名”bzip2 -k filename 保存源文件压缩bzip2 -d filename.bz2 bunzip2 filename.bz2解压缩不解压查看：bcat filename.bz2 xzxz filename压缩 .xz:”后缀名”xz -d filename.xz 解压缩unxz -k filename.xz 保存源文件解压 zipzip默认保存源文件，可以压缩目录解压：unzip FileName.zip压缩：zip FileName.zip DirName -r ：递归处理，将指定目录下的所有文件和子目录一并处理； tar-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的 tar cf file.tar files 将一个或多个文件、目录打包到tar包。tar rf file.tar file 将文件file添加到tar包中。tar uf file.tar file 将文件file更新tar包中相应的文件。tar tf file.tar 查看tar内容。tar xf file.tar 解压tar包。 -z:有gzip属性,即需要用 gzip 压缩 -j:有bz2属性,即需要用 bzip2 压缩 -v:显示处理过程 -C:指定解压输出目录 tar zxvf test.tar.gz -C test-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 -Z：有compress属性的 -O：将文件解开到标准输出 格式：tar Zcf file.tar.Z files 将一个或多个文件、目录压缩到file.tar.Z中。需要安装了ncompress软件包才行。解压.tar.Z文件。格式：tar Zxf file.tar.Z 归档并压缩：使用时间格式打包数据：tar zcf etc-$(date +%F).tar.gz /etc tar zcf etc-`date +%F`.tar.gz /etc *.tar.gz归档并调用gzip压缩 tar -zcf 新文件名.tar.gz /etc/passwd /var/log/messagages调用gzip解压缩并展开归档 tar -zxvf filename.tar.gz *.tar.bz2归档并调用bzip2压缩 tar -jcf 新文件名.tar.bz2 /etc/passwd /var/log/messages调用bzip解压缩并展开归档 tar -jxf filename.tar.bz2不解压缩查看：tar -tvf home_2018-10-14.tar.gz locate其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。 所以你要知道： locate的速度比find快，因为它并不是真的查找文件，而是查数据库locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护升级数据库命令：locate -- u CentOS系统找不到locate命令，原因是系统中没有安装 mlocate 这个包，然后更新数据库: updatedb -c :只显示找到条目的号码 -b :匹配唯一的路径名称的基本文件名 -r :基于基本正则表达式进行匹配操作 find实时查找工具，通过遍历指定起始路径下文件系统层级结构完成文件查找： 根据文件名查找： -name “pattern” -iname “pattern” 支持glob风格的通配符: \*,?,[],[^] i忽略大小写 -regex pattern :基于正则表达式查找文件，匹配整个路径而非其名； 根据文件从属关系查找：123456-user USERNAME:查找属主指定用户的所有文件； -goup GROUPNAME:查找属组指定组的所有文件； -uid UID:查找属主指定的UID的所有文件； -gid GID:查找属组指定的GID的所有文件； -nouser :查找没有属主的文件； -nogroup :查找没有属组的文件； 根据文件的类型查找：-type TYPE :按type查找f:普通文件 d:目录 l:符号链接文件 b:块设备文件 c:字符设备文件p:管道文件 s：套接字文件 【 ./可执行文件 】组合测试：12345与：-a,默认组合逻辑而且的意思; -o 是或者的意思； -not,!：非(相反)find ./ -size -1M -a -type f#寻找当前目录下文件大于1M的文件或者是目录。find ./ -size +1M -o -type d#寻找当前目录下文件小于1M并且文件类型是一般文件的文件。 !A -a !B =!(A -o B) !A -o !B =!(A -a B) 查找tmp目录下不包含“fstab”的字符文件 find /tmp -not -iname &quot;*fstab\*&quot; 根据文件的大小查找： -size [+|-]#UNIT 常用单位：K,M,G123size 10K filename,大小表示 (#-1,#] 9K&lt;filename&lt;10K; size -10K filename,大小表示[0-UNIT-1]; size +10K filename,大小表示(#,∞); 根据时间戳查找以“天”为单位： # [#,#-1]距现在为止过去几天前访问过文件。-#:(0,#) 几天内访问过文件。+#(oo, #-1] 几天前至-oo访问过的所有文件 -atime:显示的是文件中的数据最后被访问的时间，比如系统的进程直接使用或通过一些命令和脚本间接使用。 -mtime:显示的是文件内容被修改的最后时间，比如用vi编辑就会发生改变。 -ctime:显示的是文件的权限、拥有者、所属的组、链接数发生改变时的时间。当然当内容改变时也会随之改变。以“分钟”为单位: -amin -mmin -cmin 同上 根据权限来查找 -perm [/|-]mode find ./ -perm 644mode:精确权限匹配； /mode :任何一类用户(u,g,o)的权限中的任何一位(r,w,x)符合条件即满足 9位权限之间存在“或”关系； -mode :每一类用户(u,g,o)的权限中的每一位(r,w,x)同时符合条件即满足 9位权限之间存在”与”关系；440属于/666有读的权限 find./ -perm /666 符合这一查找 处理动作：-print:输出至标准输出:默认的动作;-ls:类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息-delete:删除找到的文件-fls:/PATH/TO/SOMEFILE:把查找到的所有文件的长格式信息保存至指定文件中；-ok COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认；-exec COMMAND {} \; :对查找到的每个文件执行由COMMAND表示的命令； 查找/var目录下属主为root，且属组为mail的所有文件或目录；find /var -user root -a -group mail -ls 查找/usr目录下不属于root,bin或hadoop的所有文件或目录；用两种方法find /usr -not -user root -a -not -user bin -a -not -user hadoopfind /usr -not \( -user root -o -user bin -o -user hadoop \) -ls 查找/etc目录下最近一周内其内容修改过，且属主不是root也不是hadoop用户的文件或目录；find /etc -mtime -7 -a -not -user root -a -not -user hadoopfind /etc -mtime -7 -a -not \(-user root -o -user hadoop\) -ls 查找当前系统上没有属主或属组，且最近一周内曾今被访问过的文件或目录；find ./ -nouser -o -nogroup -ls 如果有文件属于可查找项，但是加ls选项最后会无法输出显示 加了-o（或条件）和ls后只会对后一半生效。 需要find ./ \( -nouser -o -nogroup\) -atime -7 -ls 查找/etc目录下大于1M且类型为普通文件的所有文件；find /etc -size +1M -lsfind /etc -size +1M -type f -exec ls -lh {} \; 查找/etc目录下所有用户都没有写权限的文件；find /etc -not -perm /222 -type f -ls 至少有一个用户 有 查找/etc目录至少有一类用户没有执行权限的文件；find /etc -not -perm -type f -111 查找/etc/init.d目录下，所有用户都有执行权限，且其他用户有写权限的所有文件；find /etc -perm -111 -a -perm -002 -lsfind /etc -perm -113 -ls -type f historyhistory [选项][历史命令保存文件]-c:清空历史命令 -w:把缓存中的历史命令写入历史命令保存文件 ~/.bash_history 历史命令默认保存1000条，可以在环境变量配置文件/etc/profile中修改历史命令的调用： 使用上、下箭头调用以前的历史命令 使用”!n”重复执行第n条历史命令 使用”!!”重复执行上一条命令 使用”!字符串”重复执行最后一条以该字符串开头的命令。 使用ctrl+r 搜索历史命令 alias命令别名#alias 别名=&#39;原命令&#39; alias:查询命令别名。 命令执行时顺序： 第一顺位执行时用绝对路径或相对路径执行的命令。 第二顺位执行别名。 第三顺位执行Bash的内部命令。 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。让别名永久生效：vim /root/.bashrc删除别名：unalias 别名. vim:.,$y复制当前行到末尾行:! 调用系统命令，可临时执行 使vim设置永久生效:vim /etc/vimrc 把设置写到这个文件的最后，对所有账户生效set nu 显示行号 set nonu 取消行号set ic 不区分大小写 set noic 取消不区分大小写set ts=4 设置tab键长度set sw=4 设置自动缩进的tab键长度 vim /root/.vimrc 也可以把设置写到此文件，只对root生效 vim字符替换:%s/this/that 每一行的第一个this被替换成that:%s/this/that/g 将文本中所有的this替换成that %从每一行的开头到结尾 s表示替换:1,5 s/old/new/g #替换第一行到第5行中所有匹配的内容. 字符操作u撤销上一步i当前插入，I行首插入。a当前字符插入(光标后一位插入)，A行尾插入。o表示：本行回车到下一行插入，O上一行插入。x删除光标所在字符，X向前删除一个字符。dd删除光标所在的行，dG删除光标所在开始行到文件尾的所有字符。J合并两行。行操作：home 键或^键行首，$或end行尾dd删除一行Ndd(删除本行与下一行)。yy复制一行，Nyy复制n行，p将复制行粘贴，p向光标下一行粘。(N表示数字) 词操作:dw删除一个词，y+$复制至行尾。y+^复制至行首。yw复制一个词。:.,$y 复制当前行到末尾 v模式:编程的时候需要进行多行注释： （删除是要将光标移到这个词的行首，如果光标不在行首则删除光标之后的字母。）块操作：D或d+$删除至行尾 d+^删除至行首1、注释：ctrl+v进入列编辑模式2、向下或向上移动光标 （ctrl L 向下全部选中）3、把需要注释的行开头的开头标记起来4、然后按大写的I5、再插入注释符，比如“#”6、再按Esc，就会全部注释了删除多行注释：按ctrl+v进入列编辑模式;向下或向上移动光标；选中注释部 分然后按d,就会删除注释符号。 vim编辑器： :wq 可以保存外 :w +路径+文件名直接保存在某个位置和重命名:w 路径/文件名ZZ 保存退出 :x 保存退出 :!命令:!ifconfigvi的行定位功能:ctrl+f 向前卷动一个屏幕ctrl+b 向后卷动一个屏幕G 到文件最后一行行首:$ 到文件最后一行行尾mG 到指定行，m为目标行数 或者mggset nu 显示行号/内容 查找指定内容n 查找下一个N 回到前一个？ 寻找上一个 /^字符串 查找以字符串开始的行/字符串$ 查找以字符串结尾的行/a.b 查找字符串a任意字符b vim替换r 替换当前光标字符:r 文件名 在光标当前位置载入另一个文件. useradduseradd命令用来建立用户帐号和创建用户的起始目录，使用权限是终极用户. -u :uid指定用户ID -d:指定用户登入时的启始目录。 -g:指定用户所属的群组 -G:指定用户所属的附加群组。tom 用户的登陆 shell 为非交互式 shell useradd –s /sbin/nologin tom -e :指定账号的有效期限，缺省表示永久有效 useradd user1——创建用户user1;useradd –e 12/30/2009 user2——创建user2,指定有效期2009-12-30到期 -c:用户说明，手工指定用户的说明，添加说明有Spacebar时要加“ “。 用户默认值文件：/etc/defalut/useradd1.GROUP=100 :用户默认组ID (公有模式)2.HOME=/home :用户家目录3.INACTIVE=-1 :密码过期宽限天数(shadow文件7字段)4.EXPIRE=no value :密码失效时间(8字段)5.SHELL=/bin/bash :默认的shell6.SKEL=/etc/skel :模板目录7.CREATE_MAIL_SPOOL=yes :是否建立邮箱 /etc/login.defsPASS_MAX_DAYS 999 :密码有效期(5字段)PASS_MIN_DAYS 0 :密码修改间隔(4字段)PASS_MIN_LEN 5 :密码最小5位(PAM)PASS_WARN_AGE 7 :密码到期警告(6)UID_MIN 500 :最小和最大UID范围GID_MIX 60000ENCRYPT_METHOD SHA512 :加密模式. userdel删除用户userdel [-r] 用户名 -r:删除用户的同时删除用户家目录 id查看用户id：#id 用户名查询用户的UID,初始组ID,附加群组ID usermodusermod命令用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user id，必须确认这名user没在电脑上执行任何程序. -g &lt;群组&gt; 修改用户所属的原始群组。usermod -g root username -G &lt;群组&gt; 修改户所属的附加群组 -a -G 无限增加到附加组，可拥有多个附加组.将a1添加附加组user3 usermod -a -G user3 a1-c:修改用户的说明usermod -c &quot;test user&quot; username 当某一用户拥有多个附加组之后，使用usemod -G会修改附加组，则多个组消失掉变成唯一当前修改的附加组1.将 newuser2 添加到附加组 staff usermod -G staff newuser2 -l &lt;帐号名称&gt; 修改用户帐号名称。2.修改 newuser 的用户名为 newuser1 usermod -l newuser1 newuser-L 锁定用户密码，使密码无效。 -U 解除密码锁定。3.锁定账号 newuser1 usermod -L newuser14.解除对 newuser1 的锁定 usermod -U newuser1 -d 改变用户家目录,常与-m结合使用 -m 将主目录的内容移动到新目录usermod -m -d /home/user2 -uid username若使用报错使用以下命令：cat /dev/null &gt; /var/run/utmp 清空此文件。utmp是一个文件，除了utmp程序你不能编辑这个文件，删掉他的话，当前登陆信息都会丢失。它就好比系统开启后它会把系统成员的信息迅速的记录下来，过一段时间它就不再记录，确认系统的用户配置就是这样了，这个文件在每次机器reboot起来后都会重新创建。. groupadd-g GID: 修改组ID -n 新组名: 修改组名 susu: [选项] 用户名 -:选项只使用”-“代表连带用户的环境变量一起切换。可使用env命令查看-c:仅执行一次命令，而不切换用户身份su - root -c &quot;useradd user3&quot;不切换成root,但是执行useradd命令添加user1用户。 chage修改用户密码状态chagechage [选项] 用户名 -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期(shadow3字段) -m 天数:两次密码修改间隔(4字段) -M 天数:密码有效期(5字段) -W 天数:密码过期前警告天数(7字段) -I 天数:密码过后宽限天数(7字段) -E 日期:账号失效时间(8字段)chage -d 0 username这个命令其实是把密码修改日期归0了(shadow第3字段)，这样用户只要一登录就要修改密码。第三字段是指密码最后一次修改时间的日期。1970年1月1号到现在修改密码的时间戳。如果第3字段改为0，系统会认为用户没有修改过操作密码，那么当此用户一旦登录系统就会提示要修改密码，才可正常使用。. passwd-S:查询用户密码的密码状态，仅root用户可用。 -l:暂时锁定用户。仅root用户可用。 -u:解锁用户。仅root用户可用。 –stdin:可以通过管道符输出的数据作为用户的密码。echo &quot;123&quot; | passwd --stdin user gpasswd -d :从组删除用户 gpasswd -d username groupadd -a :添加用户到组(附加组),同时保留以前的组 添加用户到某一个组可以使用 usermod -G groupB userA 这个命令可以添加一个用户到指定的组，但是以前添加的组就会清空掉.所以想要添加一个用户到一个组，同时保留以前添加的组时，请使用gpasswd这个命令来添加操作用户 -A :指定组内管理员 gpasswd -A username groupname groups groups username 显示linux用户所属的组 datedate 根据给定格式显示日期或设置系统日期时间。print or set the system date and time 指令所在路径：/bin/date date &quot;+%Y-%m-%d %H:%M:%S&quot; -d:显示字符串所指的日期与时间。字符串前后必须加上双引号123date -d now date -d &apos;next monday&apos; date -d yesterday +%Y-%m-%d -r:显示文件最后修改时间 -s:设置系统时间 date -s &quot;2018-11-11 00 00 00&quot; 在使用date -s这个命令修改时间后，系统重启后就失效了，因此为了将这个时间永久生效，需要将修改的时间写入CMOS，查看CMOS的时间:clock –r将当前系统时间写入CMOS中去clock –w 在生产环境中常使用时间格式打包数据：tar zcvf etc-$(date +%F).tar.gz /etctar zcvf etc-`date +%F`.tar.gz /etc date:2018/9/23 hwclock查看硬件时间设置硬件时间hwclock --set --date=&quot;07/07/06 10:19&quot; （月/日/年 时:分:秒）硬件时间和系统时间的同步：重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需要用hwclock命令实现同步。硬件时钟与系统时钟同步：hwclock --hctosys（hc代表硬件时间，sys代表系统时间）系统时钟和硬件时钟同步:（让系统的时间同步到硬件时钟)hwclock –-systohc. lnln：链接命令硬链接：复制并同步 ln /etc/passwd /tmp/password 软链接：类似windows下的快捷方式 ln -s /etc/passwd /tmp password软链接和硬链接的区别:1.创建命令不同:ln -s /root/ruan.txt /root/桌面/ ln /root/ying.txt /root/桌面/2.软链接创建时必须使用绝对路径(链接和源文件在同一目录下,可以相对路径)硬链接创建时可以绝对路径也可相对路径3.软链接的源文件不可以剪切,重命名,删除 硬链接的源文件可以剪切,重命名,删除4.软链接的链接文件权限永远是777，即使将链接文件的权限进行了修改，也不会发生变化，变得是源文件的权限 硬链接的链接文件权限永远和源文件相同5.软链接的链接文件的inode号和源文件不同硬链接的链接文件的inode号和源文件相同6.软链接可以对目录操作硬链接不支持对目录操作，是针对于上层来说，底层是可以针对于目录做硬链接的，通过代码就可以实现7.软链接可以跨文件系统硬链接不可以跨文件系统，因为硬链接是存放在源文件的同一个block上面的 SElinux安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则） DAChttp://blog.51cto.com/zhaotianyu/1795178：在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：某个资源是否拥有对应用户的权限（读、写、执行）。只要访问这个资源的进程符合以上的条件就可以被访问。而最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问。这种权限管理机制的主体是用户，也称为自主访问控制（DAC）。 MAChttp://baijiahao.baidu.com/s?id=1590170088632157084&amp;wfr=spider&amp;for=pc：在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限。这样一来，即使进程是以 root 身份运行的，也需要判断这个进程的类型以及允许访问的资源类型才能决定是否允许访问某个资源。进程的活动空间也可以被压缩到最小。即使是以 root 身份运行的服务进程，一般也只能访问到它所需要的资源。即使程序出了漏洞，影响范围也只有在其允许访问的资源范围内。安全性大大增加。这种权限管理机制的主体是进程，也称为强制访问控制（MAC）。getenforce命令是单词get（获取）和enforce(执行)连写，可查看selinux状态setenforce 命令则是单词set（设置）和enforce(执行)连写，用于设置selinux防火墙状态，如： setenforce 0用于关闭selinux防火墙，但重启后失效。 SELinux status：selinux防火墙的状态，enabled表示启用selinux防火墙关闭SElinux:临时关闭 :setenforce 0用于关闭selinux防火墙，但重启后失效永久关闭：修改selinux的配置文件：vim /etc/selinux/config将SELINUX=enforcing改为SELINUX=disabled，保存后退出，此时获取当前selinux防火墙的安全策略仍为Enforcing，配置文件并未生效。重启后验证。SELinux 有三种工作模式，分别是：1.enforcing：强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中。2.permissive：宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用。3.disabled：关闭 SELinux crontab1.Crontab是一个用于设置周期性执行任务的工具；2.周期性执行的任务我们称为Cron Job；3.周期性执行的任务列表我们称为Cron Tablecrontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下: * * * * * command minute hour day month week command 顺序:分 时 日 月 周 minute： 表示分钟，可以是从0到59之间的任何整数。hour：表示小时，可以是从0到23之间的任何整数。day：表示日期，可以是从1到31之间的任何整数。month：表示月份，可以是从1到12之间的任何整数。week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件 -u:编辑某个用户的cron，只用root可以使用此参数为别的用户设置cron服务。也可用于给用户指定crontab文件。 -l: 列出当前用户的crontab。 -r: 删除当前用户的crontab。 -e: 编辑当前用户的crontab，默认使用vi，或者是由 VISUAL或EDITOR环境变量指定的编辑器。 -i与-r 一起使用，用来询问用户是否直接删除crontab安装cronyum install vixie-cronyum install crontabs检查crontab工具是否安装：crontab -l检查crond服务是否启动：service crond status检查crontab服务状态：service crond status 每晚的21:30重启apache30 21 * * * service httpd restart 每月1,10,22日的4:45重启apache45 4 1,10,22 * * service httpd restart 每月1-10日的4:45重启apache45 4 1-10 * * service httpd restart 每天18:00-23:00之间每隔30分钟重启apache0,30 18-23 * * * service httpd restart0-59/30 18-23 * * * service httpd restart 每晚11-早上7点之间，每隔一个小时重启apache* 23-7/1 * * * service httpd restart 每隔两分钟重启apache 123*/2 * * * * service httpd restart 1-59/2 * * * * service httpd restart(奇数分钟重启) 0-58/2 * * * * service httpd restart(偶数分钟重启) 小结：*表示任何时候都匹配；可以用”A,B,C”表示A或者B或者C时执行命令可以用”A-B”表示A到B之间时执行命令可以用”*/A”表示每A分钟(小时等)执行一次命令 */1 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP时间同步: fdiskfdisk命令操作磁盘详解–添加、删除、转换分区等主分区和扩展分区(扩展分区不能直接使用)(1-4),扩展分区下面再分逻辑分区(5开始)。 fdisk /dev/sda 分区保存报错需要重启时，强制读取分区表信息#partprobeyum install -y parted grepgrep [选项] “搜索内容” 文件名 -i 忽略大小写 -n 输出行号 -v 反向查找 --color=auto把搜索出的关键字用颜色显示]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[document]]></title>
    <url>%2F2018%2F08%2F28%2Fdocument%2F</url>
    <content type="text"><![CDATA[Linux 文档 用户和用户组管理/etc/passwd:用户信息文件user1:x:500:500::/home/user1:/bin/bash第一字段:用户名称；第二字段:密码标志；第三字段:UID(用户ID)； 0：超级用户； 1-499：系统用户(伪用户)； 500-65535:普通用户；第4字段：GID(用户初始组ID)第5字段：用户说明第6字段：家目录 普通用户：/home/用户名/ 超级用户：/root/第7字段：登录之后的Shell 影子文件:/etc/shadow第1字段：用户名第2字符：加密密码 加密算法升级为SHA512散列加密算法 如果密码位是“ ！”或“ * ”代表没有密码，不能登录。第3字段：密码最后一次修改日期：使用1970年1月1号作为标准时间，每过一天时间戳加1。第4字段：两次密码的修改间隔时间(和第3字段相比)间隔多少时间后才可以修改密码。第5字段：密码有效期(和第3字段相比)第6字段：密码修改到期前的警告天数(和第5字段相比)第7字段：密码过期后的宽限天数(和第5字段相比) 0：代表密码过期后立即失效。 -1：则代表密码永远不会失效。第8字段：账号失效时间，要用时间戳表示第9字段：保留把时间戳换算为日期：date -d &quot;1970-01-01 17740 days&quot;把日期换算为时间戳：echo $(($(date --date=&quot;2018/07/28&quot; +%s)/86400+1)) 组信息文件/etc/group第一字段：组名第二字段：组密码标志第三字段：GID第四字段：组中附加用户 组密码文件/etc/gshadow第一字段：组名第二字段：组密码第三字段：组管理员用户名第四字段：组中附加用户 用户的家目录 普通用户：/home/用户名/,所有者和所属者都是此用户，权限是700 超级用户：/root/,所有者和所属者都是root用户，权限是550。 用户的邮箱：/var/spool/mail/用户名/ 用户模板目录：/etc/skel:创建用户时，用户的家目录会自动创建一些隐藏文件，这些文件是从/etc/skel/ 过去的。想要每个新添加用户时家目录自动出现共享文件可在此目录添加。 linux的特殊权限特殊权限： SUID,SGID,STICKY 1.进程以某用户的身份运行；进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作；2.权限匹配模型：(1)判断进程的属主，是否为被访问的文件属 主 ；如果是，则应用属主的权限；否则进入第2步；(2)判断进程的属主，是否属于被访问的文件属 组 ；如果是，则应用属组的权限；否则进入第3步;(3)应用other的权限； SUIDSetUID的功能:1、只有可以执行的二进制程序才能设定SUID权限。2、命令执行者要对该程序拥有X(执行)权限3、命令执行者在执行该程序时获得该程序文件属主的身份4、SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效。 SUID :默认情况下:用户发起的进程，进程的属主是其发起者；因此，其以发起者的身份运行； SUID 的功用：用户运行某程序时，如果此程序拥有SUID的权限，那么程序运行为进程时，进程的属主不是发起者，而程序文件自己的属主;管理文件的SUID权限： chmod u+|-s FILe 展示位置：属主的执行权限位。 #chomod 4644 filename取消suid权限：#chmod 644 filename 大写S为报错,检查是否有x权限. SGID用户在执行程序时候，组身份变为该程序文件的属组与SUID类似。 管理文件的 SGID 的权限： chmod g+|-s FILE SGID : 功用：当目录属组有写的权限，且SGID权限时，当你给一个目录添加了sgid之后，后面不管谁来这个目录下创建文件，文件的所属组都会继承目录的所属组展示位置：属组的执行权限位如果属组原本有执行权限，则显示为小写s;否则，显示为大写S; #ll /usr/bin/locate #ll /var/lib/mlocate/mlocate.db STICKY sticky :t权限只能给目录添加，当你给一个目录添加了t权限之后，后面所有人在这个目录下不能删除其他人的文件,只能删除自己的文件； 管理文件的Sticky权限： chmod o+|-t FILE 展示位置：其他用户的执行权限位 如果其他用户原本有执行权限，显示为小写t;否则为大写T。 系统上的/tmp和/var/tmp目录下默认均有Sticky权限 基于八进制方式赋权时，可于默认的三位八进制数字左侧再加一位八进制数字； chmod 1777 中的 1 表示特殊权限 . faclfacl:file access control lists 文件访问控制列表文件的额外赋权机制：在原有的u,g,o之外，另一层让普通用户控制赋权给另外的用户或组的赋权机制；查看分区ACL权限是否开启dumpe2fs -h /dev/sda3dumpe2fs命令是查询指定分区详细文件系统信息的命令.选项： -h 仅显示超级块中的信息，而不显示磁盘块组的详细信息 临时开启分区ACL权限： mount -o remount,acl / 重新挂载根分区，并挂载加入acl权限。 永久开启分区ACL权限#vi /etc/fstab UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 dufaults,acl 1 1 加入ACLmount -o remount /:重新挂载文件系统或重启动系统，使修改生效。getfacl filename:查看文件额外的权限setfacl命令： setfacl -m u:username:rw filename 赋权给用户： setfacl -m u:USERNAME:MODE file 赋权给组： serfacl -m g:GROUPNAME:MODE file 撤销赋权:serfacl -x u:USERNAME file serfacl -x g:USERNAME file 递归ACL权限：#setfacl -m u:用户名:权限 -R 目录名 默认ACL权限:默认acl权限的作用是如果给父目录设定了默认的ACL权限，那么父目录中所有新建的子文件都会继承父目录ACL的权限。#setfacl -m d:u:用户名:权限 文件名 setfacl 选项 文件名选项： -m :设定ACL权限 -x :删除指定的ACL权限 -b :删除文件所有的ACL权限 -d :设定默认ACL权限 -k :删除默认ACL权限 -R :递归设定ACL权限 最大有效权限maskmask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限”相与”才能得到用户的真正权限。 A B and r r r r - - - r - - - - 修改最大有效权限：#setfacl -m m:rx filename 设定mask权限为r-x。使用“m:权限”格式。 mask值只能添加ACL权限之后后期更改，当更改mask值以后再添加ACL权限，mask值就会变为777. 文件系统属性chattr权限#chattr [+-=] [选项] 文件或目录名+：增加权限-：删除权限=：等于权限 选项：-i:如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据还可以cp，但不允许建立和删除文件 -a:如果对文件设置a属性，那么只能在文件中增加数据(只能用echo增加数据，不能用vim)，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。chattr +i a.txtlsattr -a a.txt----i--------e- a.txt e:代表此文件在ext4文件系统下建立的。查看文件系统属性：lsattr 选项 文件名 -a显示所有文件和目录 -d若目标是目录，仅列出目录本身的属性，而不是子文件。 sudo权限root把本来只能超级用户执行的命令赋予普通用户执行。sudo的操作对象是系统命令 whereis 命令 查看命令的绝对路径visudo 实际修改的是/etc/sudoers文件root ALL=(ALL) ALL用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径) 被管理的主机地址可写成主机ip和ALL%wheel ALL=(ALL) ALL组名 被管理的主机地址=(可使用的身份) 授权命令(绝对路径) root ALL=(ALL) ALLst 192.168.81.137=/sbin/shutdown -r now 添加内容 st ALL=/usr/bin/vim 危险操作su - st:切换用户sudo -l:查看可用的sudo命令sudo /sbin/shutdown -r now 普通用户执行sudo赋予的命令 linux下查看帮助命令 whatis :用于查询一个命令执行什么功能，并将查询结果打印到终端上whatis ls man :Linux提供了丰富的帮助手册，当你需要查看某个命令的参数时不必到处上网查找，只要man一下即可 man command linux根目录结构和文件系统进程的类型： 终端:硬件设备，关联一个用户接口。 与终端相关:通过终端启动。 与终端无关:操作引导启动过程中自动启动操作系统的组成: 静态:kernel,application 文件系统:层级结构FHS: Filesystem Hierarchy Standard /bin:所有用户可用的基本命令程序文件； /sbin:供系统管理使用的工具程序； /boot:引导加载器必须用到的各种静态文件：Kernel,initramfs(initrd),grub等； /dev:存储特殊文件或设备文件； 设备有两种类型：字符设备(线性设备)、块设备(随机设备)； /etc:系统程序的配置文件，只能为静态： /home：普通的家目录的集中位置：一般每个普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME； /lib:为系统启动或根文件系统上的应用程序（/bin,/sbin）等提供共享库，以及为内核提供内核模块 libc.so.*:动态链接的C库； ld*:运行时链接器/加载器； modules:用于存储内核模块的目录； /lib64:64位系统特有的存放64位共享的路径； /media:便携式设备挂载点，cdrom,floppy等； /mnt:其他文件系统的临时挂载点； /opt：附加应用程序的安装位置：可选路径； /srv:当前主机为服务提供的数据； /tmp:为那些会产生临时文件的程序提供的用于临时文件的目录：可供所用户执行写入操作：有特殊权限； /usr:usr Hierarchy,全局共享的只读数据路径： bin,lib64 include:C程序头文件； share:命令手册页和自带文档等架构特有的文件的存储位置 local:另一个层级目录； X11R6:X-widow程序的安装位置 src:程序源代码文件的存储位置 多命令顺序执行多命令执行符格式作用&amp;&amp;命令1 &amp;&amp; 命令2逻辑与,当命令1正确执行,则命令2才会执行。当命令1执行不正确,则命令2不会执行||命令1 || 命令2逻辑或,当命令1执行不正确,则命令才会执行。当命令1正确执行,则命令2不会执行 通配符通配符作用?匹配一个任意字符*匹配0个或任意多个字符，也就是可以匹配任何内容[]匹配括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者a,或者b,或者c。[^]逻辑非，表示不匹配中括号内的任意一个字符。例如:[^0-9]代表匹配一个不是数字的字符。 Bash中其他特殊符号 符号作用&#39;&#39;单引号。在单引号中所有的特殊符号，如$,`(反引号)都没有特殊含义。&quot;&quot;双引号。在双引号中特殊符号都没有特殊含义，但是$,和\是例外,拥有&quot;调用变量的值&quot; `反引号引用命令,和&quot;转义符&quot;的特殊含义&quot;``反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。$()和反引号作用一样，用来引用系统命令。#在shell脚本中，#开头的行代表注释。$用于调用变量的值,如需要调用变量name的值时，需要用$name的方式得到变量的值时，需要用$name的方式得到变量的值。\转义符,跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出$符号，而不当做是变量引用。. 12345[root@Tiger ~]# name=test [root@Tiger ~]# echo &apos;$name&apos; $name [root@Tiger ~]# echo &quot;$name&quot; test 12345[root@Tiger ~]# abc=`date` [root@Tiger ~]# echo `date` 2018年 09月 09日 星期日 13:10:57 CST [root@Tiger ~]# echo $abc 2018年 09月 09日 星期日 13:10:49 CST 12345[root@Tiger ~]# abc=$(date) [root@Tiger ~]# echo $abc 2018年 09月 09日 星期日 13:12:44 CST [root@Tiger ~]# echo &quot;abc&quot; abc 1234[root@Tiger ~]# echo &quot;$abc&quot; 2018年 09月 09日 星期日 13:12:44 CST 反引号和$ #echo `ls` #echo $(date) Bash 变量什么是变量：变量是计算机内存单元，其中存放的值可以改变。当Shell脚本需要保存一些信息时，如一个文件名或一个数字,就把它存放在一个变量中，每个变量有一个名字，所以很容易引用它，使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。变量设置规则：explanation 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是”2name”则是错误的。 在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。 变量用等号连接值，等号左右两侧不能有空格。 变量的值如果有空格，需要使用单引号或双引号包括。 在变量的值中，可以使用”\”转义符。 如果需要增加变量的值，那么可以进行变量值的叠加，不过变量需要用双引号包含”$变量名”或用${变量名}包含。 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。 环境变量名建议大写，便于区分。变量的分类 用户自定义变量 环境变量:这种变量中主要保存的是和系统操作环境相关的数据。 位置参数变量:这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。 预定义变量:是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定好的。 本地变量变量定义：#name=&quot;bianliang&quot;变量叠加： #aa=123 #aa=$aa456 #aa=${aa}789变量调用：echo $name变量查看：set变量删除：&gt;unset name 环境变量环境变量是什么:用户自定义变量只在当前的Shell中生效，而环境变量会在当前Shell和这个Shell的所有子Shell当中生效。如果把环境变量写入相应的配置文件,那么这个环境变量就会在所有Shell中生效。 pstree:查看进程数,查看当前shell设置环境变量：export 变量名=变量值申明变量:env :查询变量,专门查看环境变量。set:查看所有变量unset 变量名 #删除变量 name=sc 本地变量export age=18 环境变量sex=man 本地变量。把已经定义好的本地变量变成环境变量，只需要：export sex 系统常见环境变量PATH:系统查找命令的路径 #echo $PATH/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/binPATH变量叠加：PATH=&quot;$PATH&quot;:/root/sh(脚本保存目录) ps1:定义系统提示符的变量：\d:显示日期，格式为”星期 月 日”\h:显示简写主机名。如默认主机名”localhost”\t:显示24小时制时间，格式为”HH:MM:SS”\T:显示12小时制时间，格式为”HH:MM:SS”\A:显示12小时制时间，格式为”HH:MM”\u:显示当前用户名\w:显示当前所在目录的完整名称\W:显示当前所在目录的最后一个目录#:执行的第几个命令\$:提示符。如果为root用户会显示提示符为”#”,如果普通用户会显示提示符为”$”。\@:时间 上下午 echo $PS1 :查看提示符[root@Tiger ~]# PS1=&#39;[\u@\t \w]\$ &#39;这里的空格生成以后,提示符后会有一个SPACE的距离。[root@16:10:52 ~]#cd /usr/local/src/[root@16:11:08 /usr/local/src]# #PS1=&#39;[\u@\@]\$&#39;[root@04:13 下午]#PS1=&#39;[\u@\@ \h]\$&#39;[root@04:17 下午 Tiger]#PS1=&#39;[\u \@@]\$&#39;[root 04:18 下午@]#^ 位置参数变量位置参数变量作用$nn为数字,$0代表命令本身,$1-$9代表第一到第九个参数,十以上的参数需要用大括号包含,如${10}$这个变量代表命令行中所有的参数,$把所有的参数看成一个整体$@这个变量也代表命令行中所有的参数,不过$@把每个参数区别对待$#这个变量代表命令行中所有参数的个数位置参数变量的名称和作用是固定的，他是为了接受用户向程序传入不同的值。 123456789101112131415vim ceshi.sh #!/bin/bash echo $0echo $1echo $2echo $3 :wqchmod 755 ceshi.sh./ceshi.sh./ceshi.sh 输出结果是本身./ceshi.sh 11 22 33./ceshi.sh 输11 出22 接33 果 1234567#!/bin/bashnum1=$1num2=$2sum=$(($num1 + $num2)) //变量sum的和是num1加num2echo $sum //打印sum的值chmod 755 ceshi.sh./ceshi.sh 11 22 123456789#!/bin/bashecho $#echo $*echo $@chmod 755 ceshi.sh./ceshi.sh 11 22 33 44 55 66 6 11 22 33 44 55 6611 22 33 44 55 66 预定义变量预定义变量作用$?最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行;如果这个变量的值非0(具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确了。$$当前进程的进程号(PID)$!后台运行的最后一个进程的进程号(PID)/td&gt;在Linux里面输入一条命令正确执行以后，输入echo $? ，默认输出 0当输出一条错误的命令以后，会系统报错，输入echo $? ，默认输出 127 123456789#!/bin/bashecho &quot;$$&quot;find /root -name hello.sh $ // $符号的作用是把程序放在后台echo &quot;$!&quot;chmod 755 ceshi.sh./ceshi.sh2788827888 接受键盘输入read [选项][变量名] -p&quot;提示信息&quot;:在等待read输入时,输出提示信息 -t 秒数:read命令会一直等待用户输入，使用此选项可以指定等待时间。 -n 字符数:read命令只接受指定的字符数，就会执行 -s:隐藏输入的数据，适用于机密信息输入。 数值运算与运算符declare声明变量类型declare [+/-][选项] 变量名 -:给变量设定类型属性 +取消变量的类型属性 -i:将变量声明为整数型(integer) -x:将变量声明为环境变量 -p:显示指定变量的被声明的类型数值运算方法1: [root@Tiger data]#aa=11 [root@Tiger data]#bb=22给变量aa和bb赋值 [root@Tiger data]#declare -i cc=$aa+$bb方法2:expr或let数值运算工具 [root@Tiger data]#aa=11[root@Tiger data]#bb=22给变量aa和变量bb赋值 [root@Tiger data]#dd=$(expr $aa + $bb)$dd的值是aa和bb的和,注意”+”号左右两侧必须有空格方法3:$((运算式))或$[运算式] aa=11bb=22gg=$(($aa+$bb))ff=$[$aa+$bb] 运算优先级 优先级从上到下优先级运算符说明13-，+单目负,单目正12!，~逻辑非，按位取反或补码11*，/，%乘、除、取余10+，-加、减9&lt;&lt;，&gt;&gt;按位左移、按位右移8&lt;=，&gt;=，&lt;，&gt;小于或等于、大于或等于、小于、大于7==，!==等于、不等于6&amp;按位与5^按位异或4|按位或3&amp;&amp;逻辑与2||逻辑或1=，+=，-=， ，*=，/=，%=，&amp;=，^=，|=，&lt;&lt;=，&gt;&gt;=赋值、运算且赋值. 变量测试与内容替换 123456789101112131415[root@Tiger ~]# unset y[root@Tiger ~]# x=$&#123;y-new&#125;[root@Tiger ~]# echo $y[root@Tiger ~]# echo $xnew[root@Tiger ~]# y=&quot;&quot;[root@Tiger ~]# x=$&#123;y-new&#125;[root@Tiger ~]# echo $x[root@Tiger ~]# y=old[root@Tiger ~]# x=$&#123;y-new&#125;[root@Tiger ~]# echo $xold[root@Tiger ~]# 环境变量配置文件1source 配置文件 或 调用文件的命令1. 配置文件 环境变量配置文件简介：环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如PATH,HISTSIZE,PS1,HOSTNAME等默认环境变量。环境变量配置文件:①/etc/profile②/etc/profile.d/*.sh *是通配符，代表这个目录下所有以.sh结尾的文件。③~/.bash_profile④~/.bashrc⑤/etc/bashrc其中3个在/etc/下面的变量配置文件是对所有登录Linux用户生效。另外两个是用户家目录下的隐藏文件只对当前用户生效。 其他的配置文件和登录信息 注销时生效的环境变量配置文件：~/.bash_logout :这个文件默认是空的，如果想要每次登录比如清空历史命令或者把自己的环境变量清空等，写入后，注销时他会自动执行 ~/bash_history :保存的历史命令，但是有一些他还保存在内存当中，除非是手工写入history -w或者注销登录才会把内存中的命令转移到这个文件中去。 Shell登录信息 本地终端欢迎信息:/etc/issue只对本地登录有显示效果 转义符作用\d显示当前系统日期\s显示操作系统名称\l显示登录的终端号,这个比较常用\m显示硬件体系结构,如i386、i686等\n显示主机名\o显示域名\r显示内核版本\t显示当前系统时间\u显示当前登录用户的序列号 远程终端欢迎信息: /etc/issue.net (上图的转义符本文件不能使用,只能使用纯文本信息)转义符在/etc/issue.net文件中不能使用是否显示此欢迎信息,由ssh的配置文件 /etc/ssh/sshd_config决定，加入&quot;Banner /etc/issue.net&quot;行才能显示(记得重启SSH服务) 登录后显示 欢迎信息: /etc/motd 不管是本地登录,还是远程登录,都可以显示此欢迎信息.直接写入此文件即可 正则表达式与通配符正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配。grep、awk、sed等命令可以支持正则表达式。 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配。 元字符 作用*前一个字符匹配0次或任意多次.匹配除了换行字符外任意一个字符^匹配行首。例如：^hello 会匹配以hello开头的行。$匹配行尾。例如：hello$ 会匹配以hello结尾的行[]匹配中括号中指定的任意一个字符，只匹配一个字符。例如：[aeiou]匹配任意一个元音字母，[0-9]匹配任意一位数字，[a-z][0-9]匹配小写字母和一位数字构成的两位字符[^]匹配除中括号的字符以外的任意一个字符。例如：[^0-9]匹配任意一位非数字字符，[^a-z]表示任意一位非小写字母。\转义符。用于取消将特殊符号的含义取消。\{n\}表示其前面的字符恰好出现n次。例如：[0-9]\{4\}匹配4为数字，[1][3-8][0-9]\{9\}匹配手机号码\{n,\}表示其前面的字符出现不小于n次。例如：[0-9]\{2,\}表示两位及以上的数字\{n,m\}表示其前面的字符至少出现n次，最多出现m次。例如：[a-z]\{6,8\}匹配6到8位的小写字母 *前一个字符匹配0次，或任意多次grep &quot;a*&quot; ceshi.txt 匹配所有内容，包括空白行grep &quot;aa*&quot; ceshi.txt 匹配至少包含有一个a的行grep &quot;aaa*&quot; ceshi.txt 匹配最少包含两个连续a的字符串grep &quot;aaaaa&quot; a.txt 则会匹配最少包含四个连续的a的字符串. 匹配除了换行符外任意一个字符grep &quot;s..d&quot; a.txt s..d会匹配s和d这两个字符之间一定有两个字符的单词grep &quot;s.*d&quot; a.txt 匹配在s和d字母之间有任意字符grep &quot;.*&quot; a.txt 匹配所有内容^ 匹配行首，$匹配行尾grep &quot;^M&quot; a.txt 匹配以大写M开头的行grep &quot;n$&quot; a.txt 匹配以小写n结尾的行grep -n &quot;^$&quot; a.txt 会匹配空白行,-n 显示行号[] 匹配中括号中指定的任意一个字符，只匹配一个字符grep &quot;s[ao]id&quot; a.txt 匹配s和i字母中，要么是a要么是ogep &quot;[0-9]&quot; a.txt 匹配任意一个数字grep &quot;^[a-z] a.txt 匹配用小写字母开头的行grep &quot;^[a-z]&quot; a.txt 匹配用小写字母开头的行 ^ 匹配除中括号的字符以外的任意一个字符grep &quot;^[^a-z]&quot; a.txt 匹配不用小写字母开头的行grep &quot;^[^a-zA-Z]&quot; a.txt 匹配不多字母开头的行\ 转义符grep &quot;\.$&quot; a.txt 匹配使用.结尾的行\{n\} 表示其前面的字符恰好出现n次grep &quot;a\{3\}&quot; a.txt 匹配a字母连续出现三次的字符串grep &quot;[0-9]\{3\}&quot; a.txt 匹配包含连续的三个数字的字符串{n,\} 表示其前面的字符出现不小于n次grep &quot;^[0-9]\{3,\}&quot; a.txt 匹配最少用连续三个数字开头的行\{n,m} 匹配其前面的字符至少出现n次，最多出现m次grep &quot;sa\{1,3\}i&quot; a.txt 匹配在字母s和字母i之前有最少一个a,最多三个a 字符截取命令cut 字段提取命令printf 命令 (严格意义上讲他不属于字符截取命令，因为awk要用到，在这里提出)awk 命令sed 命令cut [选项][文件名] -f 列号: 提取第几列 -d 分隔符: 按照指定分隔符分割列.他的默认分隔符是Tabcut -f &quot;:&quot; -f 1,3 /etc/passwd12345[root@Tiger data]# vim b.txt 这里的空格是Tab键 1 ID NAME gender mark 2 1 liming M 86 3 2 sc M 90 4 3 cao M 83 12345[root@Tiger data]# cut -f 2 b.txtNAMElimingsccao 12345[root@Tiger data]# cut -f 2,4 b.txt NAME markliming 86sc 90cao 83 cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1 常和grep结合使用，查看用户文件，查找普通用户，过滤root，提取用户名称 cut命令的局限df -h | grep /dev/sda3 | cut -d &quot; &quot; -f 5 df命令使用的是空格分隔符，这条命令不能使用，cut对空格使用不友好 printf &#39;输出类型输出格式&#39; 输出内容输出类型:%ns：输出字符串。n是数字指代输出几个字符%ni：输出整数。n是数字指代输出几个数字%m.nf：输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2是小数，6位是整数。 输出格式作用\a输出警告音\b输出退格键，也就是Backspace键\f清除屏幕\n换行\r回车，也就是Enter键\t水平输出退格键，也就是Tab键\v垂直输出退格键，也就是Tab键12345678910[root@Tiger data]# printf %s 1 2 3 4 5 6123456[root@Tiger data]# [root@Tiger data]# printf %s %s %s 1 2 3 4 5 6%s%s123456[root@Tiger data]# [root@Tiger data]# printf &apos;%s %s %s&apos; 1 2 3 4 5 61 2 34 5 6[root@Tiger data]# [root@Tiger data]# printf &apos;%s %s %s\n&apos; 1 2 3 4 5 61 2 34 5 6[root@Tiger data]# printf输出文件内容格式：printf &#39;%s\n&#39; $(cat a.txt)123456[root@Tiger data]# printf &apos;%s\t %s\t %s\t %s\n&apos; $(cat b.txt) 调整格式输出ID NAME gender mark1 liming M 862 sc M 903 cao M 83[root@Tiger data]# 在awk命令的输出中支持print和printf命令print：print会在每个输出之后自动加入一个换行符(linux 默认没有print命令)printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工换行符。 awkawk ‘条件1{动作1} 条件2{动作2}…’ 文件名条件：一般使用关系表达式作为条件x &gt; 10 判断变量x是否大于10x &gt;= 10 大于等于x &lt;= 10 小于等于动作：格式化输出流程控制语句df -h | awk &#39;{print $1 &quot;\t&quot; $5 &quot;\t&quot; $6}&#39; print 自动加入换行符 12[root@Tiger data]# df -h | grep sda3 | awk &apos;&#123;print $5&#125;&apos; | awk -F &apos;%&apos; &apos;&#123;print $1&#125;&apos;62 12[root@Tiger data]# df -h | grep sda3 | awk &apos;&#123;print $5&#125;&apos; | cut -d &quot;%&quot; -f 162 BEGIN END123456awk &apos;BEGIN &#123;printf &quot;打印这里的文字\n&quot;&#125;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&apos; a.txt打印这里的文字NAME genderliming Msc Mcao M awk &#39;{FS=&quot;:&quot;}{print $1 &quot;\t&quot; $3}&#39; /etc/passwd 这样执行的话第一条会无法分割，所以可以在awk &#39;BEGIN{FS=&quot;:&quot;}{print $1 &quot;\t&quot; $3}&#39; /etc/passwd, awk是先读取一行在再执行命令，这样文件的第一行会来不及执行默认空格换行打印出。But但是可以直接用awk -F &quot;:&quot; &#39;{print $2 &quot;\t&quot; $3}&#39; /etc/passwdawk -F &quot;:&quot; &#39;END{print &quot;所有的命令执行完以后再执行&quot;&quot;}{print $2 &quot;\t&quot; $3}&#39; /etc/passwd关系运算符12345678910[root@Tiger data]# cat b.txtID NAME gender mark1 liming M 862 sc M 903 cao M 83[root@Tiger data]# cat b.txt | grep -v NAME | awk &apos;$3 &gt;= 87 &#123;print $2&#125;&apos; limingsccao[root@Tiger data]# sedsed 是一种几乎包括在所有UNIX平台(包括linux)的轻量级流量编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。vi 只能修改文件，但是vi不能修改命令的输出，他只能先把命令的输出保存在文件中，然后修改文件的输出。但是sed可以修改命令的输出结果，结合管道符。sed [选项] &#39;[动作]&#39;文件名-n :一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。 -e :允许对输入数据应用多条sed命令编辑-i :用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出。 动作作用a\追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用\代表数据未完结c\行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用\代表数据未完结i\插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用\代表数据未完结d删除，删除指定的行p打印，输出指定的行s字符替换，用一个字符串替换另外一个字符串。格式为行范围s/旧字符串/新字符串/g(和vim中的替换格式类似). 12345[root@Tiger data]# cat a.txt 例:ID name PHP Linux Mysql Average1 Liming 82 95 86 87.662 Sc 74 96 87 85.663 Gao 99 83 93 91.66 行操作查看文件的第二行12345678[root@Tiger data]# sed &apos;2p&apos; a.txtID name PHP Linux Mysql Average1 Liming 82 95 86 87.661 Liming 82 95 86 87.662 Sc 74 96 87 85.663 Gao 99 83 93 91.66[root@Tiger data]# sed -n &apos;2p&apos; a.txt1 Liming 82 95 86 87.66 删除文件第2行到第4行，可以看到没有对文件本身造成影响1234567[root@Tiger data]# sed &apos;2,4d&apos; a.txtID name PHP Linux Mysql Average[root@Tiger data]# cat a.txtID name PHP Linux Mysql Average1 Liming 82 95 86 87.662 Sc 74 96 87 85.663 Gao 99 83 93 91.66 在第二行后追加hello1sed &apos;2a hello&apos; a.txt 在第二行前插入两行数据12sed &apos;2i hello\world&apos; a.txt 修改第四行文件。将第四行的99替换成5512345678910[root@Tiger data]# sed &apos;4c no file&apos; a.txtID name PHP Linux Mysql Average1 Liming 82 95 86 87.662 Sc 74 96 87 85.66no file[root@Tiger data]# sed &apos;4s/99/55/g&apos; a.txtID name PHP Linux Mysql Average1 Liming 82 95 86 87.662 Sc 74 96 87 85.663 Gao 55 83 93 91.66 字符替换 sed &#39;s/旧字符/新字符/g&#39; 文件名在第3行中，把74换成991sed &apos;3s/74/99/g&apos; a.txt sed操作的数据直接写入文件1sed -i &apos;3s/74/99/g a.txt&apos; 同时把linux和Gao替换为空1sed -e &apos;s/Linux//g;s/Gao//g/a.txt&apos; 前面没有加行号代表整篇文档 字符处理命令统计命令 wc -l :只统计行数 -w :只统计单词数 -m :只统计字符数 sort见command 条件判断按照文件类型判断测试选型作用-b 文件判断该文件是否存在，并且是否为块设备文件(是块设备文件为真)-c 文件判断该文件是否存在，并且是否为字符设备文件(是字符设备文件为真)-d 文件判断该文件是否存在，并且是否为目录文件(是目录为真)-e 文件判断该文件是否存在，(存在为真)-f 文件判断该文件是否存在，并且是否为普通文件(是普通文件为真)-L 文件判断该文件是否存在，并且是否为符号链接文件(是符号链接文件为真)-p 文件判断文件是否存在，并且是否为管道文件(是管道文件为真)-s 文件判断该文件是否存在，并且是否为非空(非空为真)-S 文件判断该文件是否存在，并且是否为套接字文件(是套接字文件为真) 判断文件是否存在(两种格式)test -e /root/install.log-e /root/install.log]第一个判断命令如果正确执行，则打印”yes”，否则打印”no”[ -d /root ] &amp;&amp; echo &quot;yes&quot; || &quot;no&quot;注意空格 按照文件权限进行判断测试选项作用-r 文件判断该文件是否存在，并且是否该文件拥有读权限(有读权限为真)-w 文件判断该文件是否存在，并且是否该文件拥有写权限-x 文件判断该文件是否存在，并且是否该文件拥有执行权限(有执行权限为真)-u 文件判断该文件是否存在，并且是否该文件拥有SUID权限(有SUID权限为真)-g 文件判断该文件是否存在，并且是否该文件拥有SGID权限(有SGID权限为真)-k 文件判断该文件是否存在，并且是否该文件拥有SBit权限(有SBit权限为真). 1test -w /data/a.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 他只要UGO只要有一个有写权限就会执行出来 两个文件之间进行比较测试选项作用文件1 -nt 文件2判断文件1的修改时间是否比文件2的新(如果新则为真)文件1 -ot 文件2判断文件1的修改时间是否比文件2的旧(如果旧则为真)文件1 -ef 文件2判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法比较硬链接的文件Inode号1test a.txt -ef /tmp/a1.txt &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 两个整数之间比较测试选项作用整数1 -eq 整数2判断整数1是否和整数2相等 (相等为真)整数1 -ne 整数2判断整数1是否和整数2不相等 (不相等为真)整数1 -gt 整数2判断整数1 是否大于整数2 (大于为真)整数1 -lt 整数2判断整数1是否小于整数2 (小于为真)整数1 -ge 整数2判断整数1是否大于等于整数2 (大于等于为真)整数1 -le 整数2判断整数1是否小于等于整数2 (小于等于真)1[ 23 -gt 22 ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot; 注意[]左右的空格 字符串的判断测试选项作用-z 字符串判断字符串是否为空(为空返回真)-n 字符串判断字符串是否为非空(非空返回真)子串1 == 子串2判断子串1是否和子串2相等(相等返回真)子串1 ！= 子串2判断字符串1是否和字符串2不相等(不相等为真). 1234[root@Tiger data]# name=scYou have new mail in /var/spool/mail/root[root@Tiger data]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;Y&quot; || echo &quot;N&quot;N 1234[root@Tiger data]# aa=abc[root@Tiger data]# bb=abc[root@Tiger data]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;y&quot; || echo &quot;N&quot;y 多重条件判断测试选项作用判断1 -a 判断2逻辑与，判断1和判断2都成立，最终的结果才为真判断1 -o 判断2逻辑或，判断1和判断2有一个成立，最终的结果就为真! 判断逻辑非，使原始的判断式取反12345[root@Tiger data]# aa=24[root@Tiger data]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot;yes[root@Tiger data]# [ -z &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;NO&quot; NO 流程控制语句if123456789单分支if条件语句：if [ 条件判断 ] ;then 程序fi或者if [ 条件判断 ] then 程序fi 单分支条件语句需要注意几个点if语句使用fi结尾,和一般语言使用大括号结尾不同[ 条件判断 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格then后面跟符合条件之后执行的程序，可以放在[]之后，用:分割，也可以换行写入，就不需要；了. 12345678910111213141516171819判断用户输入的是什么文件#!/bin/bashread -p &quot;Please input a filename: &quot; fileif [ -z $file ] then echo &quot;Error please input a filenmae&quot; exit 1 1elif [ ! -e $file ] then echo &quot;Your input is not file!&quot;elif [ -f $file ] then echo &quot;$file is a reguare file&quot;elif [ -d $file ] then echo &quot;$file is a directory file!&quot;else echo &quot;$file is a other file&quot;fi 12345678910111213141516171819备份/etc/目录#!/bin/bashdate=$(date +%F)size=$(du -sh /home)if [ -d /tmp/date ] then echo &quot;date is:$date&quot; &gt; /tmp/date/a.txt echo &quot;size is:$date&quot; &gt;&gt; /tmp/date/a.txt cd /tmp/date tar -zcf home_$date.tar.gz /home a.txt &amp;&gt;/dev/null rm -fr /tmp/date/a.txtelse mkdir /tmp/date echo &quot;date is:$date&quot; &gt; /tmp/date/a.txt echo &quot;size is:$date&quot; &gt;&gt; /tmp/date/a.txt cd /tmp/date tar -zcf home_$date.tar.gz /home a.txt &amp;&gt;/dev/null rm -fr /tmp/date/a.txtfi nmap -sT ip地址：-sT作用扫描指定服务器查找的开放端口12345678910判断sshd服务是否开启#!/bin/bashport=$(nmap -sT 192.168.100.136 | grep ssh | awk &apos;&#123;print $2&#125;&apos;)if [ $port == &quot;open&quot; ] then echo &quot;$(date) sshd is ok!!&quot; &gt;&gt; /tmp/sshd_acc.log else /etc/rc.d/init.d/sshd restart &amp; &gt;/dev/null echo &quot;$(date) sshd reboot!!&quot; &gt;&gt; /tmp/sshd_err.logfi case语句多分支case条件语句 case语句和if…elif…else语句一样，都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。123456789101112131415161718 1 #!/bin/bash 2 echo &apos;shanghai please input &quot;dddd&quot;&apos; 3 echo &apos;guangzhou please input &quot;2&quot;&apos; 4 echo &apos;chengdu please input &quot;3&quot;&apos; 5 read -t 30 -p &quot;Please input your weizhi: &quot; u 6 case $u in 7 &quot;dddd&quot;) 8 echo &quot;shanghai de &quot; 9 ;;10 &quot;2&quot;)11 echo &quot;guangzhou&quot;12 ;;13 &quot;3&quot;)14 echo &quot;chengdu&quot;15 ;;16 *)17 echo &quot;error 1/2/3&quot;18 esac for循环语法一：for 变量 in 值1 值2 值3 do 程序 done12345678910查看当前目录有多少.sh结尾的文件。 #!/bin/bash 2 cd /home/ceshi.sh 3 ls *.sh &gt; ls.log 4 y=1 5 for i in $(cat ls.log) 6 do 7 echo $y 8 y=$(( $y + 1)) 9 done 语法二：for((初始值；循环控制条件；变量变化)) do 程序 done12345678从1加到100 #!/bin/bash 2 s=0 3 for (( i=1;i&lt;=100;i=i+1 )) 4 do 5 s=$(( $s+$i )) 6 done 7 echo $s while循环while循环是不定循环，也称作条件循环。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和for的固定循环不太一样了。1234while [ 条件判断式 ] do 程序 done 1234567891 #!/bin/bash 2 i=1 3 s=0 4 while [ $i -le 100 ] 5 do 6 s=$(( $s+$i )) 7 i=$(( $i+1 )) 8 done 9 echo $s until循环until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。123456789#!/bin/bashi=1s=0until [ $i -gt 100 ] do s=$(( $s+$i )) i=$(( $i+1 )) doneecho $s 服务的简介与分类启动与自启动 服务器启动: 就是在当前系统中让服务运行，并提供功能。 服务自启动: 自启动是指让服务在系统开机重启动之后，随着系统的启动而自动启动服务。rpm包安装的服务：chkconfig --list :查看服务自启动状态，可以看到所有RPM包安装的服务源码包安装的服务：查看服务安装位置，一般是/usr/local下RPM安装服务和源码包安装服务的区别： 就是安装位置的不同 源码包安装包安装在指定位置，一般是/usr/local/RPM包安装在默认位置中service 不能用于源码包，因为service默认搜索的是/etc/rc.d/init.d/这个路径，也就是RPM包安装的路径RPM包的一般存放的默认位置：/etc/init.d/ :启动脚本位置/etc/sysconfig/ :初始化环境配置文件位置/etc/ :配置文件位置/etc/xinted.conf ：xinetd配置文件/etc/xinetd.d/ :基于xinetd服务的启动脚本/var/lib/ :服务产生的数据放在这里/var/Log/ :日志 独立服务的启动：/etc/init.d/独立服务名 start|stop|status|restartservice 独立服务名 start|stop|status|restart status 查询服务的状态 service 红帽专有命令 service –status-all 列出系统所有已经安装的RPM包服务的状态 独立服务的自启动chkconfig命令 （详见command）修改/etc/rc.d/rc.local文件使用ntsysv命令管理自启动(红帽专有命令) 基于xinetd服务 yum -y install xinetd这是可以用chkconfig –list 查看服务可以看到基于xinetd的服务 yum -y install telnet-server 安装telnet服务端chkconfig –list 查看安装的服务Telnet的默认端口是23，netstat -tlun telnet服务还没有开启xinetd服务的启动：vim /etc/xinetd.d/telnet 修改文件service xinetd restart 重启xinetd服务 基于xinetd服务的自启动chkconfig telnet onntsysv 基于xinetd 服务的启动与自启动区别不明显，若关闭telnet(chkconfig telnet off)的自启动会将运行的telnet一并关闭，配置文件也会显示关闭状态。 . 源码包安装服务的启动使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。源码包服务的自启动：vi /etc/rc.d/rc.local 开机自启文件，加入下面的标准启动命令/usr/local/apache2/bin/apachectl start 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动vi /etc/init.d/apache# chkconfig: 35 86 76指定httpd脚本可以被chkconfig命令管理。格式是:chkconfig: 运行级别 启动顺序 关闭顺序#descriptaion:source package apache 说明，内容随意 启动顺序和关闭顺序不能和系统中现有服务的启动关闭顺序一样在/etc/rc.d/可以看到各个启动级别的服务启动关闭文件。例/etc/rc.d/rc3.d里面的文件S01表示依次启动，K01表示依次关闭。不能存在一样的启动关闭级别。 服务的总结： 进程管理进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源. body{ background-image:url(https://ws1.sinaimg.cn/large/005RRiqRly1fvyygdfzt6j31hc0u0138.jpg); background-position:center; background-repeat:repeat-y； }]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mage]]></title>
    <url>%2F2018%2F08%2F28%2F%E9%A9%AC%E5%93%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linux 培训的笔记 命令积累lscpu 查看cpu信息 lsblk （列出块设备）命令用于列出所有可用块设备的信息sosreport 收集日志 查看内存：cat /proc/meminfopartorobe 新分区不用重启的识别命令。刷新硬盘分区表 centos7partx -a centos6 -a对于增加硬盘的选项partx -d --nr 6 /dev/sda 对于删除分区后，刷新硬盘的选项 用户的UID大于500的都是非系统账号，500以下的都为系统保留的账号 进制转换123456789101112130 01 110 2 11 3100 4 101 5 110 6 111 71000 8(2^3)10000 16(2^4)100000 32(2^5)1000000 64(2^6)10000000 128(2^7) 2^0=1 2^1=2 2^2=4 2^3=8 16 32 64 128例：97(十进制)=64+32+1=1000000+100000+1=1100001。例：10101010(二进制)=128+32+8+2=170。1Gbps：每秒传输1g的位。1Gbit/second1Byte=8bit touch建立带-的文件:touch -- -atouch ./-b DAS NAS SAM 存储基础知识—存储网络 DAS NAS SAM 传输类型 SCSI、FC IP IP、FC、SAS 数据类型 数据块 文件 数据块 典型应用 任何 文件服务器 数据库应用 优点 磁盘与服务器分离，便于统一管理 不占用应用服务器资源 高扩展性，高可用性，数据集中，易管理 缺点 连接距离短，数据分散，共享困难，存储空间利用率不高，扩展性有限 不适合存储大量的块级应用，数据备份已恢复占用网络带宽 相比NAS成本较高，安装和升级比NAS复杂 分区分区分配一个目录名mount point,名为挂载分区：MBR,GPT主：一个硬盘最多有四个，只有一个是活动，1-4扩展：最多一个，划分更小的分区，扩展+主分区&lt;=4 1-4逻辑分区：5,6 运行模式：runlevel3 5.3表示前一次的运行级别，5表示现在的运行级别N:表示前一次没有运行级别 。init 3：切换到3级别，init要登录startx:切换到？级别，startx不需要登录5：字符界面 0：关机 6：重启 终端tty显示终端号chvt 2:表示ctrl+Alt+F2切换到的界面 centos7启动网络启动网络：nmcli connection modify ens33 connection.autoconnect yesid -u:当前用户的UID，root为0，非0为普通用户。 查看版本号cat /etc/centos-release lsb_release -a 命令提示符查看：echo $PS1更改：PS1=&quot;\[\e[1;33m\][\u@\h \w \!]\\$\[\e[0m\]&quot;命令提示符:prompt # :管理员 $ :普通用户显示提示符格式：echo $PS1修改提示符格式：PS1=&quot;\e[1;33m\[[\u@\h \W]\\$\\e[0m&quot;PS1=&#39;\e[1;33m[\u@\h \w]\$ &#39; \e \033 \u 当前用户 \h 主机名称 \H 主机名 \w 当前工作目录 \W 当前工作目录最后目录名 \t 24小时时间格式 \T 12小时时间格式 \！命令历史数 \# 开机后命令历史数cat ~/.bashrc 命令提示符当前用户修改路径 虚拟机取消密码进入123vim /etc/gdm/custom.conf AutomaticLoginEnable=true AutomaticLogin=root 查看命令类型type pwd:显示命令的类型外部命令或者内部命令 -a :显示所有的内部命令后外部命令的列表 执行命令输入命令后回车:提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来。在shell中可执行的命令有两类1.内部命令：由shell自带的，而且通过某种命令形式提供 help内部命令列表enable cmd 启动内部命令enable -n cmd 禁用内部命令enable -n 查看所有禁用的内部命令2.外部命令：在文件系统路径下有对应的可执行程序文件查看路径：which -a |–skip-alias; whereis3.区别指定的命令是内部或外部命令type COMMANDwhereis:查看外部命令路径和他的配置文件文档路径 命令执行路径alias –内部 –hash表(记录外部命令的路劲) –$PATH –命令找不到 Hash缓存表 系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将这条命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先会查看hash表，存在将执行之，如果不存在，将会去PATH路径下寻找，利用hash缓存表可大大提高命令的调用率。 hash常见用法 hash 显示hash缓存 hash -l 显示hash缓存，可作为输入使用 hash -p path name 将命令全路径path起别名为name hash -t name 打印缓存中name的路径 hash -d name 清除name缓存 hash -r 清除缓存 别名显示当前shell进程所有可用的命令别名alias定义别名NAME，其相当于执行命令VALUEalias NAME=&#39;VALUE&#39;在命令行中定义的别名，仅对当前shell进程有效如果想要永久有效，要定义在配置文件中 仅对当前用户： ~/.bashrc 对所有用户有效： /etc/bashrc 写入文件后，文件存储在磁盘上没有生效，必须让他在内存中才会生效，使用命令source.bashrc删除别名(指在内存中删除)：unalias 别名编辑配置给出的新配置不会立即生效bash进程重新读取配置文件. 12source /path/to/config_file./path/to/config_file 撤销别名: unalias [name] -a取消所有别名如果别名同原命令同名，如果要执行原命令，可使用12345\ALIASNAME&quot;ALIASNAME&quot;&apos;ALIASNAME&apos;command ALIASNAME/path/command 针对外部命令 . 日期和时间linux的两种时钟系统时钟：由Linu内核通过CPU的工作频率进行的硬件时钟：主板相关命令:date 显示和设置系统时间 date +%s date -d @1509536033hwclock,clock:显示硬件时钟-s,–hctosys 以硬件时钟为准，校正系统时钟-w,–systohc 以系统时钟为准，校正硬件时钟时区：/etc/localtime显示日历：cal whoami用户登录信息查看命令:whoami :显示当前登录有效用户who :系统当前所有的登录会话w :系统当前所有的登录会话及所做的操作. 远程协助：screen screen 命令：创建新screen会话 screen -S [SESSION]加入screen会话 screen -x [SESSION]退出并关闭screen会话 exit剥离当前screen会话 Ctrl+a,d显示所有已经打开的screen会话 screen -ls恢复screen会话 screen -r [SESSION]. echolinux中换行表示：移动到下一行回车：光标移动到行首说明：echo会将输入的字符送往输出。输出的字符串间以空白字符隔开，并在最后加上换行号。-E :(默认)不支持\解释功能 -n :不自动换行 -e :启用\字符的解释功能 显示变量：echo &quot;$VAR_NAME&quot; 变量会替换，弱引用 单双引号的区别echo &#39;$VAR_NAME&#39; 变量会替换，强引用反引号里面可执行命令（可用$(命令)代替）`` ls -l `echo $SHELL` 得到的是/bin/bash 文件的详细信息 启用命令选项：-e,若字符串中出现以下字符，则特别加以处理，而不会将他当成一般文字输出\a :发出警告声\b :退格键\c :最后不加上换行符号\n :换行且光标移动至行首\r :回车，即光标移动至行首，但不换行\t :插入Tab字符\ :插入\字符\0nnn :插入nnn(八进制)所代表的ASCII字符 echo -e &#39;\033[43;31;5mmagedu\033[0m&#39;\xHH插入HH(十六进制)所代表的ASCII数字(man 7 ascii) hexdump查看”二进制”文件的十六进制编码123456[root@centos7localdomain ~]# hexdump -C a00000000 31 0a |1. |00000002[root@centos7localdomain ~]# hexdump -C a00000000 31 32 0a 33 0a 61 0a |12.3.a. | 00000007 查看文件a的十六进制和ASCII码。偏移量；十六进制；ASCII码； 原始数据 （最后有空格）文件原始数据每行一个数。 Centos7设置语言localectl list-locales查看语言列表localectl set-locale LANG=en_US.utf8 修改修改后要注销再登录cat /etc/locale.conf 符号命令行扩展，被括起来的集合命令行扩展: $()或``把一个命令的输出打印给另一个命令的参数 1234echo &quot;This system&apos;s name is $(hostname)&quot;This system&apos;s name is server1.example.com echo &quot;i am `whoami`&quot;i am root 括号扩展:{}打印重复字符串的简化形式echo file{1,3,5} 结果为: file1 file3 file5rm -fr file{1,3,5}echo {1..10}echo {a..z}. whatiscentos6生成whatis数据库:makewhatisCentos7: mandbwhatis:显示命令的简短叙述;使用数据库;刚安装后不可立即使用makewhatis | mandb 制作数据库使用示例: whatis cal 或 man -f cal history 重复前一个命令使用上方向键，并且执行 按!!并回车执行 输入!-1执行倒数第一个命令 按Ctrl+p 并回车执行!:0 执行前一条命令(去除参数)Ctrl+n 显示当前历史中的下一条命令，但不执行Ctrl+j 执行当前密令!n 执行history命令输出对应序号n的命令!-n 执行history历史中倒数的第n个命令!string 重复前一个以”string”开头的命令!?string 重复前一个包含string的命令!string:p 仅打印命令历史，而不执行!$:p 打印输出!$(上一条命令的最后一个参数)的内容!*:p 打印输出!*(上一条命令的所有参数)的内容^string 删除上一条命令中的第一个string^string1^string2 将上一条命令中的第一个string1替换为string2!:g/s/string/string2 将上一条命令中所有的string1都替换为string2 3. 使用up(向上)和down(向下)键上下浏览从前输入的命令ctrl+r 在历史命令中搜索ctrl+g 从历史搜索模式中退出要重新调用前一个命令中最后一个参数：!$ESC,.(点击ESC键后松开，然后点击.键)Alt+. (按住Alt键的同时点击.键) 4. command !^ 利用上一个命令的第一个参数做cmd的参数.command !$ 利用上一个命令的最后一个参数做cmd的参数command !* 利用上一个命令的全部参数做cmd的参数command !:n 利用上一个命令的第n个参数做cmd的参数command !n:m 调用第n条命令的第m个参数command !n:* 调用第n条命令的所有参数 -c :清空命令历史 -d offser :删除历史中指定的第offser个命令 n :显示最近的n条历史 -a :追加本次会话新执行的命令历史列表至历史文件 -r :读历史文件附加到历史列表 -w :保存历史列表到指定的历史文件 -n :读取历史文件中未读过的行到历史列表 -p :展开历史参数成多行，但不存在历史列表中 -s :展开参数成一行，附加在历史列表后 -p:可以执行命令但不存在历史记录中。-s:伪造历史，不执行命令。HISTTIMEFORMAT=&quot;%F %T &quot;历史加上时间. 5.命令历史相关环境变量 HISTSIZE :命令历史记录的条数HISTFILE :指定历史文件，默认为~/.bash_history HISTFILESIZE :命令历史文件记录历史的条数 HISTTIMEFORMAT= “%F %T” 显示时间 HISTIGNORE= “str1:str2*……” 忽略str1命令，str2开头的历史 控制命令历史的记录方式： 环境变量：HISTCONTROL ignoredups 默认，忽略重复的命令，连续且相同为”重复” ignorespace 忽略所有已空白开头的命令 ignoreboth 相当于ignoredups,ignorespace的组合 erasedups 删除重复命令export 变量名=”值”存放在 /etc/profile 或 ~/.bash_profile. man查看man手册页 man [章节] keyword列出所有帮助 man -a keyword搜索man手册 man -k keyword 列出所有匹配的页面相当于whatis 数据库 man -f keyword打印man帮助文件的路径 man -w [章节] keyword man 命令的操作方法：使用less 命令实现待续写 man搜索待续写 bash 的快捷键Ctrl + l 清屏，相当于clear命令Ctrl + o 执行当前命令，并重新显示本命令Ctrl + s 阻止屏幕输出，锁定Ctrl + q 允许屏幕输出Ctrl + c 终止命令Ctrl + z 挂起命令 基名，目录名basename :取文件基名dirname :取文件目录名 centos6自动挂载cd /misc/cd 目录磁盘会自动挂载 通配符* 匹配零个或多个字符? 匹配任何单个字符~ 当前用户家目录 ~mage 用户mage家目录~+ 当前工作目录~- 前一个工作目录[0-9] 匹配数字范围 [a-z]:字母 [A-Z]:字母 [wang]匹配列表中的任何的一个字符[^wang] 匹配列表中的所有字符以外的字符ls 1[a-z].txt:不会显示出小写字母到大写字母的文件，他会以小写大写的顺序排列出来预定义的字符类：man 7 glob [:digit:] :任意数字，相当于0-9[:lower:] :任意小写字母[:upper:] :任意大写字母[:alpha:] :任意大小写字母[:alnum:] :任意数字或字母[:blank:] :水平空白字符[:space:] :水平或垂直空白字符[:punct:] :标点符号[:print:] :可打印字符[:cntrl:] :控制(非打印)字符[:graph:] :图形字符[:xdigit:] :十六进制字符ls .[^.]*显示当前目录下的隐藏目录ls -d .*ls -l &quot;[^.]*&quot; -a 三种显示方式 atime mtime ctimetouch命令-a 仅改变 atime和ctime-m 仅改变 mtime和ctime-t [[CC]YY]MMDDhhmm[.ss] touch -t 201802062036.18 linuxidc.txt 指定atime和mtime的时间戳-c 如果文件不存在，则不予创建, 如果文件存在，touch将更新访问时间 cpcp -r递归cp /etc/passwd ./a --backup将文件cp到a文件夹并备份-d:保留链接属性-a:归档，相当于-d,-p,-r-v:显示复制过程-p:此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中-u:两个同样的文件覆盖时，只复制新的到旧的上去。-f:复制已经存在的目标文时件不提示-i:询问，如果目标文件已经存在，则会询问是否覆盖-l:把目标文件建立为源文件的硬链接文件，而不是复制源文件；-b:覆盖前，目标存在先备份cp /etc/passwd ./a1 --backup=numbered例：cp -av /etc/ app/back date +%F :/etc/目录下所有文件，备份到/app独立的子目录下，要求子目录格式为backYYY-mm-dd,备份过程可见。 mv-b: 如果有相同的文件，覆盖前先备份。 -t移动文件路径和目标路径颠倒 alias rm=&#39;mv -t /data&#39; rename将main1.c重命名为main.c rename main1.c main.c main1.c如果使用rename foo foo0 foo?，会把foo1到foo9的文件重命名为foo01到foo09，重命名的文件只是有4个字符长度名称的文件，文件名中的foo被替换为foo0。 如果使用rename foo foo0 foo??，foo01到foo99的所有文件都被重命名为foo001到foo099，只重命名5个字符长度名称的文件，文件名中的foo被替换为foo0。rename支持正则表达式:rename &quot;s/AA/aa/&quot; //把文件名中的AA替换成aa修改文件的后缀 rename &quot;s//.html//.php/&quot; //把.html 后缀的改成 .php后缀批量添加文件后缀 rename &quot;s/$//.txt/&quot; //把所有的文件名都以txt结尾批量删除文件名 rename &quot;s//.txt//&quot; //把所有以.txt结尾的文件名的.txt删掉如我们想把文件扩展名为.bak 的文件扩展名去掉，可以这样 rename &#39;s/.bak$//&#39; \*.bak*.bak 为通配符(wildcard)，会被shell展开为各个文件名 123去除文件名中的空格 rename &apos;s/ //g&apos;g 是global的意思，替换所有的空格为空字符（也就是删除啦） 文件名转为小写: rename &apos;y/A-Z/a-z/&apos; tree显示目录树 -d :只显示目录 -L level :指定显示的层级数目 -P pattern :只显示由指定pattern匹配到的路径tree -P /etc/rc* mkdir创建目录 -p :存在于不报错，且可自动创建所需的各目录 -v :显示详细信息 -m MODE :创建目录时直接指定权限 rmdir删除空目录 -p :递归删除父目录(rmdir -p:从下往上删除，从深往浅删除) -v :显示详细信息rm -r :递归删除目录树 例：1.创建/testdir/dir1/x,/testdir/dir1/y,/testdir/dir1/x/a,/testdir/dir1/x/b,/testdir/dir1/y/a,/testdir/dir1/y/bmkdir -p ./testdir/dir1/{x,y}/{a,b}2.创建/testdir/dir2/x,/testdir/dir2/y,/testdir/dir2/x/a,testdir/dir2/x/bmkdir -p testdir/dir2{x/{a,b},y}3.创建/testdir/dir3,/testdir/dir4,/testdir/dir5,/testdir/dir5/dir6,testdir/dir5/dir7mkdir -p ./testdir/dir{3,4,5/dir{6,7}} inode索引节点:inode(index node)表中包含文件系统所有文件列表一个节点(索引节点)是在一个表项，包含有关文件的信息(元数据),包括： 文件类型,权限,UID,GID 链接数(指向这个文件名路径名称个数) 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 硬链接创建硬链接会增加额外的记录项以引用文件对应于同一文件系统上一个物理文件每个目录引用相同的inode号创建时链接数递增删除文件时：rm命令递减计数的链接文件要存在，至少有一个链接数当链接数为零时，该文件被删除不能跨越驱动器或分区同一个文件的不同名字，改动其中一个文件，另外一个有相同的变化。语法:ln filename 目录不支持硬链接，他前面的数字表示链接的次数是指目录下的隐藏文件夹，.和.. 软链接一个符号链接指向另一个文件ls -l的 显示链接的名称和引用的文件一个符号链接的内容是它引用文件的名称可以对目录进行可以跨分区指向的是另一个文件的路径；其大小为指向的路径字符串的长度；不增加或减少目标文件inode的引用计数；语法：ln -s filename 软链接大小是指向的路径大小这里的相对路径: ln -s ../../../data/a.txt /d1/d2/d3/a-link 写法要注意，这里就是我现在在d3要去找到data，那么就是先回到根目录，然后去data目录下。简单说就是我现在在d3目录利用相对路径去找到data。# file文件可以包含多种类型的数据。检查文件的类型，然后确定适当的打开命令或应用程序使用file [options] &lt;\filename&gt;… -b 列出文件辨识结果时，不显示文件名称-f filelist 列出文件filelist中文件名的文件类型-F 使用指定分隔符号替换输出文件名后默认的”:”分隔符-L 查看对应软链接对应文件的文件类型# tr-c:取反-s:压缩重复字符12345678910111213[root@centos7 data]# tr &apos;a-z&apos; &apos;A-Z&apos;dfsjfidshijfidsijifjdisjidishifjDFSJFIDSHIJFIDSIJIFJDISJIDISHIFJjdihsifjdisjfiiehuHIHIJJDIHSIFJDISJFIIEHUHIHIJ[root@centos7 data]#[root@centos7 data]# tr -t &quot;a-d&quot; &quot;1-3&quot; fdjfregfdjfregaaaaaasdfdsadfgh111111sdfds1dfghabcfg123fg12345[root@centos7 data]#[root@centos7 data]# tr -d &apos;0-9&apos;dsgds546y7ujyr564wef5dsgdsyujyrwef[root@centos7 data]#123456[root@centos7 data]# tr -dc &apos;0-9&apos; dsgrere54545tg653r455454565345[root@centos7 data]# [root@centos7 data]# tr -s &apos;dfg&apos;ddfsggvffcddddfsgvfcd# 用户管理员：root, 0普通用户：1-60000 自动分配系统用户：1-499, 1-999 （CentOS7）对守护进程获取资源进行权限分配登录用户：500+, 1000+（CentOS7）## Linux安全上下文运行中的程序：进程 (process) 以进程发起者的身份运行：root: /bin/catmage: /bin/cat进程所能够访问资源的权限取决于进程的运行者的身份## 组Linux组：Groupname/GID管理员组：root, 0普通组： 系统组：1-499, 1-999（CENTOS7） 普通组：500+, 1000+（CENTOS7） Linux组的类别:用户的主要组(primary group)用户必须属于一个且只有一个主组组名同用户名，且仅包含一个用户，私有组用户的附加组(supplementary group)一个用户可以属于零个或多个辅助组.## 用户和组的配置文件 Linux用户和组的主要配置文件：/etc/passwd：用户及其属性信息(名称、UID、主组ID等）/etc/group：组及其属性信息/etc/shadow：用户密码及其相关属性/etc/gshadow：组密码及其相关属性 .## passwd 文件格式login name：登录用名（wang）passwd：密码 (x)UID：用户身份编号 (1000)GID：登录默认所在组编号 (1000)GECOS：用户全名或注释home directory：用户主目录 (/home/wang)shell：用户默认使用shell (/bin/bash)## shadow文件格式登录用名用户密码:一般用sha512加密从1970年1月1日起到密码最近一次被更改的时间密码再过几天可以被变更（0表示随时可被变更）密码再过几天必须被变更（99999表示永不过期）密码过期前几天系统提醒用户（默认为一周）密码过期几天后帐号会被锁定从1970年1月1日算起，多少天后帐号失效## 例12345678groupmems -a p2 -g p1:将用户p2加入p1组 groupmems -d p2 -g p1:将用户p2从p1组删除 [root@centos7 ~]# getent group p1 p1:x:1001:p2 [root@centos7 ~]# getent group p2 p2:x:1002: [root@centos7 ~]#newgrp p1：将当前用户的主组临时修改为p1,要求当前用户必须在p1组。vipw == vi /etc/passwdvigr == vi /etc/growuseradd-o:忽略id的唯一性检查-r:建立系统用户，他默认不会创建家目录-s:指定shell类型-c:描述groups x:查看用户x属于那些组-N：不要创建以用户名称为名的群组(默认加组users)新建用户默认属性文件：# id-g或–group 显示用户所属群组的ID。-G或–groups 显示用户所属附加群组的ID。-n或–name 显示用户，所属群组或附加群组的名称。-r或–real 显示实际ID。-u或–user 显示用户ID。-help 显示帮助。-version 显示版本信息[root@localhost ~]# iduid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)用户root的UID号码 = 0，GID号码 = 0。用户root是下面组的成员：root组GID号是：0bin组GID号是：1daemon组GID号是：2sys组GID号是：3adm组GID号是：4disk组GID号是：6wheel组GID号是：10# su切换用户或以其他用户身份执行命令su [options…] [-] [user [args…]]切换用户的方式：su UserName：非登录式切换，即不会读取目标用户的配置文件，不改变当前工作目录su - UserName：登录式切换，会读取目标用户的配置文件，切换至家目录，完全切换root su至其他用户无须密码；非root用户切换时需要密码换个身份执行命令：su [-] UserName -c ‘COMMAND’选项：-l –loginsu -l UserName 相当于 su - UserNamesu - pan -c &#39;ls&#39; 到用户pan执行命令ls再退回# passwd-d：删除指定用户密码 -l：锁定指定用户 -u：解锁指定用户 -e：强制用户下次登录修改密码 -f：强制操作 -n mindays：指定最短使用期限 -x maxdays：最大使用期限 -w warndays：提前多少天开始警告 -i inactivedays：非活动期限–stdin：从标准输入接收用户密码echo “PASSWORD” | passwd –stdin USERNAME# chage修改用户密码状态chagechage [选项] 用户名 -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期(shadow3字段) -m 天数:两次密码修改间隔(4字段) -M 天数:密码有效期(5字段) -W 天数:密码过期前警告天数(7字段) -I 天数:密码过后宽限天数(7字段) -E 日期:账号失效时间(8字段)chage -d 0 username这个命令其实是把密码修改日期归0了(shadow第3字段)，这样用户只要一登录就要修改密码。第三字段是指密码最后一次修改时间的日期。1970年1月1号到现在修改密码的时间戳。如果第3字段改为0，系统会认为用户没有修改过操作密码，那么当此用户一旦登录系统就会提示要修改密码，才可正常使用。.# groupmod修改和删除组组属性修改：groupmod groupmod [OPTION]… group-n group_name: 新名字-g GID: 新的GID组删除：groupdelgroupdel GROUPgroupmod -n p1(新名字) pangroupmod -g 1004 p1# gpasswd更改组密码组密码：gpasswdgpasswd [OPTION] GROUP-a user 将user添加至指定组中-d user 从指定组中移除用户user-A user1,user2,… 设置有管理权限的用户列表newgrp命令：临时切换主组如果用户本不属于此组，则需要组密码# groupmemsgroupmems [options] [action] options：-g, –group groupname 更改为指定组 (只有root) Actions:-a, –add username 指定用户加入组 -d, –delete username 从组中删除用户-p, –purge 从组中清除所有成员-l, –list 显示组成员列表groups [OPTION].[USERNAME]… 查看用户所属组列表1234groupmems -g admins -a zhu------将zhu用户添加到admins组中 groupmems -g admins -l ------------查看admins组中的用户列表 groupmems -g admins -d ma-------将ma从admins组中删除 groupmems -g admins -p------------清空admins组中的所有组成员# umask新建文件和目录的默认权限umask值 可以用来保留在创建文件权限 新建FILE权限: 666-umask如果所得结果某位存在执行（奇数）权限，则将其权限+1 新建DIR权限: 777-umask 非特权用户umask是 002 root的umask 是 022 umask: 查看 umask #: 设定umask 002 umask –S 模式方式显示 umask –p 输出可被调用 全局设置： /etc/bashrc 用户设置：~/.bashrc# SUID SGID STICKYsuid:4 作用在二进制可执行的文件上，功能：当用户执行此文件，会继承此文件所有者的权限。sgid:2 作用于二进制可执行的文件上，功能：会执行此文件所属组的权限 。 作用于目录上，功能：当用户在此目录建新文件时，此新文件的所属组继承目录的所属组。stikey:1 作用于目录上，功能：对于目录的文件只能删除自己的文件。# chattrchattr +i 不能删除，改名，更改chattr +a 只能追加内容lsattr 显示特定属性# ACL访问控制列表ACL：Access Control List，实现灵活的权限管理除了文件的所有者，所属组和其它人，可以对更多的用户设置权限CentOS7 默认创建的xfs和ext4文件系统具有ACL功能CentOS7 之前版本，默认手工创建的ext4文件系统无ACL功能,需手动增加 tune2fs –o acl /dev/sdb1mount –o acl /dev/sdb1 /mnt/testACL生效顺序：所有者，自定义用户，自定义组，其他人setfacl -R -m d:u:p1:rw text 给文件夹text设置acl权限，默认以后文件下创建的文件都会有这个权限(text文件夹下所有的文件夹马上会带有acl权限。)setfacl -b test #清除所有aclsetfacl -x u:tank test #清除tank用户，对test文件acl规则setfcl -k test 清楚text目录下所有文件的默认acl权限(文件夹除外)赋权给用户： setfacl -m u:USERNAME:MODE file赋权给组： serfacl -m g:GROUPNAME:MODE file[root@centos7 text]# cat au:p1:rwu:p2:rwsetfacl -M a.txt aa 将已编辑好的acl文件a，赋给aa文件。设置文件的ACL权限后，会有一个mask权限，他表示所有权限的上限(所有者除外)，其他用户和组的权限都要以他为最大标准。ll查看文件的基础权限组权限就是mask权限，更改组的权限相当更改mask权限。所以文件的组的权限在getfacl里面12345678910111213[root@centos7 text]# getfacl a# file: a# owner: root# group: rootuser::rwxuser:p1:rwx #effective:rw- 最大权限rwgroup::r-- 基础组权限group:p1:rwx #effective:rw-mask::rw-other::---[root@centos7 text]# ll a -rwxrw----+ 1 root root 41 Apr 7 12:03 asetfacl -m mask::rw 更改mask权限 或者直接chmod更改# cat,head,tail,cut文件查看 文件查看命令：cat，tac，rev cat [OPTION]… [FILE]…-E：显示行结束符$-n：对显示出的每一行进行编号-A：显示所有控制符-b：非空行编号-s：压缩连续的空行成一行 tac rev## 显示文本前或后行内容head [OPTION]… [FILE]…-c #: 指定获取前#字节-n #: 指定获取前#行-#： 指定行数 tail [OPTION]… [FILE]…-c #: 指定获取后#字节-n #: 指定获取后#行-#：同上-f: 跟踪显示文件fd新追加的内容,常用日志监控相当于 –follow=descriptor-F: 跟踪文件名，相当于–follow=name –retry tailf 类似tail –f，当文件不增长时并不访问文件## 按列抽取文本cut和合并文件pastecut [OPTION]… [FILE]…-d DELIMITER: 指明分隔符，默认tab-f FILEDS:#: 第 # 个 字 段 #,#[,#]：离散的多个字段，例如1,3,6 #-#：连续的多个字段, 例如1-6混合使用：1-3,7-c 按字符切割–output-delimiter=STRING指定输出分隔符cut -d : -f 1,3 --output-delimiter=+ /etc/passwd输出分隔符为’+’# cut和paste显示文件或STDIN数据的指定列cut -d: -f1 /etc/passwdcat /etc/passwd | cut -d: -f7 cut -c2-5 /usr/share/dict/wordspaste 合并两个文件同行号的列到一行paste [OPTION]… [FILE]…-d 分隔符：指定分隔符，默认用TAB-s : 所有行合成一行显示示 例 ： paste f1 f2paste -s f1 f2# wc计数单词总数、行总数、字节总数和字符总数可以对文件或STDIN中的数据运行wc story.txt39 237 1901 story.txt 行数 字数 字节数常用选项-l 只计数行数-w 只计数单词总数-c 只计数字节总数-m 只计数字符总数-L 显示文件中最长行的长度# sort文本排序sort把整理过的文本显示在STDOUT，不改变原始文件sort [options] file(s)常用选项-r 执行反方向（由上至下）整理-R 随机排序-n 执行按数字大小整理-f 选项忽略（fold）字符串中的字符大小写-u 选项（独特，unique）删除输出中的重复行-t c 选项使用c做为字段界定符-k X 选项按照使用c字符分隔的X列来整理能够使用多次# uniquniq命令：从输入中删除前后相接的重复的行uniq [OPTION]… [FILE]…-c: 显示每行重复出现的次数-d: 仅显示重复过的行-u: 仅显示不曾重复的行注：连续且完全相同方为重复 常和sort 命令一起配合使用： sort userlist.txt | uniq -c# patch复制对文件改变patchdiff 命令的输出被保存在一种叫做“补丁”的文件中使用 -u 选项来输出“统一的（unified）”diff格式文件，最适用于补丁文件patch 复制在其它文件中进行的改变（要谨慎使用）适用 -b 选项来自动备份改变了的文件diff -u foo.conf foo2.conf &gt; foo.patch patch -b foo.conf foo.patch# grep–color=auto: 对匹配到的文本着色显示 -v: 显示不被pattern匹配到的行 -i: 忽略字符大小写 -n：显示匹配的行号 -c: 统计匹配的行数 -o: 仅显示匹配到的字符串 -q: 静默模式，不输出任何信息 -A #: after, 后#行 -B #: before, 前#行 -C #：context, 前后各#行 -e：实现多个选项间的逻辑or关系 grep –e &#39;cat&#39; -e dog&#39; file-w：匹配整个单词 -E：使用ERE -F：相当于fgrep，不支持正则表达式 -f file: 根据模式文件处理## 字符匹配基本正则表达式元字符. 匹配任意单个字符[] 匹配指定范围内的任意单个字符，示例：[wang] [0-9] [a-z] [a-zA-Z][^] 匹配指定范围外的任意单个字符[:alnum:] 字母和数字[:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z[:lower:] 小写字母[:upper:] 大写字母[:blank:] 空白字符（空格和制表符）[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）[:cntrl:] 不可打印的控制字符（退格、删除、警铃…）[:digit:] 十进制数字[:xdigit:]十六进制数字[:graph:] 可打印的非空白字符[:print:] 可打印字符[:punct:] 标点符号## 匹配次数用在要指定次数的字符后面，用于指定前面的字符要出现的次数* 匹配前面的字符任意次，包括0次贪婪模式：尽可能长的匹配.* 任意长度的任意字符\? 匹配其前面的字符0或1次\+ 匹配其前面的字符至少1次\{n\} 匹配前面的字符n次\{m,n\} 匹配前面的字符至少m次，至多n次\{,n\} 匹配前面的字符至多n次\{n,\} 匹配前面的字符至少n次## 位置锚定定位出现的位置：^ 行首锚定，用于模式的最左侧$行尾锚定，用于模式的最右侧^PATTERN$ 用于模式匹配整行^$ 空行^[[:space:]]*$ 空白行\&lt; #锚定单词的开始，如:&#39;\&lt;grep&#39;匹配包含以grep开头的单词的行\&gt; #锚定单词的结束，如:&#39;grep\&gt;&#39;匹配包含以grep结尾的单词的行\b #单词锁定符，如: &#39;\bgrep\b&#39;只匹配grep数字,字母,下划线,不能作为单词的分隔符。.## 分组\(\) 将一个或多个字符捆绑在一起，当作一个整体处理，如：\(root\)\+分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \1, \2, \3, …\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符 示例： \(string1\+\(string2\)*\)\1: string1\+\(string2\)*\2: string2后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身或者：|示例：a|b: a或b C|cat: C或cat (C|c)at:Cat或cat^ 行首$ 行尾 . 任意单一字符 [][]内任意单一字符 [^] 除[]内任意单一字符 * 前面字符重复不确定次数 \+ 前面字符重复一次以上不确定次数 \? 前面字符重复0或1次 \ 转义符.* 任意长度字符 \{n\} 前面字符重复n次 \{n,\} 前面字符重复n次以上\{m,n\} 前面字符重复m次和n次之间 # 扩展正则egrep = grep -Eegrep [OPTIONS] PATTERN [FILE…]扩展正则表达式的元字符：字符匹配：.任意单个字符 [] 指定范围的字符 [^] 不在指定范围的字符 次数匹配：* 匹配前面字符任意次 ? 0或1次 + 1次或多次 {m} 匹配m次 {m,n} 至少m，至多n次 位置锚定：^ 行首 $ 行尾 \&lt; #锚定单词的开始 \&gt; #锚定单词的结束 \b #单词锁定符 分组：() 后向引用：\1, \2, …或者：a|ba或b C|catC或cat (C|c)atCat或cat.# vim# 脚本编程 脚本调试检测脚本中的语法错误bash -n /path/to/some_script 调试执行bash -x /path/to/some_script# 环境变量## 局部变量变量赋值：name=‘value’可以使用引用value: (1)可以是直接字串; name=“root” (2) 变量引用：name=”$USER” (3) 命令引用：name=COMMAND name=$(COMMAND)变量引用：${name} $name “”：弱引用，其中的变量引用会被替换为变量值 ‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串显示已定义的所有变量：set## 删除变量：unset name查看当前shell进程号：echo $$ echo BASHPID只读和位置变量只读变量：只能声明，但不能修改和删除声明只读变量：readonly namedeclare -r name查看只读变量： readonly –p## 位置变量：在脚本代码中调用通过命令行传递给脚本的参数$1, $2, …：对应第1、第2等参数，shift [n]换位置 $0: 命令本身$*: 传递给脚本的所有参数，全部参数合为一个字符串$@: 传递给脚本的所有参数，每个参数为独立字符串$#: 传递给脚本的参数的个数$@ $ 只在被双引号包起来的时候才会有差异set – 清空所有位置变量## 退出状态进程使用退出状态来报告成功或失败• 0 代表成功，1－255代表失败• $? 变量保存最近的命令退出状态例如：ping -c1 -W1 hostdown &amp;&gt; /dev/null echo $?返回值可以被指定。exit 100退出状态码bash自定义退出状态码 exit [n]：自定义退出状态码注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码# 算术运算算术运算bash中的算术运算:help let`+, -, , /, %取模（取余）, （乘方）实现算术运算： (1) let var=算术表达式 (2) var=$[算术表达式] (3) var=$((算术表达式)) (4) var=$(expr arg1 arg2 arg3 ...) (5) declare –i var = 数值 (6) echo ‘算术表达式’ | bc 乘法符号有些场景中需要转义，如bash有内建的随机数生成器：$RANDOM（0-32767） echo $[$RANDOM%50] ：0-49之间随机数 1234let &quot;a=8+9&quot; a=$[9+7] expr 1 + 3 declare -i n=3+6 # 颜色指定 Color=&quot;\e[1;5;$[RANDOM%7+31]m&quot; END=&quot;\e[0m&quot; echo -e &quot;$Color 你好 $END&quot; 1：表示亮度；5：表示闪烁 表示随机打印出任意颜色的 &quot;你好&quot; # 赋值 增强型赋值：+=, -=, =, /=, %let varOPERvalue 例如:let count+=3 自加3后自赋值 自增，自减： let var+=1 let var++ let var-=1 let var-- # 逻辑运算 true, false 1, 0 与： 1 与 1 = 1 1 与 0 = 0 0 与 1 = 0 0 与 0 = 0  或: 1 或 1 = 1 1 或 0 = 1 0 或 1 = 1 0 或 0 = 0 非：！ ! 1 = 0 ! true ! 0 = 1 ! false 短路运算 短路与 第一个为0，结果必定为0 第一个为1，第二个必须要参与运算短路或 第一个为1，结果必定为1 第一个为0，第二个必须要参与运算 异或：^ 异或的两个值,相同为假，不同为真#str=abcde;[[ “$str” =~ ^abc ]] &amp;&amp; echo true || echo false正则表达式#str=abcdef;[[ “$str” == abc ]] &amp;&amp; echo true || echo false通配符id $1 &amp;&gt; /dev/null &amp; ( echo &amp;1 is exist;exit ) || (useradd $1;echo $1 is created)echo finined小括号会开启子shell。退出只会退出子shell，不会退出脚本本身。 # 条件测试 判断某需求是否满足，需要由测试机制来实现 专用的测试表达式需要由测试命令辅助完成测试过程 评估布尔声明，以便用在条件性执行中 • 若真，则返回0 • 若假，则返回1 测试命令： • test EXPRESSION • [ EXPRESSION ] • [[ EXPRESSION ]] 注意：EXPRESSION前后必须有空白字符 # Bash的文件权限测试 存在性测试 -a FILE：同-e -e FILE: 文件存在性测试，存在为真，否则为假 存在性及类别测试 -b FILE：是否存在且为块设备文件 -c FILE：是否存在且为字符设备文件 -d FILE：是否存在且为目录文件 -f FILE：是否存在且为普通文件 -h FILE 或 -L FILE：存在且为符号链接文件 -p FILE：是否存在且为命名管道文件 -S FILE：是否存在且为套接字文件 # Bash的文件属性测试 文件权限测试： -r FILE：是否存在且可读 -w FILE: 是否存在且可写 -x FILE: 是否存在且可执行 文件特殊权限测试： -u FILE：是否存在且拥有suid权限 -g FILE：是否存在且拥有sgid权限 -k FILE：是否存在且拥有sticky权限 文件大小测试： -s FILE: 是否存在且非空 文件是否打开： -t fd: fd 文件描述符是否在某终端已经打开 -N FILE：文件自从上一次被读取之后是否被修改过 -O FILE：当前有效用户是否为文件属主 -G FILE：当前有效用户是否为文件属组 双目测试： FILE1 -ef FILE2: FILE1是否是FILE2的硬链接 FILE1 -nt FILE2: FILE1是否新于FILE2（mtime） FILE1 -ot FILE2: FILE1是否旧于FILE2 # Bash的组合测试条件 第一种方式： COMMAND1 &amp;&amp; COMMAND2 并且 COMMAND1 || COMMAND2 或者 ! COMMAND 非 如：[ -f “$FILE” ] &amp;&amp; [[ “$FILE”=~ ..sh$ ]]第二种方式： EXPRESSION1 -a EXPRESSION2 并且 EXPRESSION1 -o EXPRESSION2 或者 ! EXPRESSION 必须使用测试命令进行，[[ ]] 不支持 示例：[ -z “$HOSTNAME” -o $HOSTNAME “==”localhost.localdomain” ] \ &amp;&amp; hostname www.magedu.com`[ -f /bin/cat -a -x /bin/cat ] &amp;&amp; cat /etc/fstab# read使用read来把输入值分配给一个或多个shell变量 -p 指定要显示的提示-s 静默输入，一般用于密码 -n N 指定输入的字符长度N -d ‘字符’ 输入结束符-t N TIMEOUT为N秒read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量read -p “Enter a filename: “ FILE# bash如何展开命令行把命令行分成单个命令词展开别名展开大括号的声明（{}）展开波浪符声明（~）命令替换$() 和 ）再次把命令行分成命令词展开文件通配（*、?、[abc]等等）准备I/0重导向（&lt;、&gt;）运行命令# 防止扩展反斜线（\）会使随后的字符按原意解释 $ echo Your cost: \$5.00Your cost: $5.00加引号来防止扩展• 单引号（’）防止所有扩展• 双引号（”）也防止所有扩展，但是以下情况例外：$（美元符号） － 变量扩展`（反引号） － 命令替换\（反斜线） － 禁止单个字符扩展!（叹号） － 历史命令替换# bash的配置文件按生效范围划分，存在两类：全局配置：/etc/profile/etc/profile.d/*.sh/etc/bashrc个人配置：~/.bash_profile ~/.bashrc# shell登录两种方式交互式登录：(1)直接通过终端输入账号密码登录(2)使用“su - UserName” 切换的用户执行顺序：/etc/profile --&gt; /etc/profile.d/*.sh --&gt; ~/.bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc非交互式登录：(1)su UserName(2)图形界面下打开的终端(3)执行脚本(4)任何其它的bash实例执行顺序： /etc/profile.d/*.sh --&gt; /etc/bashrc --&gt;~/.bashrc# Profile类按功能划分，存在两类：profile类和bashrc类profile类：为交互式登录的shell提供配置全局：/etc/profile, /etc/profile.d/*.sh 个人：~/.bash_profile功用：(1) 用于定义环境变量(2) 运行命令或脚本# bashrc类：为非交互式和交互式登录的shell提供配置全局：/etc/bashrc个人：~/.bashrc功用：(1) 定义命令别名和函数(2) 定义本地变量# 编辑配置文件生效修改profile和bashrc文件后需要生效：两种方法：.重新启动shell进程 .或source例：.~/.bashrc# Bash 退出任务保存在~/.bash_logout文件中(用户)在退出登录shell时运行用于：创建自动备份清除临时文件想要登出后系统自动执行操作可以将执行动作放在： ~/.bash_logot# $-h：hashall，打开这个选项后，Shell 会将命令所在的路径hash下来，避免每次都要查询。通过set +h将h选项关闭i：interactive-comments，包含这个选项说明当前的 shell 是一个交互式的shell。所谓的交互式shell,在脚本中，i选项是关闭的。m：monitor，打开监控模式，就可以通过Job control来控制进程的停止、继续，后台或者前台执行等。B：braceexpand，大括号扩展H：history，H选项打开，可以展开历史列表中的命令，可以通过!感叹号来完成，例如“!!”返回上最近的一个历史命令，“!n”返回第 n 个历史命令# locate-i 不区分大小写的搜索-n N 只列举前N个匹配项目-r 使用正则表达式例：搜索名称或路径中带有”conf”的文件locate conf# find指搜索层级-maxdepth level 最大搜索目录深度，指定目录为第1级-maindepth level 最小搜索目录深度find /data -maxdepth 2 -mindepth 2 -name &quot;*.sh&quot; 表示只在/data下的二级目录下搜索先处理目录内的文件，再处理目录 -depth根据文件名和inode查找： -name “文件名称”:支持使用glob *,?,[],[^] -iname “文件名称”:不区分字母大小写 -inum n 按inode号查找 -samefile name 相同inode号的文件 -links n 链接数为n的文件 -reges “PATTERN”:以PATTERN匹配整个文件路径，而非文件名称## 查找条件根据属主，属组查找：-user USERNAME :查找属主为指定用户(UID)的文件 -group GROUPNAME :查找属组为指定组(GID)的文件 -uid UserID :查找属主为指定的UID号的文件 -gid GroupID :查找属组为指定的GID号的文件 -nouser :查找没有属主的文件 -nogroup :查找没有属组的文件## 根据文件类型查找：-type TYPE: f :普通文件 d :目录文件 l :符号链接文件 s :套接字文件 b :块设备文件 c :字符设备文件 p :管道文件空文件或目录： -emptyfind /app -type d -empty## 查找条件组合条件： 与：-a 或：-o 非：-not,!德 摩根定律：(非A)或(非B)=非(A或B)(非A)且(非B)=非(A或B)示例： !A -a !B = !(A -o B) !A -o !B = !(A -a B)## 根据文件大小来查找 -size[+|-]#UNIT 常用单位:k,M,G,c(byte) #UNIT:(#-1,#] 如: 6k表示(5k,6k] -#UNIT:[0,#-1] 如: +6k表示(0,5k] +#UNIT:(#,∞) 如: +6k表示(6k,∞)## 根据时间戳：以”天”为单位-atime [+|-]#, #:[#,#+1) +#:[#+1,∞] -#:[0,#)-mtime-ctiime以”分钟”为单位-amin-mmin-cminatime、ctime、mtime的区别atime：上一次访问这个文件是什么时候ctime：上一次改变这个文件的属性(元数据)是什么时候mtime：上一次改变这个文件的内容是什么时候 .## 根据权限查找：-perm[/|-]MODE MODE:精确权限匹配 /MODE:任何一类(u,g,o)对象的权限中只要能一位匹配即可，或关系，从centos7开始淘汰 -MODE:每一类对象都必须同时拥有指定权限，与关系 ０:表示不关注find -perm 755会匹配权限模式恰好是755的文件只有当任意人有写权限时，find -perm +222就会匹配只要当每个人都有写权限时，find -perm -222才会匹配只要当其他人(other)有写权限时，find -perm -002 才会匹配 .## 处理动作-exec COMMAND {} \;:对查到的每个文件执行有COMMAND指定的命令{}:用于引用查找到的文件名称自身find传递查找到的文件至后面的命令时，查找到所有符合条件的文件一次性传递给后面的命令## 参数替换xargs由于很多命令不支持管道|来传递参数，而日常工作中有这个必要，所以就有了xargs命令xargs用于产生某个命令的参数，xargs可以读入stdin的数据，并且已空格符或回车将stdin的数据分隔为arguments注意:文件名或者是其他意义的名词内含有空格符的情况有些命令不能接受过多参数，命令执行可能会失败，xargs可以解决示例：ls f | xargs rmfind /sbin -perm +700 | ls -l 这个命令是错误的,ls不支持标准输入find /sbin -perm +7000 | xargs ls -l 查找特殊权限的文件find和xargs格式:find | xargs COMMAND .# 压缩compress [-dfvcVr]\[-b maxbits]\[file…] -d :解压缩，相当于gunzip -c :结果输出至标准输出，不删除原文件 -v :显示详情 uncompress 解压缩zcat file.Z &gt; file## gzip/gunzip-d:解压缩，相当于gunzip-c :结果输出至标准输出，保留源文件不改变 -# :1-9，指定压缩比，值越大压缩比越大 zcat:不解压缩的前提下查看文本文件内容示例： gzip -c messages &gt; messages.gzgzip -c -d message.gz &gt; messageszcat messages.gz &gt; messagescat messages | gzip &gt; m.gz.## bzip2/bunzip2/bzcatbzip2 [option]…FILE… -k :keep，保留原文件 -d :解压缩 -# :1-9,压缩比，默认为9 bzcat:不显示解压缩的前提下查看文件文件内容## xz/unxz/xzcatxz[OPTION]…FILE… -k :keep，保留原文件 -d :解压缩 -# :1-9，压缩比，默认为6unxz file.xz 解压缩xzcat: 不显示解压缩的前提下查看文本文件内容## zip/unzip 打包压缩zip -r /backup/sysconfig /etc/sysconfig解包解压缩unzip sysconfig.zipcat /var/log/messages | zip messages -unzip -p message &gt; message# tar工具-exclude 排除文件tar zcvf /root/a3.tgz --exclude=/app/host1 --exclude=/app/host2/app-T选项指定输入文件，-X选项指定包含要排除的文件列表tar zcvf mybackup.tgz -T /root/includefilelist -X /root/excludefilelistsplist:: 分割一个文件为多个文件分割大的tar文件为多份小文件split -b Size -d tar-file-name prefix-namesplit -b 1M -d mybackup.tgz mybackup-partssplit -b 1m mybackup.taz mybackup-parts合并：cat mybackup-parts &gt; mybackup.tar.gz.spilt -b 2M -d /root/data.tar.xz databak -d会以数字结尾# cpio功能：cpio用于创建、解压归档文件，也可以对归档文件执行拷入拷出的动作，即向归档文件中追加文件，或从归档文件中提取文件。它也支持tar格式的归档文件，但是对压缩后的tar(如.tar.gz格式)就没法支持了，cpio毕竟不会调用对应的(解)压缩工具。cpio命令是通过重定向的方式将文件进行打包备份，还原恢复的工具，它可以解压以.cpio或者.tar结尾的文件 cpio [选项] &gt; 文件名或者设备名cpio [选项] &lt; 文件名或者设备名 -o 将文件拷贝打包成文件或者将文件输出到设备上 -O filename 输出到指定的归档文件名 -A 向已存在的归档文件中追加文件 -i 解包，将打包文件解压或将设备上的备份还原到系统 -I filename 对指定的归档文件名解压 -t 预览，查看文件内容或者输出到设备上的文件内容 -F filename 使用指定的文件名替代标准输入或输出 -d 解包生成目录，在cpio还原时，自动的建立目录 -v 显示打包过程中的文件名称 将etc目录备份：find ./etc -print |cpio -ov &gt;bak.cpio 将/data内容追加bak.cpio find /data | cpio -oA -F bak.cpio 内容预览cpio –tv &lt; etc.cpio 解包文件 cpio –idv &lt; etc.cpio .# sed-n 不输出模式空间内容到屏幕，即不自动打印 -e 多点编辑 -f /PATH/SCRIPT_FILE 从指定文件中读取编辑脚本 -r 支持使用扩展正则表达 -i.bak 备份文件并原处编辑script: &#39;地址命令&#39;地址定界： (1) 不给地址：对全文进行处理(2) 单地址： #: 指定的行，$：最后一行 /pattern/：被此处模式所能够匹配到的每一行(3) 地址范围： #,# #,+# pat1/,/pat2/ #,/pat1/(4) ~：步进 1~2 奇数行, 2~2 偶数行sed -i.back &#39;/^root/aadmin line passwd&#39; 插入并备份原文件使用sed将/etc/httpd/conf/httpd.conf中#NameVirtualHost *:80去掉#号,同时将最后7行的#都去掉解:sed -e &#39;s/#Name/Name/&#39; -e &#39;/#&lt;VirtualHost/,/#&lt;\/Virtual/s/#//&#39; /etc/httpd/conf/httpd.conf.## 编辑命令d 删除模式空间匹配的行，并立即启用下一轮循环p 打印当前模式空间内容，追加到默认输出之后a []text在指定行后面追加文本，支持使用\n实现多行追加i []text在行前面插入文本c []text 替换行为单行或多行文本w /path/file 保存模式匹配的行至指定文件r /path/file读取指定文件的文本至模式空间中匹配到的行后= 为模式空间中的行打印行号! 模式空间中匹配行取反处理 sed &#39;/^UUID/r /etc/issue&#39; /etc/fstab 读取/etc/issue中的内容到/etc/fstab UUID开头的行后123456seq 10 | sed &apos;1~2d&apos; 输出双数的行 seq 10 | sed &apos;axxx\nyyy\nzzz&apos; sed &apos;/^root/i\ admin line&apos; /etc/passwd 加入了空格 sed &apos;/^root/aadmin line&apos; /etc/passwd sed &apos;/^UUID/w f1&apos; /etc/fstab sed &apos;/^UUID/=&apos; /etc/fstab 打印UUID开头的行显示行号## sed替换s/// 查找替换,支持使用其它分隔符，s@@@，s###替换标记：g 行内全局替换p 显示替换成功的行w /PATH/FILE 将替换成功的行保存至文件中例：sed -n &#39;s/UUID/tempfilesystem/gp&#39; /etc/fstabifconfig | sed -n &#39;2p&#39; | sed &#39;s/.*inet //&#39;|sed &#39;s@ netmask.*$@@&#39;ifconfig | sed -nr &#39;2s/.*t (.*) net.*/\1/gp&#39;ifconfig ens33 | sed -r &#39;2!d;s/.*inet (addr:)?//;s/ .*//&#39; sed取IP地址echo /etc/sysconfig/network-scripts/ | sed -nr &#39;s#(^.*/)([^/].*)/?$#\1#p&#39;取基名（不理解）sed大小写转换：sed -r &#39;s/[[:alpha:]]/\u&amp;/g&#39; /etc/fstabsed -r &#39;s/[[:alpha:]]/\l&amp;/g&#39; /etc/fstab## sed 示例1234567891011sed ‘2p’ /etc/passwdsed –n ‘2p’ /etc/passwdsed –n ‘1,4p’ /etc/passwdsed –n ‘/root/p’ /etc/passwdsed –n ‘2,/root/p’ /etc/passwd 从2行开始sed -n ‘/^$/=’ file 显示空行行号sed –n –e ‘/^$/p’ –e ‘/^$/=’ filesed ‘/root/a\superman’ /etc/passwd行后sed ‘/root/i\superman’ /etc/passwd 行前sed ‘/root/c\superman’ /etc/passwd 代替行c:是表示将我现在所写的字符与所找到的行全部替换。不是字符替换。1234567891011sed ‘/^$/d’ filesed ‘1,10d’ filenl /etc/passwd | sed ‘2,5d’nl /etc/passwd | sed ‘2a tea’sed &apos;s/test/mytest/g&apos; examplesed –n ‘s/root/&amp;superman/p’ /etc/passwd 单词后sed –n ‘s/root/superman&amp;/p’ /etc/passwd 单词前sed -e ‘s/dog/cat/’ -e ‘s/hi/lo/’ petssed –i.bak ‘s/dog/cat/g’ petsnl:表示显示行号，空行不显示&amp;：代表前面找到的内容## sed高级P：打印模式空间开端至\n内容，并追加到默认输出之前h: 把模式空间中的内容覆盖至保持空间中H：把模式空间中的内容追加至保持空间中g: 从保持空间取出数据覆盖至模式空间G：从保持空间取出内容追加至模式空间x: 把模式空间中的内容与保持空间中的内容进行互换n: 读取匹配到的行的下一行覆盖至模式空间N：读取匹配到的行的下一行追加至模式空间d: 删除模式空间中的行D：如果模式空间包含换行符，则删除直到第一个换行符的模式空间中的文本，并不会读取新的输入行，而使用合成的模式空间重新启动循环。如果模式空间不包含换行符，则会像发出d命令那样启动正常的新循环12345678910sed -n &apos;n;p&apos; FILEsed &apos;1!G;h;$!d&apos; FILEsed‘N;D’FILEsed &apos;$!N;$!D&apos; FILEsed &apos;$!d&apos; FILEsed ‘G’ FILEsed ‘g’ FILEsed ‘/^$/d;G’ FILEsed &apos;n;d&apos; FILEsed -n &apos;1!G;h;$p&apos; FILE# rpm–test: 测试安装，但不真正执行安装，即dry run模式–nodeps：忽略依赖关系–replacepkgs 强制重新安装已经安装的软件包–replacefiles 替换属于其他软件包的文件–nosignature: 不检查来源合法性 –nodigest：不检查包完整性–noscripts：不执行程序包脚本 %pre:安装前脚本 –nopre %post: 安装后脚本 –nopost %preun: 卸载前脚本 –nopreun %postun:卸载后脚本 –nopostun## rpm升级upgrade：安装有旧版程序包，则“升级”如果不存在旧版程序包，则“安装” freshen：安装有旧版程序包，则“升级”如果不存在旧版程序包，则不执行升级操作 rpm -Uvh PACKAGE_FILE …rpm -Fvh PACKAGE_FILE …–oldpackage：降级 –force: 强制安装 注意：(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，可以直接安装新版本内核(2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名(FILENAME.rpmnew)后保留.## 包查询-a: 所有包 -f: 查看指定的文件由哪个程序包安装生成 -p rpmfile：针对尚未安装的程序包文件做查询操作 –whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供 –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖rpm2cpio 包文件|cpio –itv 预览包内文件rpm2cpio 包文件|cpio –id &quot;\*.conf&quot; 释放包内文件 –changelog：查询rpm包的changelog -c: 查询程序的配置文件 -d: 查询程序的文档 -i: information -l: 查看指定的程序包安装后生成的所有文件 –scripts：程序包自带的脚本 –provides: 列出指定程序包所提供的CAPABILITY -R: 查询指定的程序包所依赖的CAPABILITY## 包校验#rpm -V 已安装的包名选项：-V 校验指定RPM包中的文件。(verify) [root@Tiger ~]#rpm -V httpd S.5….T. c /etc/httpd/conf/httpd.conf验证内容中的8个信息的具体内容如下： S：文件大小是否改变； M：文件的类型或文件的权限(r w x)是否被改变； 5：文件MD5校验和是否改变(可以看成文件的内容是否改变)； D：设备的主，从设备号是否改变； L：文件路径是否改变； U：文件的属主(所有者)是否改变； G：文件的属组是否改变； T：文件的修改时间是否改变； 文件类型：* c :配置文件(config file) d :普通文档(documentation) g :”鬼”文件(ghost file),很少见，就是该文件不应该被这个RPM包包含 l :授权文件(license file) r :描述文件(read me)## 秘钥包来源合法性验正及完整性验证完整性验证：SHA256来源合法性验证：RSA公钥加密对称加密：加密、解密使用同一密钥非对称加密：密钥是成对儿的public key: 公钥，公开所有人secret key: 私钥, 不能公开导入所需要公钥rpm -K|checksig rpmfile 检查包的完整性和签名rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 CentOS 7发行版光盘提供：RPM-GPG-KEY-CentOS-7`rpm -qa “gpg-pubkey“检查系统公钥rpm -qa “gpg-pubkey“[root@centos7 Packages]# rpm –import /mnt/RPM-GPG-KEY-CentOS-7[root@centos7 Packages]# rpm -K tree-1.6.0-10.el7.x86_64.rpm ## 数据库 数据库重建：/var/lib/rpm rpm {--initdb|--rebuilddb} initdb: 初始化 如果事先不存在数据库，则新建之否则，不执行任何操作 rebuilddb：重建已安装的包头的数据库索引目录 # centos6 内核救援 ![](https://s2.ax1x.com/2019/05/03/ENOeun.png) ![](https://s2.ax1x.com/2019/05/03/ENOnH0.png) # yumyum repolist查看仓库信息 仓库的元数据 [root@centos7 \~]# cd /var/cache/yum/x86_64/7/yum history查看yum安装历史yum history info 2查看历史中的第二项 ![](https://s2.ax1x.com/2019/05/04/EauSmR.png)yum客户端配置文件：/etc/yum.conf：为所有仓库提供公共配置/etc/yum.repos.d/.repo：为仓库的指向提供配置仓库指向的定义：&lt;pre&gt;[repositoryID] name=Some name for this repository baseurl=url://path/to/repository/ enabled={1|0} gpgcheck={1|0} gpgkey=URL enablegroups={1|0} failovermethod={roundrobin|priority} roundrobin：意为随机挑选，默认值 priority:按顺序访问 cost= 默认为1000&lt;/pre&gt; yum的repo配置文件中可用的变量：$releasever: 当前OS的发行版的主版本号$arch: 平台，i386,i486,i586,x86_64等$basearch：基础平台；i386, x86_64$YUM0-$YUM9:自定义变量 实例: 123http://server/centos/$releasever/$basearch/ http://server/centos/7/x86_64 http://server/centos/6/i384 ## 实验基于httpd搭建的yum服务器： 1234567891011121314151617181920212223242526yum install -y httpdmkdir -pv centos/&#123;6,7&#125;/os/x86_64 html/└── centos ├── 6 │ └── os │ └── x86_64 └── 7 └── os └── x86_64 ├── EFI │ └── BOOT │ └── fonts ├── images │ └── pxeboot ├── isolinux ├── LiveOS ├── Packages └── repodatamount /dev/sr0 html/centos/7/os/x86_64/[base]name=Centos\#baseurl=file:///run/media/pan/CentOS\ 7\ x86_64/baseurl=http://192.168.134.138/centos/$releasever/os/$basearchgpgcheck=0 ## yum 调用文件路径：123456mirrorlist=http://192.168.134.138/list.txt[root@centos7 html]# lscentos list.txt[root@centos7 html]# cat list.txtfile:///var/www/html/centos/7/os/x86_64baseurl=http://192.168.134.138/centos/$releasever/os/$basearch ## 源码编译 123456789101112yum groupinstall &quot;development tools&quot;tar xf cmatrix-1.2a.tar.gzcd cmatrix-1.2a./configure --prefix=/app/cmatrixmake &amp;&amp; make installyum install -y ncurses-devel(缺的包)make &amp;&amp; make installcd /app/cmtrix/bin./cmatrix 写入PATHecho &apos;PATH=/app/httpd/bin:$PATH&apos; &gt; /etc/profile.d/httpd.sh. /etc/profile.d/httpd.sh # centos7:支持神奇目录：rpm -q autofssystemctl enabled autofssystemctl start autofs`建立仓库元数据：createrepo /data/repodbyum仓库必须要仓库元数据才能使用 centos 防火墙cnetos7:下次开机不启用 systemctl disable firewalld现在马上关掉：systemctl stop firewalld centos6:chkconfig iptables offservice iptables stop]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[blog 本博客从2018年7月左右开始搭建,博客所有搭建过程及修改均来自于互联网。本站使用基于 Node.js 的 Hexo 博客框架，托管于 Github,由 腾讯云 提供 DNS 解析服务 me 19年毕业，专业是计算机网络(学了很讨厌)。现在正在一边实习，一边学习网络linux课程,希望可以早日拿到阿里云认证。 爱好:写博客，改博客 美剧 动漫 switch you 想要交流，可以留言]]></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
